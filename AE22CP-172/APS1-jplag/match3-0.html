<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>1881906</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>1881906_main.c</CENTER></H3><HR>
<PRE>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;


typedef struct {
    int* data;     // vetor que armazenará os inteiro;
    int  size;     // tamanho atual do vetor
    int  capacity; // tamanho reservado em memória 
} vector;


vector* new_vector(int inital_size);
void free_vector(vector* v);
void resize(vector* v);
void vector_push_back(vector* v, int value);
void vector_push_front(vector* v, int value);
void vector_print(vector* v);
int* vector_at(vector* v, int i);
int vector_get(vector* v, int i);
int vector_set(vector* v, int value, int i);
int vector_insert(vector* v, int value, int i);
int vector_pop_front(vector* v);
int vector_erase(vector* v, int i);
int vector_pop_back(vector* v);

int main(int argc, char const *argv[])
{
	int x;
	scanf(&quot;%d&quot;, &amp;x);				// x recebe valor da primeira linha lida : capacidade inicial

	vector* vetor1 = new_vector(x);

	scanf(&quot;%d&quot;, &amp;x);				// x recebe valor da segunda linha lida : quantidade de comandos

	int i; 							// aux do laço for
	char comando[20];
	for(i = 0; i &lt;x; i++)
	{
		scanf(&quot;%s&quot;, comando);			// le comando

		// agora comando contem a função que deve ser chamada.
		// dentro de cada função, devemos ler o numero correto de argumentos

		if (!strcmp(comando, &quot;insert&quot;))
		{	
			int arg1, arg2, r;
			scanf(&quot;%d&quot;, &amp;arg1);
			scanf(&quot;%d&quot;, &amp;arg2);
			r = vector_insert(vetor1,arg1,arg2);
			
			if (r == -1)
			{
				printf(&quot;Erro posição %d não existe no vetor\n&quot;, arg2);
			}
			
		}

		if (!strcmp(comando,&quot;push_front&quot;))
		{
			int arg;
			scanf(&quot;%d&quot;, &amp;arg);
			vector_push_front(vetor1, arg);
			//vector_print(vetor1);
		}

		if (!strcmp(comando,&quot;push_back&quot;))
		{
			int arg;
			scanf(&quot;%d&quot;, &amp;arg);
			vector_push_back(vetor1,arg);
			//vector_print(vetor1);
		}

		if (!strcmp(comando,&quot;pop_back&quot;))
		{
			int r = vector_pop_back(vetor1);
			if(r == -1)
			{
				printf(&quot;Erro - vetor não tem elementos&quot;);
			}
		}
		if (!strcmp(comando,&quot;erase&quot;))
		{
			int arg;
			scanf(&quot;%d&quot;, &amp;arg);
			vector_erase(vetor1,arg);
		}
		if (!strcmp(comando,&quot;set&quot;))
		{	
			int arg1, arg2;
			scanf(&quot;%d&quot;, &amp;arg1); // posição 
			scanf(&quot;%d&quot;, &amp;arg2); // valor
			vector_set(vetor1, arg2, arg1);
		}
		if (!strcmp(comando,&quot;pop_front&quot;))
		{
			vector_pop_front(vetor1);
		}

		vector_print(vetor1);
	}

	free_vector(vetor1);

	return 0;
}




// funções do vector
//cria vector
vector* new_vector(int inital_size)
{
	vector* nv = malloc(sizeof(vector));

	nv-&gt;data = malloc(sizeof(int)*inital_size);
	nv-&gt;size = 0;
	if(inital_size == 0)
	{
		nv-&gt;capacity = 4;
	}
	else 
	{
		nv-&gt;capacity = inital_size;	
	}
	

	return nv;
}
//destroi vector
void free_vector(vector* v)
{
	free(v-&gt;data);  // cada malloc deve ter um free
	free(v);
}

//realoca vector
void resize(vector* v)
{
<A NAME="0"></A>	v-&gt;capacity = v-&gt;capacity * 2;
	v-&gt;data = realloc(v-&gt;data,sizeof(int)* v-&gt;capacity);
	
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match3-1.html#0',3,'match3-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}


//funções de inserção
void vector_push_back(vector* v, int value)
{
	if (v-&gt;size == v-&gt;capacity)
	{
		resize(v);
	}

	v-&gt;data[v-&gt;size] = value;
	v-&gt;size++;
}

void vector_push_front(vector* v, int value)
{</B></FONT>
	if(v-&gt;size == v-&gt;capacity)
	{
		resize(v);
	}

	int i;
	for (i=v-&gt;size-1;i&gt;=0;i--)
	{
		v-&gt;data[i+1] = v-&gt;data[i];
	}

	v-&gt;data[0] = value;
	v-&gt;size++;

}

int vector_insert(vector* v, int value, int i)
{
	if (i &gt; v-&gt;size)   				// se i apontar para fora do vetor, retorna erro
	{
		return -1;
	}
	
	if(v-&gt;size == v-&gt;capacity)
	{
		resize(v);
	}

    if(i == 0)
    {
        vector_push_front(v, value);
    }
    else
    {
        int o;
    
	   for(o = v-&gt;size-1; o &gt;= i; o--)
	   {
		  v-&gt;data[o+1] = v-&gt;data[o];
	   }

	   v-&gt;data[i] = value; 
	   v-&gt;size++;
    }

	return(1);
}

// funções de obtenção de dados do vector	
int vector_set(vector* v, int value, int i)
{
	if (i &gt; v-&gt;capacity)
	{
		return -1;
	}
	
	v-&gt;data[i] = value;
	return 1;
}

int* vector_at(vector* v, int i)
{
	return(&amp;v-&gt;data[i]);
}

int  vector_get(vector* v, int i)
{
	return(v-&gt;data[i]);
}

//Funções de remoção 
// Remove o elemento do fim do vetor, decrementando size.
int vector_pop_back(vector* v)
{
	if(v-&gt;size == 0)
	{
		return(-1);
	}

	v-&gt;size --;
	return(1);
	//return(v-&gt;data[v-&gt;size+1];);
}

// Remove o elemento na posição i, e move os posteriores para trás
int vector_erase(vector* v, int i)
{
	if(i &gt; v-&gt;size)
	{
		return -1;
	}

	// se precisar imprimir dado removido, returne u.
	int u;
	u= v-&gt;data[i];

	for(; i &lt; v-&gt;size-1; i++)
	{
		v-&gt;data[i] = v-&gt;data[i+1];
	}

	v-&gt;size --;

	return 1; 

}
// Remove o elemento na posição zero do vetor e move os posteriores para trás
int vector_pop_front(vector* v)
{
	if(v-&gt;size == 0)
	{
		return -1;
	}

	// se precisar imprimir dado removido, returne u.
	int u, i;
	u= v-&gt;data[0];

	i= vector_erase(v,0);
	return 0; 
}

//Imprimir vetor
void vector_print(vector* v)
{
	//[size/capacity] data[0] data[1] data[2] ... data[size] \n
	printf(&quot;[%d/%d] &quot;,v-&gt;size,v-&gt;capacity);
	
	int i;
	for (i = 0; i &lt; v-&gt;size; i++)
	{
		printf(&quot;%d &quot;,v-&gt;data[i]);
	}
	printf(&quot;\n&quot;);

}
</PRE>
</BODY>
</HTML>
