<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jean P. Martins</title>
    <description>Combinatorial optimization, evolutionary optimization, estimation of distribution algorithms, linkage learning, learning and optimization.
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 28 Oct 2017 23:43:35 -0200</pubDate>
    <lastBuildDate>Sat, 28 Oct 2017 23:43:35 -0200</lastBuildDate>
    <generator>Jekyll v3.4.3</generator>
    
      <item>
        <title>FAQ</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#segmentation-fault&quot; id=&quot;markdown-toc-segmentation-fault&quot;&gt;Segmentation Fault&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo-1&quot; id=&quot;markdown-toc-exemplo-1&quot;&gt;Exemplo 1&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo-2&quot; id=&quot;markdown-toc-exemplo-2&quot;&gt;Exemplo 2&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#programação-estruturada&quot; id=&quot;markdown-toc-programação-estruturada&quot;&gt;Programação estruturada&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#função-list_sizel&quot; id=&quot;markdown-toc-função-list_sizel&quot;&gt;Função &lt;code class=&quot;highlighter-rouge&quot;&gt;list_size(l)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;segmentation-fault&quot;&gt;Segmentation Fault&lt;/h1&gt;

&lt;p&gt;Se seu código está dando falha de segmentação, rode ele dentro do gdb, em muitos casos nem é preciso procurar o erro passo a passo, pois o gdb mostra informações de onde a falha de segmentação ocorreu.&lt;/p&gt;

&lt;h2 id=&quot;exemplo-1&quot;&gt;Exemplo 1&lt;/h2&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;@:~$ &lt;/span&gt;./list &amp;lt; input/input02.txt 
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1] 35 
Falha de segmentação &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;imagem &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;núcleo gravada&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Esta saída não nos dá informação suficiente para a correção do erro. Portanto, utilizarei o gdb. Primeiro passo, compilar com a flag &lt;code class=&quot;highlighter-rouge&quot;&gt;-g&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;@:~$ &lt;/span&gt;gcc main.c list.c -o list -g
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Após isso, inicializar o gdb passando o executável como parâmetro&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;@:~$ &lt;/span&gt;gdb ./list
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;A seguir, utilizar o comando &lt;code class=&quot;highlighter-rouge&quot;&gt;run&lt;/code&gt; do gdb para iniciar a execução do programa.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; run ./list &amp;lt; input/input02.txt &amp;gt; out
Starting program: ./list &amp;lt; input/input02.txt &amp;gt; out
 
Program received signal SIGSEGV, Segmentation fault.
0x00000000004009fb &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;list_erase &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0x7fffffffdfd0, &lt;span class=&quot;nv&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; at list.c:101
101        n-&amp;gt;next&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;j-&amp;gt;next;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Desta saída, podemos focar apenas em algumas partes.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Program received signal SIGSEGV, Segmentation fault.
&lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;list_erase &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;v, &lt;span class=&quot;nv&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; at list.c:101
101        n-&amp;gt;next&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;j-&amp;gt;next;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;SIGSEGV, é uma constante representando o tipo de erro, neste caso &lt;em&gt;segmentation fault&lt;/em&gt;, que se refere à tentativa de acesso de memória não permitido: além dos limites de um vetor, ou em posições de memória que não foram alocadas pelo programador.&lt;/p&gt;

&lt;p&gt;Note, que &lt;code class=&quot;highlighter-rouge&quot;&gt;list_erase (v, i=1)&lt;/code&gt;, nos diz que o erro aconteceu na função &lt;code class=&quot;highlighter-rouge&quot;&gt;list_erase&lt;/code&gt;, quando recebendo a posição &lt;code class=&quot;highlighter-rouge&quot;&gt;i=1&lt;/code&gt; e nos mostra também a linha exata onde a falha de segmentação aconteceu.&lt;/p&gt;

&lt;h2 id=&quot;exemplo-2&quot;&gt;Exemplo 2&lt;/h2&gt;

&lt;p&gt;Seguiremos o mesmo procedimento descrito anteriormente.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;@:~$ &lt;/span&gt;./list &amp;lt; input/input03.txt 
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1] 68
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;2] 68 98
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;3] 16 68 98
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;2] 68 98
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1] 98
Falha de segmentação &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;imagem &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;núcleo gravada&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;@:~$ &lt;/span&gt;gdb ./list
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; run ./list &amp;lt; input/input03.txt 
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1] 68
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;2] 68 98
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;3] 16 68 98
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;2] 68 98
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1] 98
 
Program received signal SIGSEGV, Segmentation fault.
0x0000000000400acb &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;list_pop_back &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0x604020&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; at list.c:183
183 &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;ptr-&amp;gt;next-&amp;gt;next !&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; NULL&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Neste exemplo, a falha de segmentação ocorreu na linha 183, na função &lt;code class=&quot;highlighter-rouge&quot;&gt;list_pop_back&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;in list_pop_back (l=0x604020) at list.c:183
183 while(ptr-&amp;gt;next-&amp;gt;next != NULL)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Como sabemos, &lt;em&gt;segmentation fault&lt;/em&gt; indica acesso indevido de memória. Portanto podemos imaginar que algo errado com a operação&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;183 while(ptr-&amp;gt;next-&amp;gt;next != NULL)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;O que aconteceria se &lt;code class=&quot;highlighter-rouge&quot;&gt;ptr-&amp;gt;next&lt;/code&gt; for &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt;? Bom, neste caso, ao tentar acessar o próximo &lt;code class=&quot;highlighter-rouge&quot;&gt;-&amp;gt;next&lt;/code&gt;, estariamos acessando o endereço indicado por &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt;, e lá procurando o campo &lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt;, algo como: &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL-&amp;gt;next&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Como &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt; é usualmente definido como o endereço &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; da memória, qualquer acesso a esse endereço levará à falha de segmentação. Portanto, sempre que houver falha de segmentação, a primeira suspeita deve ser:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Acesso fora dos limites de um vetor&lt;/li&gt;
  &lt;li&gt;Acesso (dereferenciamento) ao endereço &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;programação-estruturada&quot;&gt;Programação estruturada&lt;/h1&gt;

&lt;h2 id=&quot;função-list_sizel&quot;&gt;Função &lt;code class=&quot;highlighter-rouge&quot;&gt;list_size(l)&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;“Se a estrutura de dados &lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt; duplamente encadeada já possui um campo &lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;, qual a necessidade da função &lt;code class=&quot;highlighter-rouge&quot;&gt;list_size()&lt;/code&gt;.”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Em algumas situações certas funções parecem desnecessárias, é o caso do &lt;code class=&quot;highlighter-rouge&quot;&gt;list_size()&lt;/code&gt;. Para entender o porque de sua utilidade, é bom pensarmos em termos da lista como estrutura abstrata, a qual tem uma interface &lt;code class=&quot;highlighter-rouge&quot;&gt;list.h&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Nesse sentido, ambas implementações, “lista simples”, “listas duplas”, teriam uma implementação de &lt;code class=&quot;highlighter-rouge&quot;&gt;list_size()&lt;/code&gt;. Nas listas simples, preciso percorrer toda lista para saber o tamanho, nas duplas, basta acessar o size já existente. Algo desse tipo&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// forward_list.c
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;list_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// list.c
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;list_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Agora suponha que estejamos utilizando uma estrutura lista para resolver algum problema, soma/multiplicação de inteiros grandes, splice, por exemplo.&lt;/p&gt;

&lt;p&gt;Neste caso, se sempre que precisarmos saber o tamanho de uma lista, utilizarmos &lt;code class=&quot;highlighter-rouge&quot;&gt;list_size()&lt;/code&gt; (e as demais funções de acesso a lista), isso nos permitiria utilizar tanto a implementação da lista de encadeamento simples (&lt;code class=&quot;highlighter-rouge&quot;&gt;forward_list.c&lt;/code&gt;) quanto a de encadeamento duplo (&lt;code class=&quot;highlighter-rouge&quot;&gt;list.c&lt;/code&gt;). Bastando escolher durante a compilação.&lt;/p&gt;

&lt;p&gt;Se pelo contrário, eu utilizasse &lt;code class=&quot;highlighter-rouge&quot;&gt;l-&amp;gt;size&lt;/code&gt; diretamente, eu não conseguiria utilizar a implementação &lt;code class=&quot;highlighter-rouge&quot;&gt;forward_list.c&lt;/code&gt;, visto que nela, esse campo não existe.&lt;/p&gt;

&lt;p&gt;Portanto, a ideia de termos várias funções para acessar certas propriedades da estrutura, nos permite separar a implementação da definição da estrutura de dados. Isso é sugerido quando programamos pensando em reutilização, e programação de bibliotecas.&lt;/p&gt;

&lt;p&gt;Obviamente, podemos também querer implementar uma lista para algo bem específico, sem pensar que tal código será reutilizado para várias coisas diferentes, e então, não precisaríamos nos preocupar com isso.&lt;/p&gt;

&lt;p&gt;Em geral é essa a ideia, e se aplica ao uso das demais funções também.&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Dec 2017 13:50:00 -0200</pubDate>
        <link>http://localhost:4000/ae22cp-172/FAQ.html</link>
        <guid isPermaLink="true">http://localhost:4000/ae22cp-172/FAQ.html</guid>
        
        <category>faq</category>
        
        
        <category>AE22CP-172</category>
        
      </item>
    
      <item>
        <title>Lógica de predicados - Identidade</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#identidades&quot; id=&quot;markdown-toc-identidades&quot;&gt;Identidades&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplos&quot; id=&quot;markdown-toc-exemplos&quot;&gt;Exemplos&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#introdução-da-identidade&quot; id=&quot;markdown-toc-introdução-da-identidade&quot;&gt;Introdução da identidade&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplos-1&quot; id=&quot;markdown-toc-exemplos-1&quot;&gt;Exemplos&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#eliminação-da-identidade&quot; id=&quot;markdown-toc-eliminação-da-identidade&quot;&gt;Eliminação da identidade&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;identidades&quot;&gt;Identidades&lt;/h1&gt;

&lt;p&gt;Na lógica de predicados podemos definir um predicado $I(x,y)$ para denotar a igualdade entre $x$ e $y$.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$I(x,y)$: $x$ igual a $y$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;No entanto, por esse predicado ser de uso bastante comum, se torna às vezes conveniente representá-lo de forma mais compacta. O mesmo aconteceria se quiséssemos definir um predicado $M(x,y)$ para denotar $x$ é menor que $y$. Como tais predicados são comumente representado pelos símbolos $=$ e $&amp;lt;$ não há motivos para que não utilizemos os mesmos símbolos também na linguagem da lógica de predicados.&lt;/p&gt;

&lt;p&gt;Enquanto a letra ‘I’ pode ser utilizada para denotar o predicado de igualdade/identidade, ou seja $I(x,y)$ indicando a igualdade entre $x$ e $y$; ela também poderia ser utilizada em outras situações para denotar outro predicado qualquer, exemplo $I(x)$ indicando que $x$ é impar. Por outro lado, o símbolo ‘=’ também representa o predicado identidade, no entanto, ele nunca assumirá um significado diferente, ou seja, é um símbolo específico para representar o predicado de igualdade.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$x=y$: $x$ igual a $y$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Diferentemente dos demais predicados, $=$ é utilizado na forma infixa, ou seja, entre os operandos. Isso facilita pois mantém a forma de representação convencionalmente utilizada nas demais áreas da matemática.&lt;/p&gt;

&lt;h2 id=&quot;exemplos&quot;&gt;Exemplos&lt;/h2&gt;

&lt;p&gt;Formalize as seguintes sentenças utilizando o predicado identidade ‘$=$’&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$a$: Álvaro de Campos&lt;/li&gt;
  &lt;li&gt;$t$: Tabacaria&lt;/li&gt;
  &lt;li&gt;$f$: Fernando Pessoa&lt;/li&gt;
  &lt;li&gt;$A(x)$: $x$ é um autor português&lt;/li&gt;
  &lt;li&gt;$M(x,y)$: $x$ é melhor autor que $y$&lt;/li&gt;
  &lt;li&gt;$E(x,y)$: $x$ escreveu $y$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;a. Fernando Pessoa não é Álvaro de Campos&lt;/p&gt;

&lt;p&gt;b. Existe Fernando Pessoa&lt;/p&gt;

&lt;p&gt;c. Se Fernando Pessoa é Álvaro de Campos, então Álvaro de Campos escreveu Tabacaria&lt;/p&gt;

&lt;p&gt;d. Somente Fernando Pessoa escreveu Tabacaria&lt;/p&gt;

&lt;p&gt;e. Fernando Pessoa é o melhor autor português&lt;/p&gt;

&lt;p&gt;f. Existem ao menos duas coisas diferentes.&lt;/p&gt;

&lt;p&gt;g. Existe somente uma coisa.&lt;/p&gt;

&lt;p&gt;h. Existem exatamente duas coisas.&lt;/p&gt;

&lt;h2 id=&quot;introdução-da-identidade&quot;&gt;Introdução da identidade&lt;/h2&gt;

&lt;p&gt;Para qualquer letra nominal $\alpha$, podemos sempre introduzir a identidade $\alpha = \alpha$. Esse tipo de regra é útil para produzir exemplos para outras regras de derivação. Considere, por exemplo, a introdução dos quantificadores universal e existencial, a introdução de ambos depende da existência de um exemplo.&lt;/p&gt;

&lt;p&gt;Para o quantificador universal, esse exemplo deve utilizar uma letra nominal genérica, de modo que seja possível generalizar a afirmação. Nesse caso, uma instância/exemplo $Fa\land Ga$ pode ser generalizada à $\forall x (Fx \land Gx)$, desde que não haja restrições quanto à letra $a$.&lt;/p&gt;

&lt;p&gt;Para o quantificador existencial, por outro lado, o funcionamento é mais simples. Se tivermos um exemplo, então podemos generalizá-lo. Deste modo, a partir de $(Fa\land Ga)$ podemos imediatamente concluir $\exists x(Fx \land Gx)$.&lt;/p&gt;

&lt;h3 id=&quot;exemplos-1&quot;&gt;Exemplos&lt;/h3&gt;

&lt;p&gt;Dada a interpretação acima, como demonstraríamos os seguintes argumentos?&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall x (x=x)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \exists x (a=x)&lt;/script&gt;

&lt;h2 id=&quot;eliminação-da-identidade&quot;&gt;Eliminação da identidade&lt;/h2&gt;

&lt;p&gt;A regra de eliminação da identidade é apenas uma formalização da nossa intuição. Se duas coisas são iguais, posso utilizar tanto uma quanto a outra em qualquer situação.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Fa, a=b \vdash Fb&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Fa, \neg Fb \vdash \neg (a = b)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall x \forall y (x=y)\to(y=x)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall x \forall y \forall z (x=y\land y=z)\to (x=z))&lt;/script&gt;
</description>
        <pubDate>Thu, 26 Oct 2017 10:20:00 -0200</pubDate>
        <link>http://localhost:4000/lc21cp-172/lp-identidade.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/lp-identidade.html</guid>
        
        <category>predicados</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
      <item>
        <title>PROVA 2</title>
        <description>&lt;p&gt;&lt;strong&gt;NOME:&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;equivalências&quot;&gt;Equivalências&lt;/h1&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;$\phi\to\psi$&lt;/td&gt;
      &lt;td&gt;$\neg\phi\lor\psi$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;$\phi\leftrightarrow\psi$&lt;/td&gt;
      &lt;td&gt;$(\phi\land\psi)\lor(\neg\phi\land\neg\psi)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;$\neg(\phi\land\psi)$&lt;/td&gt;
      &lt;td&gt;$\neg\phi \lor \neg \psi$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;$\neg(\phi\lor\psi)$&lt;/td&gt;
      &lt;td&gt;$\neg\phi\land\neg\psi$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;$\neg(\phi\to\psi)$&lt;/td&gt;
      &lt;td&gt;$\phi\land \neg \psi$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;$\neg(\phi\leftrightarrow\psi)$&lt;/td&gt;
      &lt;td&gt;$(\phi\land \neg\psi)\lor (\neg\phi\land\psi)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;(2,0pts)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; Verifique se as formas de argumento a seguir são válidas ou inválidas utilizando árvores de refutação.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \vdash (p\to (q\land p)) \to (p\land q)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(q\land r)\to p, \neg q, \neg r \vdash \neg p&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg(p\land q), r \leftrightarrow p \vdash \neg r&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p\leftrightarrow q, q \leftrightarrow r \vdash p \leftrightarrow r&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;(2,0pts)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; Verifique se as fórmulas a seguir são tautologias utilizando árvores de refutação.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \leftrightarrow \neg(p\lor q)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\land q) \land \neg(p\lor r)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\land q) \to p&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg((p\land q) \leftrightarrow(p\lor q))&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\to(q\land r)) \to (p\to r)&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;(1,0pt)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; Reescreva as sentenças a seguir como fórmulas da lógica de predicados. Utilize os predicados:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$A(x,y)$ : $x$ ama $y$&lt;/li&gt;
  &lt;li&gt;$L(x,y)$ : $x$ é mais alto que $y$&lt;/li&gt;
  &lt;li&gt;“Benedito”: $b$&lt;/li&gt;
  &lt;li&gt;“Cassandra”: $c$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;a. Para quaisquer três objetos, se o primeiro é mais alto que o segundo e o segundo mais alto que o terceiro, então o primeiro é mais alto que o terceiro.&lt;/p&gt;

&lt;p&gt;b. Todo mundo é amado por alguém&lt;/p&gt;

&lt;p&gt;c. Benedito e Cassandra amam todo mundo.&lt;/p&gt;

&lt;p&gt;d. Se alguém ama o Benedito então Cassandra ama esse alguém.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(4,0pts)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; Demonstre 5 das seguintes formas de argumento da lógica de predicados.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x (Fx \land Gx) \vdash \forall x (Fx \to \neg Gx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(\neg Fx \lor \neg Gx) \vdash \neg(Fa \land Ga)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(Fx \to Gx) \vdash \forall x(\neg Gx \to \neg Fx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \forall y(Fxy \to \neg Fyx) \vdash \forall x \neg Fxx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x (Fx \land Gx) \vdash \forall x (\neg Fx \lor \neg Gx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \forall x(Fx \land Gx) \vdash \exists x(\neg Fx \lor \neg Gx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x \exists y Lxy \vdash \forall x \neg Lxx&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;(1,0pts)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt; Descreva em linguagem natural cada uma das fórmulas e as reescreva utilizando outro quantificador&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \forall x \neg Fx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists x \neg Fx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \neg Fx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x \neg Fx&lt;/script&gt;

</description>
        <pubDate>Wed, 25 Oct 2017 10:20:00 -0200</pubDate>
        <link>http://localhost:4000/lc21cp-172/PROVA2.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/PROVA2.html</guid>
        
        <category>predicados</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
      <item>
        <title>APS3 - Algoritmos de ordenação</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#objetivos&quot; id=&quot;markdown-toc-objetivos&quot;&gt;Objetivos&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#motivação&quot; id=&quot;markdown-toc-motivação&quot;&gt;Motivação&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#experimentos&quot; id=&quot;markdown-toc-experimentos&quot;&gt;Experimentos&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#cenários-de-experimentação&quot; id=&quot;markdown-toc-cenários-de-experimentação&quot;&gt;Cenários de experimentação&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#experimentos-1&quot; id=&quot;markdown-toc-experimentos-1&quot;&gt;Experimentos&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#análise-dos-resultados&quot; id=&quot;markdown-toc-análise-dos-resultados&quot;&gt;Análise dos resultados&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;objetivos&quot;&gt;Objetivos&lt;/h1&gt;

&lt;p&gt;Comparar experimentalmente os algoritmos de ordenação em diferentes cenários. Identificar a relação entre os tipos de entradas e a eficiência desses algoritmos.&lt;/p&gt;

&lt;h1 id=&quot;motivação&quot;&gt;Motivação&lt;/h1&gt;

&lt;p&gt;Aprender a identificar qual algoritmo utilizar para ordenação de dados em um determinado contexto.&lt;/p&gt;

&lt;h1 id=&quot;experimentos&quot;&gt;Experimentos&lt;/h1&gt;

&lt;p&gt;Todos algoritmos deverão ser executados para os mesmos casos de teste e depois comparados quanto ao&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;tempo médio&lt;/strong&gt;,&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;número de comparações&lt;/strong&gt;,&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;número de trocas&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Deste modo, a primeira etapa do trabalho consiste em adaptar seus códigos para que a cada execução esses três dados sejam coletados/contabilizados.&lt;/p&gt;

&lt;h1 id=&quot;cenários-de-experimentação&quot;&gt;Cenários de experimentação&lt;/h1&gt;

&lt;p&gt;Os algoritmos serão avaliados em quatro cenários. Cada cenário representará um tipo de sequência de entrada.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Sequências aleatórias,&lt;/li&gt;
  &lt;li&gt;Sequências ordenadas de forma crescente&lt;/li&gt;
  &lt;li&gt;Sequências ordenadas de forma decrescente&lt;/li&gt;
  &lt;li&gt;Sequências quase ordenadas&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Consideraremos que uma sequência quase ordenada é gerada por dois passos principais.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Gerar uma sequência ordenada,&lt;/li&gt;
  &lt;li&gt;Efetuar um certo número de trocas aleatórias
    - O número de trocas deve equivaler a 15% do tamanho da sequência.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;experimentos-1&quot;&gt;Experimentos&lt;/h1&gt;

&lt;p&gt;Cada um dos cenários acima serão avaliados seguindo o mesmo planejamento de experimentos. Como exemplo, podemos considerar o caso de sequências &lt;em&gt;aleatórias&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Queremos avaliar o desempenho dos algoritmos para sequências de tamanhos diferentes, então neste contexto a primeira etapa seria definirmos quais tamanhos de sequências farão parte dos experimentos. É importante que possamos avaliar os algoritos em sequências pequenas e grandes, portanto os tamanhos utilizados devem atender essa demanda.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sugestão de tamanhos $n(x) = 10 \times 2^x$.&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$x$&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$n$&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;40&lt;/td&gt;
      &lt;td&gt;80&lt;/td&gt;
      &lt;td&gt;160&lt;/td&gt;
      &lt;td&gt;320&lt;/td&gt;
      &lt;td&gt;640&lt;/td&gt;
      &lt;td&gt;1280&lt;/td&gt;
      &lt;td&gt;2560&lt;/td&gt;
      &lt;td&gt;5120&lt;/td&gt;
      &lt;td&gt;10240&lt;/td&gt;
      &lt;td&gt;20480&lt;/td&gt;
      &lt;td&gt;40960&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Os experimentos terão que ser repetidos para cada $n$.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Vamos assumir, como exemplo, o caso de $n=20$. Cada algoritmo deverá ser executado em sequências de tamanho $n$, porém, como estamos estamos interessados no comportamento médio do algoritmo, não podemos executá-lo apenas uma vez. Deste modo, cada algoritmo deverá ser executado um determinado número $N$ de vezes com sequências diferentes de tamanho $n$, $N$ é chamado &lt;em&gt;número de experimentos&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sugestão para o número de experimentos $N$: $30 \leq N \leq 100$.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Cada execução de um algoritmo &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; com as sequências aleatórias (&lt;code class=&quot;highlighter-rouge&quot;&gt;rand&lt;/code&gt;) de um determinado tamanho $n$ (&lt;code class=&quot;highlighter-rouge&quot;&gt;20&lt;/code&gt;), produzirá três dados:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;num. comparações&lt;/em&gt;,&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;num. trocas&lt;/em&gt;,&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;tempo&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;17823812 123213 0.2345
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;O conjunto de $N$ execuções produzirá então, um arquivo de saída &lt;code class=&quot;highlighter-rouge&quot;&gt;rand_20_A.out&lt;/code&gt;, com $N$ linhas, cada uma delas representando um experimento.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;17823812 123213 0.2345
17823812 123213 0.2345
...
17823812 123213 0.2345
17823812 123213 0.2345
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Suponha que estejamos comparando quatro algoritmos: &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;D&lt;/code&gt;. Ao repetirmos o procedimento acima para cada um deles, teremos produzido quatro arquivos:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rand_20_A.out&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rand_20_B.out&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rand_20_C.out&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rand_20_D.out&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tais nomes foram escolhidos pois são informativos sobre o experimento que eles representam. O prefixo &lt;code class=&quot;highlighter-rouge&quot;&gt;rand&lt;/code&gt; indica que a sequência foi gerada aleatoriamente, o infixo &lt;code class=&quot;highlighter-rouge&quot;&gt;20&lt;/code&gt; indica o tamanho dessas sequências, e o sufixo &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, indica o algoritmo.&lt;/p&gt;

&lt;h1 id=&quot;análise-dos-resultados&quot;&gt;Análise dos resultados&lt;/h1&gt;

&lt;p&gt;Esses arquivos contém os dados brutos dos experimentos. Podemos a partir deles iniciar a análise dos resultados. Primeiro passo é calcular a média de cada coluna. No exemplo, acima, a média de cada coluna em cada um dos arquivos produzirá três valores.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rand_20_A.out&lt;/code&gt;, média das colunas:
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;17823812 123213 0.2345
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rand_20_B.out&lt;/code&gt;, média das colunas:
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;89898923 1342213 2.2345
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rand_20_C.out&lt;/code&gt;, média das colunas:
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;123812 123213 9.2345
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rand_20_D.out&lt;/code&gt;, média das colunas:
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;948812 99213 11.2345
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Com esses novos valores (médias), podemos inciar a popular nossos gráficos, um para cada dado sendo avaliado. Nos gráficos abaixo inserimos os pontos referentes aos valores médios de &lt;em&gt;comparações&lt;/em&gt;, &lt;em&gt;trocas&lt;/em&gt; e &lt;em&gt;tempo&lt;/em&gt; obtidos para sequências aleatórias de tamanho $20$. Portanto, todos os pontos ficam na mesma coluna (posição 20 no eixo $x$).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/AE22CP/rand_20.png&quot; alt=&quot;rand_20&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ao efetuarmos esses mesmos experimentos mas agora com os demais tamanhos de sequência, teremos vários outros pontos para popular o gráfico, indicando o comportamento dos algoritmos com os diferentes tamanhos de sequência.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/AE22CP/rand_20_todos.png&quot; alt=&quot;rand_20&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 20 Oct 2017 13:50:00 -0200</pubDate>
        <link>http://localhost:4000/ae22cp-172/APS3-ordenacao.html</link>
        <guid isPermaLink="true">http://localhost:4000/ae22cp-172/APS3-ordenacao.html</guid>
        
        <category>ordenação</category>
        
        
        <category>AE22CP-172</category>
        
      </item>
    
      <item>
        <title>Lógica de predicados - Teoremas e regras de equivalência</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#teoremas&quot; id=&quot;markdown-toc-teoremas&quot;&gt;Teoremas&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo-1&quot; id=&quot;markdown-toc-exemplo-1&quot;&gt;Exemplo 1&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo-2&quot; id=&quot;markdown-toc-exemplo-2&quot;&gt;Exemplo 2&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo-3&quot; id=&quot;markdown-toc-exemplo-3&quot;&gt;Exemplo 3&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#equivalências&quot; id=&quot;markdown-toc-equivalências&quot;&gt;Equivalências&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo-1-1&quot; id=&quot;markdown-toc-exemplo-1-1&quot;&gt;Exemplo 1&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo-2-1&quot; id=&quot;markdown-toc-exemplo-2-1&quot;&gt;Exemplo 2&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo-3-1&quot; id=&quot;markdown-toc-exemplo-3-1&quot;&gt;Exemplo 3&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#intercâmbio-de-quantificadores&quot; id=&quot;markdown-toc-intercâmbio-de-quantificadores&quot;&gt;Intercâmbio de quantificadores&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#variáveis-abertas-e-fechadas&quot; id=&quot;markdown-toc-variáveis-abertas-e-fechadas&quot;&gt;Variáveis abertas e fechadas&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo&quot; id=&quot;markdown-toc-exemplo&quot;&gt;Exemplo&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#qual-a-utilidade&quot; id=&quot;markdown-toc-qual-a-utilidade&quot;&gt;Qual a utilidade?&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-1&quot; id=&quot;markdown-toc-exemplo-1&quot;&gt;Exemplo&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;teoremas&quot;&gt;Teoremas&lt;/h1&gt;

&lt;p&gt;Assim como na lógica proposicional, existem fórmulas na lógica de predicados que podem ser demonstradas sem a necessidade de premissas. Tais fórmulas, chamadas &lt;em&gt;teoremas&lt;/em&gt;, são verdades lógicas, ou seja sua verdade é necessária de acordo com as regras da lógica de predicados. Todos os teoremas da lógica proposicional são, também, teoremas na lógica de predicados.&lt;/p&gt;

&lt;h2 id=&quot;exemplo-1&quot;&gt;Exemplo 1&lt;/h2&gt;

&lt;p&gt;O condicional quando aplicado a antecedente e consequente iguais é um teorema na lógica proposicional, $p \to p$, sendo portanto representado em forma de argumento sem premissas&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash p \to p \alpha 3&lt;/script&gt;

&lt;p&gt;Na lógica de predicados temos a versão generalizada deste teorema, a qual é produzida pela introdução do quantificador universal.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall x (Fx\to Fx)&lt;/script&gt;

&lt;p&gt;A demonstração deste teorema segue a estratégia utilizada para demonstrarmos qualquer condicional. Assumimos como hipótese o antecedente e derivamos o consequente.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; Fa                   &amp;   \mbox{Hipótese para prova do condicional}\\
2 &amp; Fa\to Fa     &amp;  \mbox{Introdução do condicional 1}\\
3 &amp; \forall x (Fx\to Fx)             &amp;   \mbox{Introdução do universal em 2}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h2 id=&quot;exemplo-2&quot;&gt;Exemplo 2&lt;/h2&gt;

&lt;p&gt;Provemos o seguinte teorema:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall x Fx \to Fa&lt;/script&gt;

&lt;p&gt;A estratégia de demonstração é a mesma, basta observarmos que $Fa$ é uma instância da fórmula generalizada $\forall x Fx$. Portanto&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall x Fx                   &amp;   \mbox{Hipótese para prova do condicional}\\
2 &amp; \qquad Fa     &amp;  \mbox{Eliminação do universal em 1}\\
3 &amp; \forall x Fx\to Fa             &amp;   \mbox{Prova do condicional 1-2}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h2 id=&quot;exemplo-3&quot;&gt;Exemplo 3&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \neg(\forall x Fx \land \exists x \neg Fx)&lt;/script&gt;

&lt;p&gt;Neste exemplo, não é evidente qual regra de derivação utilizar. Seguindo a estratégia já mencionada anteriormente, tentaremos a demonstração por redução ao absurdo. Assumindo a negação da conclusão como hipótese&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall x Fx \land \exists x \neg Fx    &amp;   \mbox{Hipótese para redução ao absurdo}\\
2 &amp; \qquad \forall x Fx     &amp;  \mbox{Eliminação do condicional em 1}\\
3 &amp; \qquad \exists x \neg Fx     &amp;  \mbox{Eliminação do condicional em 1}\\
4 &amp; \qquad\quad \neg Fa          &amp;   \mbox{Hipótese para eliminação do existencial}\\
5 &amp; \qquad\quad Fa              &amp;    \mbox{Eliminação do universal em 2}\\
6 &amp; \qquad\quad p \land \neg p    &amp;  \mbox{Pela contradição de } Fa\\
7 &amp; \qquad p \land \neg p &amp; \mbox{Eliminação do existencial 4-6}\\
8 &amp; \neg(\forall x Fx \land \exists x \neg Fx) &amp; \mbox{Redução a absurdo 1-7}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h1 id=&quot;equivalências&quot;&gt;Equivalências&lt;/h1&gt;

&lt;p&gt;Assim como vimos para as árvores de refutação da lógica proposicional, nem sempre uma fórmula é facilmente demonstrável ou derivavel. Em alguns desses casos, no entanto, a utilização de uma fórmula equivalente facilita consideravelmente o trabalho.&lt;/p&gt;

&lt;p&gt;Para ilustrar essa ideia, como demonstraríamos o teorema a seguir?&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall x Fx \lor \exists x \neg Fx&lt;/script&gt;

&lt;p&gt;Não é evidente quais regras aplicar, visto que não temos premissas, a regra de eliminação ou introdução da disjunção não são aplicáveis. Podemos então tentar substituir essa fórmula por uma equivalente, mas qual utilizar? Na lógica proposicional demonstramos a equivalência $p \to q \dashv\vdash \neg p \lor q$, seria essa quivalência válida na lógica de predicados.&lt;/p&gt;

&lt;h2 id=&quot;exemplo-1-1&quot;&gt;Exemplo 1&lt;/h2&gt;

&lt;p&gt;Demonstre a equivalência&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x Fx \lor \exists x \neg Fx \dashv\vdash \neg\forall x Fx \to \exists x \neg Fx&lt;/script&gt;

&lt;p&gt;Dada a equivalência acima, demonstrar o teorema $\vdash \forall x Fx \lor \exists x \neg Fx$ é equivalente a demonstrar sua equivalência&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \neg\forall x Fx \to \exists x \neg Fx&lt;/script&gt;

&lt;h2 id=&quot;exemplo-2-1&quot;&gt;Exemplo 2&lt;/h2&gt;

&lt;p&gt;Demonstre a equivalência&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(Fx \to \neg Gx) \dashv\vdash \neg \exists x(Fx \land Gx)&lt;/script&gt;

&lt;h2 id=&quot;exemplo-3-1&quot;&gt;Exemplo 3&lt;/h2&gt;

&lt;p&gt;Demonstre as equivalências&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \forall x \neg Fx \dashv \vdash \exists x Fx \label{eq:1}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \forall x Fx \dashv \vdash \exists x \neg Fx \label{eq:2}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \neg Fx \dashv\vdash \neg \exists x Fx \label{eq:3}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x Fx \dashv\vdash \neg \exists x \neg Fx \label{eq:4}&lt;/script&gt;

&lt;h1 id=&quot;intercâmbio-de-quantificadores&quot;&gt;Intercâmbio de quantificadores&lt;/h1&gt;

&lt;p&gt;As últimas equivalências, descritas no Exemplo 3, são mais genéricas do que parecem à primeira vista. De fato, elas são válidas para quaiquer subfórmulas, desde que sejam subfórmulas dependentes da mesma variável. No entanto, para formalizarmos essa ideia, precisamos definir antes alguns conceitos.&lt;/p&gt;

&lt;h2 id=&quot;variáveis-abertas-e-fechadas&quot;&gt;Variáveis abertas e fechadas&lt;/h2&gt;

&lt;p&gt;Consideremos como exemplo simples a fórmula $\forall x Fx$. Pela definição das regras de formação da linguagem da lógica de predicados, sabemos que $Fx$ só faz sentido, se houver antes um quantificador discriminando $x$.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Uma fórmula é dita fechada em relação a uma variável $x$ qualquer, se existe um quantificador associado a tal variável. Exemplo: $\forall x (Fx \land Gx)$&lt;/li&gt;
  &lt;li&gt;Uma fórmula é dita aberta em relação a uma variável $x$ qualquer, se não existe quantificador que discrimine tal variável. Exemplo: $Fx \land Gx$, $\forall y Fxy$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Essa terminologia permite nos referirmos mais facilmente a fórmulas e subfórmulas com a mesma característica em termos de variáveis. Para melhor exemplificar, consideremos a equivalência $\eqref{eq:4}$ descrita anteriormente.&lt;/p&gt;

&lt;p&gt;Nela, podemos nos referir $Fx$ como uma fórmula &lt;strong&gt;aberta em $x$&lt;/strong&gt; enquanto $\forall x Fx$ é uma fórmula &lt;strong&gt;fechada em $x$&lt;/strong&gt;. Obviamente, existem diversas outras fórmulas abertas em $x$. Por exemplo $Fx\land Gx$ e $Fx\to Gx$ são ambas fórmulas abertas em $x$. Ou seja, todas elas compartilham essa mesma característica com $Fx$. Podemos então, expressar ideias como&lt;/p&gt;

&lt;p&gt;“Seja qualquer fórmula $\phi$ que seja aberta em $\beta$”.&lt;/p&gt;

&lt;p&gt;Em que $\beta$ represente qualquer variável, e.g. $x, y, z,\dots$. Isso nos permite generalizar as equivalências $\eqref{eq:1}-\eqref{eq:4}$ para além de $Fx$, da seguinte forma:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \forall \beta \neg \phi \dashv \vdash \exists \beta \phi \label{eq:5}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \forall \beta \phi \dashv \vdash \exists \beta \neg \phi&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall \beta \neg \phi \dashv\vdash \neg \exists \beta \phi&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall \beta \phi \dashv\vdash \neg \exists \beta \neg \phi \label{eq:8}&lt;/script&gt;

&lt;h2 id=&quot;exemplo&quot;&gt;Exemplo&lt;/h2&gt;

&lt;p&gt;Vejamos um exemplo da aplicação dessa generalização. Considere a forma de argumento a seguir:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x (Fx \to \neg Gx) \vdash \neg \exists x (Fx \land Gx)&lt;/script&gt;

&lt;p&gt;Neste exemplo, $(Fx\to\neg Gx)$ e $(Fx \land Gx)$ são fórmulas abertas em $x$. Se dermos um nome mais simples para cada uma delas, por exemplo, $\phi$ e $\psi$, respectivamente. Então a forma de argumento acima é instância de algo mais genérico&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \phi \vdash \exists x \psi&lt;/script&gt;

&lt;h2 id=&quot;qual-a-utilidade&quot;&gt;Qual a utilidade?&lt;/h2&gt;

&lt;p&gt;A principal utilidade desse tipo de generalização é nos permitir utilizar as equivalências em um contexto amplo, sem necessariamente ter que provar cada uma delas, mostrando que todas são instâncias dos mesmos teoremas. Em outras palavras, se:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall x \neg Fx  \leftrightarrow \neg \exists Fx&lt;/script&gt;

&lt;p&gt;Então o teorema a seguir também é verdadeiro&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall x \neg (Fx \land Gx)  \leftrightarrow \neg \exists (Fx \land Gx)&lt;/script&gt;

&lt;p&gt;pois ambos são instâncias do mesmo teorema genérico.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall \beta \neg \phi \leftrightarrow \neg \exists\beta \phi&lt;/script&gt;

&lt;p&gt;Este tipo de intercâmbio entre equivalências em muitos casos torna as demonstrações muito mais simples.&lt;/p&gt;

&lt;h3 id=&quot;exemplo-1&quot;&gt;Exemplo&lt;/h3&gt;

&lt;p&gt;Demonstre o seguinte teoremas&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall x  Fx \lor \exists x \neg Fx&lt;/script&gt;

&lt;p&gt;Iniciaremos com a tautologia&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x Fx \lor \neg \forall x Fx&lt;/script&gt;

&lt;p&gt;A subfórmula $\neg \forall x Fx$ pode ser interpretada como&lt;/p&gt;

&lt;p&gt;“Nem todo x satisfaz o predicado F”&lt;/p&gt;

&lt;p&gt;Que por sua vez é equivalente a dizermos que&lt;/p&gt;

&lt;p&gt;“Existe x que não satisfaz F”&lt;/p&gt;

&lt;p&gt;A segunda versão pode ser escrita simbolicamente como $\exists x \neg Fx$. Esta equivalência está representada em $\eqref{eq:2}$. Substituindo essa equivalência na tautologia acima, produzimos&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x Fx \lor \exists x \neg Fx&lt;/script&gt;

&lt;p&gt;O qual finaliza a demonstração do teorema.&lt;/p&gt;
</description>
        <pubDate>Wed, 18 Oct 2017 10:20:00 -0200</pubDate>
        <link>http://localhost:4000/lc21cp-172/lp-teoremas-equivalencias.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/lp-teoremas-equivalencias.html</guid>
        
        <category>predicados</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
      <item>
        <title>Algoritmos de ordenação</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#introdução&quot; id=&quot;markdown-toc-introdução&quot;&gt;Introdução&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ordenação-de-inteiros&quot; id=&quot;markdown-toc-ordenação-de-inteiros&quot;&gt;Ordenação de inteiros&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#o-que-são-algoritmos-de-ordenação&quot; id=&quot;markdown-toc-o-que-são-algoritmos-de-ordenação&quot;&gt;O que são Algoritmos de ordenação?&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#algoritmos-de-ordenação&quot; id=&quot;markdown-toc-algoritmos-de-ordenação&quot;&gt;Algoritmos de Ordenação&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#bubble-sort&quot; id=&quot;markdown-toc-bubble-sort&quot;&gt;Bubble sort&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#selection-sort&quot; id=&quot;markdown-toc-selection-sort&quot;&gt;Selection sort&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#insertion-sort&quot; id=&quot;markdown-toc-insertion-sort&quot;&gt;Insertion sort&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#quicksort&quot; id=&quot;markdown-toc-quicksort&quot;&gt;Quicksort&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#partition&quot; id=&quot;markdown-toc-partition&quot;&gt;Partition&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;introdução&quot;&gt;Introdução&lt;/h1&gt;

&lt;p&gt;A ordenação de informação tem impacto relevante em diversos aspectos do nosso cotidiano. Considere, por exemplo, a ordem alfabética em que um dicionário é organizado, ou a ordem crescente (decrescente) em que os preços de um determinado produto são exibidos em uma compra online. Nessas situações, o fato da informação estar organizada (ordenada) de um modo consistente nos permite procurar por determinado item (uma &lt;em&gt;palavra&lt;/em&gt; nos dicionários, um objeto de determinado &lt;em&gt;valor&lt;/em&gt; na lista de compras) de forma muito mais simples.&lt;/p&gt;

&lt;p&gt;Do ponto de vista computacional a ordenação de dados tem influência similar. Ao reorganizarmos a informação de forma consistente, diversas operações que poderiam ser feitas sobre o conteúdo armazenado podem, possivelmente, se tornar mais simples e eficientes.&lt;/p&gt;

&lt;p&gt;Em princípio qualquer sequência de dados pode ser ordenada. Para isso, no entanto, é necessário que exista uma &lt;a href=&quot;https://pt.wikipedia.org/wiki/Rela%C3%A7%C3%A3o_de_ordem&quot;&gt;relação de ordem&lt;/a&gt; para o conjunto dos dados a serem ordenados. Sem perda de generalidade, consideraremos que cada item $i$ na sequência a ser ordenada possui uma chave $k_i\in \mathbb{D}$, tal que essas chaves pertençam a um domínio para o qual exista uma relação de ordem $R \subseteq \mathbb{D}\times \mathbb{D}$. Exemplos de relações de &lt;a href=&quot;https://pt.wikipedia.org/wiki/Rela%C3%A7%C3%A3o_de_ordem#Rela.C3.A7.C3.B5es_de_ordem_linear_ou_total&quot;&gt;ordem totais&lt;/a&gt; mais comuns são: menor ou igual ($\leq$) e maior ou igual ($\geq$).&lt;/p&gt;

&lt;h2 id=&quot;ordenação-de-inteiros&quot;&gt;Ordenação de inteiros&lt;/h2&gt;

&lt;p&gt;Suponha uma sequência finita de números inteiros dispostos em uma ordem arbitrária, gerado de forma aleatória, por exemplo. Podemos representar essa sequência por:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x_1, ~x_2, ~\dots, ~x_n,~\forall x_i\in\mathbb{Z} \mbox{ e } n\in\mathbb{Z}&lt;/script&gt;

&lt;p&gt;Como o conjunto dos números inteiros $\mathbb{Z}$ é totalmente ordenado de acordo com a relação de ordem $\leq$, existe então uma reordenação dos elementos dessa sequência $\alpha : \mathbb{Z}\to\mathbb{Z}$, tal que:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\alpha(1) ~\leq~\alpha(2)~\leq~ \dots ~\leq~\alpha(n)&lt;/script&gt;

&lt;p&gt;O mesmo é verdade para a relação de ordem $\geq$, e portanto existe também uma reordenação $\beta : \mathbb{Z}\to\mathbb{Z}$&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;{\beta(1)} ~\geq~{\beta(2)}~\geq~ \dots ~\geq~{\beta(n)}&lt;/script&gt;

&lt;p&gt;Transformar uma sequência de dados em ordem arbitrária em uma sequência ordenada é o objetivo dos &lt;strong&gt;algoritmos de ordenação&lt;/strong&gt; que veremos a seguir.&lt;/p&gt;

&lt;h2 id=&quot;o-que-são-algoritmos-de-ordenação&quot;&gt;O que são Algoritmos de ordenação?&lt;/h2&gt;

&lt;p&gt;Um algoritmo de ordenação é um procedimento que recebe como entrada uma sequência de dados, os quais assumiremos como números inteiros daqui em diante, e rearranja os items dessa sequência de modo que ao final eles estejam em uma determinada ordem: crescente, decrescente, por exemplo.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(13, 1, 0 -1, 9, 6, 3, 1) \Rightarrow (-1, 0, 1, 1, 3, 6, 9, 13)&lt;/script&gt;

&lt;h1 id=&quot;algoritmos-de-ordenação&quot;&gt;Algoritmos de Ordenação&lt;/h1&gt;

&lt;h2 id=&quot;bubble-sort&quot;&gt;Bubble sort&lt;/h2&gt;

&lt;p&gt;Dada uma sequência de entrada, a &lt;em&gt;ordenação por bolha&lt;/em&gt; compara pares de itens $x_i$ e $x_{i+1}$, levando para posições posteriores aquele elemento que seja o maior. Na prática isso significa que se $x_{i+1}$ for maior que $x_i$ esses elementos devem trocar de posição:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Trocar os elementos nas posições i e i+1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;O Bubble sort percorre do início ao fim do vetor várias vezes, efetuando trocas da forma acima. Na primeira passagem pelo vetor, o maior elemento é levado à posição final $x_{n}$, e, portanto, já estará na posição correta. A próxima iteração levará o segundo maior valor à posição anterior a final $x_{n-1}$ e assim sucessivamente, até que o primeiro elemento seja avaliado. Neste momento, o algoritmo precisa parar pois o vetor estará ordenado e nenhuma troca adicional ocorrerá.&lt;/p&gt;

&lt;h2 id=&quot;selection-sort&quot;&gt;Selection sort&lt;/h2&gt;

&lt;p&gt;Dada uma sequência de entrada, a &lt;em&gt;ordenação por seleção&lt;/em&gt; seleciona a cada passagem pelo vetor o menor elemento e o coloca na posição inicial $x_1$. Na segunda iteração o menor elemento entre $x_2$ e $x_n$ será selecionado e colocado na posição $x_2$. Ou seja, a cada iteração, o algoritmo deixa um elemento a mais na posição correta.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Trocar os elementos nas posições i e posição do menor elemento de i-n. 
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;insertion-sort&quot;&gt;Insertion sort&lt;/h2&gt;

&lt;p&gt;Dada uma sequência de entrada, a &lt;em&gt;ordenação por inserção&lt;/em&gt; percorre a sequência e para cada valor em uma determinada posição $i$, reinsere o valor $x_i$ na sua posição correta no momento. A posição correta $j$ para um elemento qualquer $x_i$ em um dado momento é aquela posição tal que $x_{j} \leq x_i \leq x_{j+1}$.&lt;/p&gt;

&lt;h2 id=&quot;quicksort&quot;&gt;Quicksort&lt;/h2&gt;

&lt;p&gt;Consideremos uma sequência numérica qualquer de tamanho $n$, em ordem arbitrária.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x_1, ~x_2, ~\dots, ~x_n,~\forall x_i\in\mathbb{Z} \mbox{ e } n\in\mathbb{Z}&lt;/script&gt;

&lt;p&gt;Vamos analisar as propriedades produzidas pelo seguinte procedimento, o qual é mais simples que a ordenação em si.&lt;/p&gt;

&lt;p&gt;Dado qualquer elemento desta sequência $x_p$, o qual chamaremos &lt;em&gt;pivô&lt;/em&gt;, &lt;strong&gt;reordene a sequência&lt;/strong&gt; de modo que $\forall x_i$ que preceda $x_p$, $x_i\leq x_p$. Em contrapartida, $\forall x_j$ que suceda $x_p$, $x_p \leq x_j$. Observe que não estamos exigindo que os elementos anteriores ou posteriores a $x_p$ estejam ordenados. No entanto, uma propriedade importante é evidente.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Se todos antes de $x_p$ são menores ou iguais a ele e todos elementos depois são maiores ou iguais, então $x_p$ está na sua posição correta. Ou seja, na posição que ele ocuparia em uma sequência ordenada.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Por essa propriedade concluímos que $x_p$ não precisa mais ser comparado a nenhum outro elemento. Nos restando duas subpsequências a serem ordenadas. Aquela contendo os elementos anteriores e aquela contendo os elementos posteriores a $x_p$.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;[\dots],~ x_p,~ [\dots]&lt;/script&gt;

&lt;p&gt;Podemos então repetir o mesmo procedimento em cada uma dessas subsequências, até que todos elementos tenham sido considerados como pivô e, portanto, colocados em suas devidas posições ordenadas.&lt;/p&gt;

&lt;p&gt;O Algoritmo acima descrito é chamado, no contexto do &lt;em&gt;Quicksort&lt;/em&gt;, de  &lt;em&gt;partition&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;partition&quot;&gt;Partition&lt;/h3&gt;

&lt;p&gt;Dada uma sequência númerica em ordem arbitrária como entrada e um valor &lt;em&gt;pivô&lt;/em&gt; $k$.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x_1, ~x_2, ~\dots, ~x_n,~\forall x_i\in\mathbb{Z} \mbox{ e } n\in\mathbb{Z}&lt;/script&gt;

&lt;p&gt;&lt;em&gt;Partition&lt;/em&gt; irá produzir uma nova sequência, com o pivô numa posição $p$, de modo que $y_i \leq k$, $\forall i \leq p$ e $y_j \geq k$, $\forall j \geq p$.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;y_1,~y_2,~\dots,y_{p-1},~ k_p,~ y_{p+1}, \dots,~ y_{n-1},~ y_{n}&lt;/script&gt;

&lt;p&gt;Outra característica importante dessa nova sequência é que todos elementos $y_1,\dots,y_{p-1}$ são menores que aqueles em $y_{p+1},\dots,y_n$. Portanto, eles não precisam mais ser comparados. As comparações adicionais acontecerão internamente a cada uma das sequências apenas.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Versão Cormen (Lomuto)
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;partition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Versao simples (Hoare)
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;partition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
            &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Partition&lt;/li&gt;
  &lt;li&gt;Complexidade no melhor caso&lt;/li&gt;
  &lt;li&gt;O que afeta o melhor caso&lt;/li&gt;
  &lt;li&gt;Complexidade no pior caso&lt;/li&gt;
  &lt;li&gt;Como contornar o pior caso: escolha do pivô&lt;/li&gt;
  &lt;li&gt;Mediana de três: p, r, (p+r)/2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;-Insertionsort
  -Heapsort
  -Shellsort
  -Mergesort&lt;/p&gt;

</description>
        <pubDate>Tue, 17 Oct 2017 13:50:00 -0200</pubDate>
        <link>http://localhost:4000/ae22cp-172/ordenacao.html</link>
        <guid isPermaLink="true">http://localhost:4000/ae22cp-172/ordenacao.html</guid>
        
        <category>ordenação</category>
        
        
        <category>AE22CP-172</category>
        
      </item>
    
      <item>
        <title>Lista VIII - Lógica de predicados, dedução</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#equivalências&quot; id=&quot;markdown-toc-equivalências&quot;&gt;Equivalências&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#exercícios&quot; id=&quot;markdown-toc-exercícios&quot;&gt;Exercícios&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#referências&quot; id=&quot;markdown-toc-referências&quot;&gt;Referências&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;equivalências&quot;&gt;Equivalências&lt;/h1&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;$\phi\to\psi$&lt;/td&gt;
      &lt;td&gt;$\neg\phi\lor\psi$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;$\phi\leftrightarrow\psi$&lt;/td&gt;
      &lt;td&gt;$(\phi\land\psi)\lor(\neg\phi\land\neg\psi)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;$\neg(\phi\land\psi)$&lt;/td&gt;
      &lt;td&gt;$\neg\psi \lor \neg \psi$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;$\neg(\phi\lor\psi)$&lt;/td&gt;
      &lt;td&gt;$\neg\phi\land\neg\psi$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;$\neg(\phi\to\psi)$&lt;/td&gt;
      &lt;td&gt;$\phi\land \neg \psi$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;$\neg(\phi\leftrightarrow\psi)$&lt;/td&gt;
      &lt;td&gt;$(\phi\land \neg\psi)\lor (\neg\phi\land\psi)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;exercícios&quot;&gt;Exercícios&lt;/h1&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x Fx \vdash Fa \land (Fb \land (Fc \land Fd))&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(Fx \lor Gx), \neg Fa \vdash \neg Ga&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg Fa \vdash \neg \forall x (Fx \land Gx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(Fx \leftrightarrow r), r \vdash Fa&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(\neg Fx \lor \neg Gx) \vdash \neg(Fa \land Ga)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(Fx \to Gx) \vdash \forall x(\neg Gx \to \neg Fx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(Fx \to Gx) \vdash \forall x\neg Gx \to \forall x \neg Fx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \forall y Fxy \vdash \forall x Fxx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x Fx \vdash \forall x Gx \to \forall x (Fx \land Gx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \forall y(Fxy \to \neg Fyx) \vdash \forall x \neg Fxx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x Fx \vdash \exists x Fx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x Fx \vdash \neg Fa&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists x \neg Fx \vdash \neg \forall x Fx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(Fx \to Gx) \vdash \exists x Fx \to \exists x Gx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x (Fx \land Gx) \vdash \forall x (\neg Fx \lor \neg Gx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \forall x(Fx \land Gx) \vdash \exists x(\neg Fx \lor \neg Gx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x \exists y Lxy \vdash \forall x \neg Lxx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists x Fx \vdash \exists x \exists y(Fx \land Fy)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \neg Fx \vdash \forall x(Fx \to Gx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \neg Fx \vdash \forall x(Fx \to \neg Gx)&lt;/script&gt;

&lt;h1 id=&quot;referências&quot;&gt;Referências&lt;/h1&gt;

&lt;p&gt;Seção 2.1: Pg. 71, &lt;a href=&quot;http://www.cse.chalmers.se/edu/course/DAT060/huthryan_lics2_sol.pdf&quot;&gt;Logica - Huth &amp;amp; Ryan (PDF).&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Capítulo 6: Pgs. 254-284, &lt;a href=&quot;https://racionalistasusp.files.wordpress.com/2010/01/nolt-john-rohatyn-dennis-lc3b3gica.pdf&quot;&gt;Logica - John Nolt (PDF).&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 05 Oct 2017 10:00:00 -0300</pubDate>
        <link>http://localhost:4000/lc21cp-172/lista8-logica-predicados-deducao.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/lista8-logica-predicados-deducao.html</guid>
        
        <category>predicados</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
      <item>
        <title>Lógica de predicados - Regras de dedução II</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#quantificador-existencial&quot; id=&quot;markdown-toc-quantificador-existencial&quot;&gt;Quantificador existencial&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#regra-de-introdução&quot; id=&quot;markdown-toc-regra-de-introdução&quot;&gt;Regra de introdução&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-1&quot; id=&quot;markdown-toc-exemplo-1&quot;&gt;Exemplo 1&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-2&quot; id=&quot;markdown-toc-exemplo-2&quot;&gt;Exemplo 2&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-4&quot; id=&quot;markdown-toc-exemplo-4&quot;&gt;Exemplo 4&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-5&quot; id=&quot;markdown-toc-exemplo-5&quot;&gt;Exemplo 5&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#regra-eliminação&quot; id=&quot;markdown-toc-regra-eliminação&quot;&gt;Regra Eliminação&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-1-1&quot; id=&quot;markdown-toc-exemplo-1-1&quot;&gt;Exemplo 1&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-2-619---pg277&quot; id=&quot;markdown-toc-exemplo-2-619---pg277&quot;&gt;Exemplo 2 (6.19 - pg.277)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-3-620&quot; id=&quot;markdown-toc-exemplo-3-620&quot;&gt;Exemplo 3 (6.20)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-4-621&quot; id=&quot;markdown-toc-exemplo-4-621&quot;&gt;Exemplo 4 (6.21)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-5-1&quot; id=&quot;markdown-toc-exemplo-5-1&quot;&gt;Exemplo 5&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-6&quot; id=&quot;markdown-toc-exemplo-6&quot;&gt;Exemplo 6&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-7&quot; id=&quot;markdown-toc-exemplo-7&quot;&gt;Exemplo 7&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;quantificador-existencial&quot;&gt;Quantificador existencial&lt;/h2&gt;

&lt;p&gt;Assim como todos os demais operadores o quantificador existencial ($\exists$) também possui duas regras de inferência: introdução e eliminação.&lt;/p&gt;

&lt;h3 id=&quot;regra-de-introdução&quot;&gt;Regra de introdução&lt;/h3&gt;

&lt;p&gt;A regra de introdução do quantificador existencial segue de forma intuitiva e direta a partir de sua definição. Suponhamos, por exemplo, o caso específico $F(a)\land G(a)$. Por si só, este exemplo já nos permite concluir a forma mais geral $\exists x (Fx \land Gx)$, nesta situação $a$ serviu como prova da existência de um determinado $x$ para o qual $Fx \land Gx$ fosse verdadeira.&lt;/p&gt;

&lt;h4 id=&quot;exemplo-1&quot;&gt;Exemplo 1&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x (Fx \lor Gx) \vdash \exists x(Fx \lor Gx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall x (Fx \lor Gx) &amp; \mbox{premissa}\\
2 &amp; Fa \lor Ga       &amp; \mbox{e-}\forall 1 \\
3 &amp; \exists x (Fx \lor Gx) &amp; \mbox{Introdução do existencial em 2}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h4 id=&quot;exemplo-2&quot;&gt;Exemplo 2&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x (Fx \lor Gx) \vdash \exists x Fx \lor \exists x Gx&lt;/script&gt;

&lt;p&gt;Apesar da similaridade como exemplo anterior, a demonstração neste caso é um pouco mais complexa. Precisamos provar que é possível derivar a conclusão a partir de cada disjuncto, utilizando a regra de eliminação da disjunção.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\dfrac{\phi\quad\psi\quad (\phi\to\chi) \quad (\psi\to\chi)}{\chi}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall x (Fx \lor Gx) &amp; \mbox{premissa}\\
2 &amp; Fa \lor Ga       &amp; \mbox{e-}\forall 1 \\
3.1 &amp; \qquad Fa  &amp; \mbox{Hipótese 1 da disjunção}\\
3.2 &amp; \qquad \exists x Fx &amp; \mbox{i-}\exists 3.1 \\
3.3 &amp; \qquad \exists x Fx \lor \exists x Gx &amp; \mbox{i-}\lor 3.2 \\
4   &amp; Fa \to (\exists x Fx \lor \exists x Gx) &amp; \mbox{i-}\to 3.1-3.3 \\
5.1   &amp; \qquad Ga      &amp; \mbox{Hipótese 2 da disjunção} \\
5.2 &amp; \qquad \exists x Gx &amp; \mbox{i-}\exists 5 \\
5.3 &amp; \qquad \exists x Fx \lor \exists x Gx &amp; \mbox{i-}\lor 5.2 \\
6  &amp; Ga \to (\exists x Fx \lor \exists x Gx) &amp; \mbox{i-}\to 5.1-5.3 \\
7  &amp; \exists x Fx \lor \exists x Gx &amp; \mbox{e-}\lor 2, 4, 6
\end{array} %]]&gt;&lt;/script&gt;

&lt;h4 id=&quot;exemplo-4&quot;&gt;Exemplo 4&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x Fx \vdash \forall x \neg Fx&lt;/script&gt;

&lt;p&gt;Para provar a inexistência de um $Fa$, utilizamos a estratégia de redução ao absurdo.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \neg \exists x Fx &amp; \mbox{premissa}\\
2.1 &amp; Fa        &amp; \mbox{Hipótese de absurdo} \\
2.2 &amp; \exists x Fx &amp; \mbox{Introdução do existencial 2.1}\\
2.3 &amp; \exists x Fx \land \neg \exists x Fx &amp; \mbox{Introdução da conjunção 1,2.2}\\
3   &amp; \neg Fa  &amp; \mbox{Por redução ao absurdo 2.1-2.3}\\
4   &amp; \forall x \neg Fx  &amp; \mbox{Introdução do universal 3}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h4 id=&quot;exemplo-5&quot;&gt;Exemplo 5&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x (Fx \land \neg Gx) \vdash \forall x (Fx \to Gx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \neg \exists x (Fx \land \neg Gx) &amp; \mbox{premissa}\\
2.1.0 &amp; \qquad Fa             &amp; \mbox{Hipótese para o condicional}\\
2.1.1 &amp; \qquad\qquad \neg Ga &amp; \mbox{Hipótese para o absurdo}\\
2.1.2 &amp; \qquad\qquad Fa \land \neg Ga &amp; \mbox{Introdução conjunção 2.1,2.1.1}\\
2.1.3 &amp; \qquad\qquad \exists x (Fx \land \neg Gx) &amp; \mbox{Introdução existencial 2.1.2}\\
2.1.4 &amp; \qquad\qquad Ga &amp; \mbox{Absurdo em 1 e 2.1.3}\\
2.2   &amp; \qquad Fa \to Ga &amp; \mbox{Introdução do condicional 2.1.0 - 2.1.4}\\\
3   &amp; \forall x (Fx \to Gx) &amp; \mbox{Introdução universal 2.2}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;regra-eliminação&quot;&gt;Regra Eliminação&lt;/h3&gt;

&lt;p&gt;A eliminação do quantificador existencial segue raciocínio contrário. Da premissa que afirma a existência de algo, por exemplo, $\exists x (Fx \land Gx)$, sabemos que para algum $x$ a propriedade é verdadeira. No entanto, não sabemos qual elemento substituir no lugar de $x$, visto que pode ser o caso de nem todos possíveis elementos satisfazerem $(Fx \land Gx)$.&lt;/p&gt;

&lt;p&gt;Por esse motivo, para eliminarmos um quantificador existencial, temos que o fazer por meio de uma hipótese, a qual irá supor que um determinado objetvo $a$ satisfaça a propriedade em questão.&lt;/p&gt;

&lt;h4 id=&quot;exemplo-1-1&quot;&gt;Exemplo 1&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists (Fx \land Gx) \vdash \exists x Fx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \exists x (Fx \land Gx) &amp; \mbox{premissa}\\
2 &amp; \qquad Fa \land Ga     &amp;  \mbox{Hipótese para eliminação do existencial}\\
3 &amp; \qquad Fa             &amp;   \mbox{Eliminação da conjunção 2}\\
4 &amp; \qquad \exists x Fx   &amp;   \mbox{Introdução do existencial 3}\\
5 &amp; \exists x Fx   &amp;  \mbox{Eliminação do existencial 1, 2-4}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h4 id=&quot;exemplo-2-619---pg277&quot;&gt;Exemplo 2 (6.19 - pg.277)&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x (Fx \to Gx), \exists x Fx \vdash \exists x Gx&lt;/script&gt;

&lt;h4 id=&quot;exemplo-3-620&quot;&gt;Exemplo 3 (6.20)&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists x (Fx \lor Gx) \vdash \exists x Fx \lor \exists x Gx&lt;/script&gt;

&lt;h4 id=&quot;exemplo-4-621&quot;&gt;Exemplo 4 (6.21)&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists Fx \lor \exists x Gx \vdash \exists x (Fx \lor Gx)&lt;/script&gt;

&lt;h4 id=&quot;exemplo-5-1&quot;&gt;Exemplo 5&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists x \forall y Lxy \vdash \forall x \exists y Lyx&lt;/script&gt;

&lt;h4 id=&quot;exemplo-6&quot;&gt;Exemplo 6&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x (Fx \to \exists y Lxy), \exists x (Fx \land Gx) \vdash \exists x\exists y (Gx \land Lxy)&lt;/script&gt;

&lt;h4 id=&quot;exemplo-7&quot;&gt;Exemplo 7&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x (Fx \to \neg Gx) \vdash \neg \exists x (Fx \land Gx)&lt;/script&gt;
</description>
        <pubDate>Wed, 04 Oct 2017 10:20:00 -0300</pubDate>
        <link>http://localhost:4000/lc21cp-172/logica-predicados-deducao-2.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/logica-predicados-deducao-2.html</guid>
        
        <category>predicados</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
      <item>
        <title>Lógica de predicados - Regras de dedução I</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#regras-de-inferência&quot; id=&quot;markdown-toc-regras-de-inferência&quot;&gt;Regras de inferência&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#quantificador-universal&quot; id=&quot;markdown-toc-quantificador-universal&quot;&gt;Quantificador universal&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#regra-de-eliminação&quot; id=&quot;markdown-toc-regra-de-eliminação&quot;&gt;Regra de eliminação&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#exemplo-1&quot; id=&quot;markdown-toc-exemplo-1&quot;&gt;Exemplo 1&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#exemplo-2&quot; id=&quot;markdown-toc-exemplo-2&quot;&gt;Exemplo 2&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#exemplo-3&quot; id=&quot;markdown-toc-exemplo-3&quot;&gt;Exemplo 3&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#regra-de-introdução&quot; id=&quot;markdown-toc-regra-de-introdução&quot;&gt;Regra de introdução&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#exemplo-1-1&quot; id=&quot;markdown-toc-exemplo-1-1&quot;&gt;Exemplo 1&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#exemplo-2-1&quot; id=&quot;markdown-toc-exemplo-2-1&quot;&gt;Exemplo 2&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#exemplo-3-1&quot; id=&quot;markdown-toc-exemplo-3-1&quot;&gt;Exemplo 3&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#exemplo-4&quot; id=&quot;markdown-toc-exemplo-4&quot;&gt;Exemplo 4&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#exemplo-5&quot; id=&quot;markdown-toc-exemplo-5&quot;&gt;Exemplo 5&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;regras-de-inferência&quot;&gt;Regras de inferência&lt;/h1&gt;

&lt;p&gt;O cálculo de predicados usa as mesmas dez regras do cálculo proposicional. Adicionalmente, temos as regras de introdução e de eliminação dos quantificadores. Relembremos um exemplo do cálculo proposicional&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg r \lor q, q \to p \vdash r \to p&lt;/script&gt;

&lt;p&gt;Este exemplo pode ser demonstrado utilizando a abordagem de prova de condicionais: assumir o antecedente como hipótese e derivar o consequente. Vejamos como ficaria&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \neg r \lor q &amp; \mbox{premissa}\\
2 &amp; q \to p       &amp; \mbox{premissa}\\
3 &amp; r             &amp; \mbox{hipótese}\\
4 &amp; \neg\neg r     &amp; \mbox{Dupla negação 3}\\
5 &amp; q            &amp; \mbox{Silogismo disjuntivo 1,4}\\
6 &amp; p           &amp;  \mbox{Modus ponens 2,5}\\
7 &amp; r \to p     &amp; \mbox{Prova do condicional 3-6}
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;Um exemplo similar na lógica de predicados, poderia ser provado utilizando-se das mesmas regras de derivação. Consideremos, por exemplo, a forma de argumento.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg F(a) \lor \exists x F(x), \exists x F(x) \to p \vdash F(a) \to p&lt;/script&gt;

&lt;p&gt;Se substituirmos as subfórmulas análogamente ao exemplo anterior, temos a demonstração a seguir:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \neg F(a) \lor \exists x F(x) &amp; \mbox{premissa}\\
2 &amp; \exists x F(x) \to p       &amp; \mbox{premissa}\\
3 &amp; F(a)             &amp; \mbox{hipótese}\\
4 &amp; \neg\neg F(a)     &amp; \mbox{Dupla negação 3}\\
5 &amp; \exists x F(x)            &amp; \mbox{Silogismo disjuntivo 1,4}\\
6 &amp; p           &amp;  \mbox{Modus ponens 2,5}\\
7 &amp; F(a) \to p     &amp; \mbox{Prova do condicional 3-6}
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;Neste exemplo da lógica de predicados não precisamos utilizar regras de inferência para os quantificadores, deste modo a demonstração se restringiu à utilização das regras já definidas para a lógica proposicional. Como esse não é sempre o caso, precisamos especificar o funcionamento das regras de derivação para os quantificadores: &lt;em&gt;universal&lt;/em&gt; ($\forall$) e &lt;em&gt;existencial&lt;/em&gt; ($\exists$).&lt;/p&gt;

&lt;h2 id=&quot;quantificador-universal&quot;&gt;Quantificador universal&lt;/h2&gt;

&lt;h3 id=&quot;regra-de-eliminação&quot;&gt;Regra de eliminação&lt;/h3&gt;
&lt;p&gt;Iremos iniciar pela definição da regra de eliminação do quantificador universal ($\forall$e). Intuitivamente a regra de eliminação do quantificador universal é bem simples e segue a seguinte ideia:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Se algo é valido para todos objetos, também é válido para um objeto em específico.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Portanto, uma fórmula geral do tipo $\forall x P(x)$, pode ser substituída durante uma demonstração por um caso específico $P(a)$, onde $a$ é um termo qualquer. Vejamos o seguinte exemplo.&lt;/p&gt;

&lt;p&gt;“Todos os homens são mortais”&lt;/p&gt;

&lt;p&gt;“Sócrates é homem”&lt;/p&gt;

&lt;p&gt;“Sócrates é mortal”&lt;/p&gt;

&lt;p&gt;Se definirmos os predicados:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$H(x):$ $x$ é homem&lt;/li&gt;
  &lt;li&gt;$M(x):$ $x$ é mortal&lt;/li&gt;
  &lt;li&gt;$s:$ Sócrates&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Temos o seguinte argumento formalizado:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(H(x)\to M(x)), H(s) \vdash M(s)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall x(H(x)\to M(x)) &amp; \mbox{premissa}\\
2 &amp; H(s)       &amp; \mbox{premissa}\\
3 &amp; H(s)\to M(s) &amp; \mbox{Eliminação do universal 1}\\
4 &amp; M(s)        &amp;  \mbox{Modus Ponens 2, 3}
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;O caso genérico indicado pela premissa $\forall x(H(x)\to M(x))$ pode ser especializado em termos de $s$ (Sócrates), levando à fórmula $H(s)\to M(s)$. Ou seja, se o fato de ser homem implica ser mortal, essa regra se aplica a qualquer homem $x$, inclusive Sócrates $s$. Pode-se dizer que $H(s)\to M(s)$ é uma instanciação da regra universal.&lt;/p&gt;

&lt;h4 id=&quot;exemplo-1&quot;&gt;Exemplo 1&lt;/h4&gt;

&lt;p&gt;Prove a validade da seguinte forma de argumento&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x ~F(x)\to G(x), ~\forall x F(x) ~~~\vdash~~ G(a)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall x ~F(x)\to G(x) &amp; \mbox{premissa}\\
2 &amp; \forall x F(x)       &amp; \mbox{premissa}\\
3 &amp; F(a)\to G(a) &amp; \mbox{Eliminação do universal 1}\\
4 &amp; F(a)        &amp;  \mbox{Eliminação do universal 2}\\
5 &amp; G(A)        &amp;  \mbox{Modus Ponens 3, 4}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h4 id=&quot;exemplo-2&quot;&gt;Exemplo 2&lt;/h4&gt;

&lt;p&gt;Prove a validade da seguinte forma de argumento&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg F(a)~~\vdash ~~\neg \forall x F(x)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \neg F(a)        &amp; \mbox{premissa}\\
2 &amp; \forall x F(x)   &amp; \mbox{Hipótese por absurdo}\\
3 &amp; F(a)             &amp; \mbox{Eliminação do universal 1}\\
4 &amp; \neg F(a) \land F(a)       &amp;  \mbox{Introdução do condicional 1,3}\\
5 &amp; \neg \forall x F(x)        &amp;  \mbox{Redução ao absurdo 2-4}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h4 id=&quot;exemplo-3&quot;&gt;Exemplo 3&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \forall y F(x,y)~~ \vdash F(a,a)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall x \forall y F(x,y)        &amp; \mbox{premissa}\\
2 &amp; \forall y F(a,y)   &amp; \mbox{Eliminação do universal 1}\\
3 &amp; F(a,a)      &amp; \mbox{Eliminação do universal 2}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;regra-de-introdução&quot;&gt;Regra de introdução&lt;/h3&gt;

&lt;p&gt;Em princípio, para introduzirmos uma fórmula do tipo $\forall x F(x)$, teríamos que demonstrar que para qualquer que seja $x$ então o predicado $P(x)$ é verdadeiro. Obviamente, sendo $x$ parte de um domínio possivelmente infinito esse tipo de abordagem não é possível. Como então introduzirmos o quantificador universal?&lt;/p&gt;

&lt;p&gt;A ideia também é simples, apesar de um pouco confusa no início. Se eu consigo demonstrar que para um caso específico $a$, $P(a)$ é verdadeiro, então, se nenhuma consideração/restrição foi feita em termos de $a$, essa demonstração poderia ser utilizada para demonstrar que para qualquer $x$, $P(x)$ também é verdadeiro. Consideremos um exemplo:&lt;/p&gt;

&lt;p&gt;“Todos os peixes são ciprinídeos”&lt;/p&gt;

&lt;p&gt;“Todos ciprinídeos são vistosos”&lt;/p&gt;

&lt;p&gt;“Todos os peixes são vistosos”&lt;/p&gt;

&lt;p&gt;Que formalizada por meio dos predicados:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$P(x)$: $x$ é peixe&lt;/li&gt;
  &lt;li&gt;$C(x)$: $x$ é ciprinídeo&lt;/li&gt;
  &lt;li&gt;$V(x)$: $x$ é vistoso&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(Px\to Cx),~~\forall x(Cx\to Vx) \vdash \forall (Px\to Vx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall x(Px\to Cx)        &amp; \mbox{premissa}\\
2 &amp; \forall x(Cx\to Vx)   &amp; \mbox{premissa}\\
3 &amp; Pa\to Ca      &amp; \mbox{Eliminação do universal 1}\\
4 &amp; Ca\to Va      &amp; \mbox{Eliminação do universal 2}\\
5 &amp; Pa\to Va      &amp; \mbox{Transitividade 3,4}\\
6 &amp; \forall x(Px\to Vx)      &amp; \mbox{Generalização universal 5}
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;Apesar de $a$ neste exemplo ser utilizado para referenciar um caso específico de $x$, nenhuma suposição foi feita acerca de $a$, portanto ele poderia ser utilizado para substituir qualquer $x$. Portanto é possível generalizar a conclusão de $a$ para $\forall x$.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Para que a aplicação dessa regra seja válida, não pode haver suposições sobre o símbolo $a$, ou seja, ele &lt;strong&gt;não pode aparecer nas premissas&lt;/strong&gt; nem e nenhuma &lt;strong&gt;hipótese vigente&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;Pois nesses casos haveria suposições sobre $a$, consequentemente ele não poderia representar um $x$ arbitrário.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;exemplo-1-1&quot;&gt;Exemplo 1&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall (Fx \land Gx) ~~ \vdash ~~\forall x Fx \land \forall x Gx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall (Fx \land Gx)        &amp; \mbox{premissa}\\
2 &amp; Fa \land Ga   &amp; \mbox{Eliminação do universal 1}\\
3 &amp; Fa      &amp; \mbox{Eliminação da conjunção 2}\\
4 &amp; Ga      &amp; \mbox{Eliminação da conjunção 2}\\
5 &amp; \forall x Fx      &amp; \mbox{Introdução do universal 3}\\
6 &amp; \forall x Gx      &amp; \mbox{Introdução do universal 4}\\
7 &amp; \forall x Fx \land \forall x Gx      &amp; \mbox{Introdução da conjunção 5, 6}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h4 id=&quot;exemplo-2-1&quot;&gt;Exemplo 2&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x (Fx \to (Gx \lor Hx)), \forall x \neg Gx  \vdash \forall x Fx \to \forall x Hx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall x (Fx \to (Gx \lor Hx))        &amp; \mbox{premissa}\\
2 &amp; \forall x \neg Gx   &amp; \mbox{premissa}\\
3 &amp; Fa \to (Ga \lor Ha)      &amp; \mbox{Eliminação do universal 1}\\
4 &amp; \neg Ga      &amp; \mbox{Eliminação do universal 2}\\
5 &amp; \qquad \forall x Fx      &amp; \mbox{Hipótese do condicional}\\
6 &amp; \qquad Fa      &amp; \mbox{Eliminação do universal 5}\\
7 &amp; \qquad Ga \lor Ha      &amp; \mbox{Modus Ponens 3, 6}\\
8 &amp; \qquad Ha             &amp; \mbox{Silogismo disjuntivo 4,7}\\
9 &amp; \qquad\forall x Hx   &amp; \mbox{Introdução do universal 8}\\
10 &amp; \forall x Fx \to \forall x Hx &amp; \mbox{Prova do condicional 5-9}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h4 id=&quot;exemplo-3-1&quot;&gt;Exemplo 3&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x (Fx \to (Gx \lor Hx)), \forall x \neg Gx  \vdash \forall x (Fx \to Hx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall x (Fx \to (Gx \lor Hx))        &amp; \mbox{premissa}\\
2 &amp; \forall x \neg Gx   &amp; \mbox{premissa}\\
3 &amp; Fa \to (Ga \lor Ha)      &amp; \mbox{Eliminação do universal 1}\\
4 &amp; \neg Ga      &amp; \mbox{Eliminação do universal 2}\\
5 &amp; \qquad Fa      &amp; \mbox{Hipótese do condicional}\\
6 &amp; \qquad Ga \lor Ha      &amp; \mbox{Modus Ponens 3, 5}\\
7 &amp; \qquad Ha             &amp; \mbox{Silogismo disjuntivo 4,7}\\
8 &amp; Fa \to Ha   &amp; \mbox{Prova do condicional 5-7}\\
9 &amp; \forall x (Fx \to Hx) &amp; \mbox{Introdução do universal 8}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h4 id=&quot;exemplo-4&quot;&gt;Exemplo 4&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x Fax, \forall x \forall y (Fxy \to Gyx) \vdash \forall x Gxa&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall x Fax        &amp; \mbox{premissa}\\
2 &amp; \forall x \forall y (Fxy \to Gyx)  &amp; \mbox{premissa}\\
3 &amp; Fab      &amp; \mbox{Eliminação do universal 1}\\
4 &amp; \forall y (Fay \to Gya)      &amp; \mbox{Eliminação do universal 2}\\
5 &amp; Fab \to Gba      &amp; \mbox{Eliminação do universal 4}\\
6 &amp; Gba      &amp; \mbox{Modus Ponens 3, 5}\\
7 &amp; \forall x Gxa             &amp; \mbox{Introdução do universal 6}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h4 id=&quot;exemplo-5&quot;&gt;Exemplo 5&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x Fx \to \forall x Gx, \neg Ga \vdash \neg \forall x Fx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall x Fx \to \forall x Gx        &amp; \mbox{premissa}\\
2 &amp; \neg Ga  &amp; \mbox{premissa}\\
3 &amp; \qquad \forall x Fx      &amp; \mbox{Hipótese para absurdo}\\
4 &amp; \qquad \forall x Gx      &amp; \mbox{Modus Ponens 1, 3}\\
5 &amp; \qquad Ga      &amp; \mbox{Eliminação do universal 4}\\
6 &amp; \qquad Ga \land \neg Ga      &amp; \mbox{Introdução da conjunção 2,5}\\
7 &amp; \neg \forall x Fx             &amp; \mbox{Redução ao absurdo 3-6}
\end{array} %]]&gt;&lt;/script&gt;
</description>
        <pubDate>Wed, 04 Oct 2017 10:20:00 -0300</pubDate>
        <link>http://localhost:4000/lc21cp-172/logica-predicados-deducao-1.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/logica-predicados-deducao-1.html</guid>
        
        <category>predicados</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
      <item>
        <title>Lista VII - Lógica de predicados, formalização</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#exercícios&quot; id=&quot;markdown-toc-exercícios&quot;&gt;Exercícios&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#0-predicados-unários&quot; id=&quot;markdown-toc-0-predicados-unários&quot;&gt;#0 Predicados unários&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#1--predicados-binários&quot; id=&quot;markdown-toc-1--predicados-binários&quot;&gt;#1  Predicados binários&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#2-predicados-binários&quot; id=&quot;markdown-toc-2-predicados-binários&quot;&gt;#2 Predicados binários&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#3-fórmulas-bem-formadas&quot; id=&quot;markdown-toc-3-fórmulas-bem-formadas&quot;&gt;#3 Fórmulas bem formadas&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#referências&quot; id=&quot;markdown-toc-referências&quot;&gt;Referências&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;exercícios&quot;&gt;Exercícios&lt;/h1&gt;

&lt;h2 id=&quot;0-predicados-unários&quot;&gt;#0 Predicados unários&lt;/h2&gt;

&lt;p&gt;Interpretando como&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$c$: “está chovendo”&lt;/li&gt;
  &lt;li&gt;$R$: “é uma rã”&lt;/li&gt;
  &lt;li&gt;$V$: “é verde”&lt;/li&gt;
  &lt;li&gt;$S$: “é saltitante”&lt;/li&gt;
  &lt;li&gt;$I$: “é iridescente”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Formalize as seguintes sentenças:&lt;/p&gt;

&lt;p&gt;a. Todas as rãs são verdes&lt;/p&gt;

&lt;p&gt;b. Nenhuma rã é verdes&lt;/p&gt;

&lt;p&gt;c. Algumas rãs são verdes&lt;/p&gt;

&lt;p&gt;d. Algumas rãs não são verdes&lt;/p&gt;

&lt;p&gt;e. Toda coisa é uma rã.&lt;/p&gt;

&lt;p&gt;f. Alguma coisa é uma rã.&lt;/p&gt;

&lt;p&gt;g. Nem toda coisa é uma rã.&lt;/p&gt;

&lt;p&gt;h. Nada é uma rã.&lt;/p&gt;

&lt;p&gt;i. Existem rãs verdes&lt;/p&gt;

&lt;p&gt;j. Qualquer coisa ou é rã ou é iridescente.&lt;/p&gt;

&lt;p&gt;k. Qualquer coisa é uma rã verde.&lt;/p&gt;

&lt;p&gt;l. Está chovendo e algumas rãs estão saltitando&lt;/p&gt;

&lt;p&gt;m. Se está chovendo, então todas as rãs estão saltitando&lt;/p&gt;

&lt;p&gt;n. Algumas coisas são verdes e algumas não são&lt;/p&gt;

&lt;p&gt;o. Algumas coisas são verdes e iridescentes simultaneamente&lt;/p&gt;

&lt;p&gt;p. Ou qualquer coisa é uma rã, ou nada é uma rã&lt;/p&gt;

&lt;p&gt;q. Qualquer coisa ou é uma rã ou não é uma rã.&lt;/p&gt;

&lt;p&gt;r. Todas as rãs são rãs.&lt;/p&gt;

&lt;p&gt;s. Somente rãs são verdes.&lt;/p&gt;

&lt;p&gt;t. Não existem rãs iridescentes.&lt;/p&gt;

&lt;p&gt;u. Todas as rãs verdes estão saltitando&lt;/p&gt;

&lt;p&gt;v. Algumas rãs verdes não estão saltitando&lt;/p&gt;

&lt;p&gt;w. Não é verdade que algumas rãs verdes estão saltitando.&lt;/p&gt;

&lt;p&gt;x. Se nada é verde, então não existem rãs verdes.&lt;/p&gt;

&lt;p&gt;y. Rãs verdes saltam se e somente se não está chovendo.&lt;/p&gt;

&lt;h2 id=&quot;1--predicados-binários&quot;&gt;#1  Predicados binários&lt;/h2&gt;

&lt;p&gt;Use os predicados&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$A(x,y)$: $x$ admira $y$&lt;/li&gt;
  &lt;li&gt;$B(x,y)$: $x$ estava presente em $y$&lt;/li&gt;
  &lt;li&gt;$P(x)$: $x$ é um professor&lt;/li&gt;
  &lt;li&gt;$E(x)$: $x$ é um estudante&lt;/li&gt;
  &lt;li&gt;$L(x)$: $x$ é uma aula&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;e o símbolo funcional (constante)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$m$: Maria&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;a. Maria admira todo professor&lt;/p&gt;

&lt;p&gt;b. Algum professor admira Maria&lt;/p&gt;

&lt;p&gt;c. Maria admira a si própria&lt;/p&gt;

&lt;p&gt;d. Nenhum estudante estava presente em todas as aulas.&lt;/p&gt;

&lt;p&gt;e. Nenhuma aula teve a presença de todos os estudantes&lt;/p&gt;

&lt;p&gt;f. Nenhuma aula teve a presença de qualquer estudante.&lt;/p&gt;

&lt;h2 id=&quot;2-predicados-binários&quot;&gt;#2 Predicados binários&lt;/h2&gt;
&lt;p&gt;Suponha&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$F(x,y)$: $x$ é o pai de $y$&lt;/li&gt;
  &lt;li&gt;$M(x,y)$: $x$ é a mãe de $y$&lt;/li&gt;
  &lt;li&gt;$H(x,y)$: $x$ é marido de $y$&lt;/li&gt;
  &lt;li&gt;$S(x,y)$: $x$ é irmã de $y$&lt;/li&gt;
  &lt;li&gt;$B(x,y)$: $x$ é irmão de $y$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;É permitido usar constantes para representar nomes: ‘Ed’, ‘Patsy’&lt;/p&gt;

&lt;p&gt;a. Todos têm uma mãe&lt;/p&gt;

&lt;p&gt;b. Todos têm um pai e uma mãe&lt;/p&gt;

&lt;p&gt;c. Todos que tem uma mãe tem um pai&lt;/p&gt;

&lt;p&gt;d. Ed é um avô&lt;/p&gt;

&lt;p&gt;e. Todos os pais são pais ou mães&lt;/p&gt;

&lt;p&gt;f. Todos os maridos são cônjuges&lt;/p&gt;

&lt;p&gt;g. Nenhum tio é tia&lt;/p&gt;

&lt;p&gt;h. Todos os irmãos são irmãos ou irmãs&lt;/p&gt;

&lt;p&gt;i. Nenhuma avó é pai de alguém&lt;/p&gt;

&lt;p&gt;j. Ed e Patsy são marido e mulher&lt;/p&gt;

&lt;p&gt;k. Carlos é cunhado de Monique.&lt;/p&gt;

&lt;h2 id=&quot;3-fórmulas-bem-formadas&quot;&gt;#3 Fórmulas bem formadas&lt;/h2&gt;

&lt;p&gt;Sejam $m$ uma constante, $f$ um símbolo funcional unário e $S$ e $B$ dois símbolos predicados binários. Quais das cadeias a seguir são fórmulas na lógica de predicados.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;S(m)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;B(m, f(m))&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;B(B(m,x),y)&lt;/script&gt;

&lt;h1 id=&quot;referências&quot;&gt;Referências&lt;/h1&gt;

&lt;p&gt;Seção 2.1: Pg. 71, &lt;a href=&quot;http://www.cse.chalmers.se/edu/course/DAT060/huthryan_lics2_sol.pdf&quot;&gt;Logica - Huth &amp;amp; Ryan (PDF).&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Capítulo 6: Pgs. 239, &lt;a href=&quot;https://racionalistasusp.files.wordpress.com/2010/01/nolt-john-rohatyn-dennis-lc3b3gica.pdf&quot;&gt;Logica - John Nolt (PDF).&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 28 Sep 2017 12:00:00 -0300</pubDate>
        <link>http://localhost:4000/lc21cp-172/lista7-logica-predicados.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/lista7-logica-predicados.html</guid>
        
        <category>predicados</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
  </channel>
</rss>
