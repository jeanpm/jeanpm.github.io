<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jean P. Martins</title>
    <description>Combinatorial optimization, evolutionary optimization, estimation of distribution algorithms, linkage learning, learning and optimization.
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 18 Oct 2017 17:01:06 -0200</pubDate>
    <lastBuildDate>Wed, 18 Oct 2017 17:01:06 -0200</lastBuildDate>
    <generator>Jekyll v3.4.3</generator>
    
      <item>
        <title>Algoritmos de ordenação</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#introdução&quot; id=&quot;markdown-toc-introdução&quot;&gt;Introdução&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ordenação-de-inteiros&quot; id=&quot;markdown-toc-ordenação-de-inteiros&quot;&gt;Ordenação de inteiros&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#o-que-são-algoritmos-de-ordenação&quot; id=&quot;markdown-toc-o-que-são-algoritmos-de-ordenação&quot;&gt;O que são Algoritmos de ordenação?&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#algoritmos-de-ordenação&quot; id=&quot;markdown-toc-algoritmos-de-ordenação&quot;&gt;Algoritmos de Ordenação&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#bubble-sort&quot; id=&quot;markdown-toc-bubble-sort&quot;&gt;Bubble sort&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#selection-sort&quot; id=&quot;markdown-toc-selection-sort&quot;&gt;Selection sort&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#insertion-sort&quot; id=&quot;markdown-toc-insertion-sort&quot;&gt;Insertion sort&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#quicksort&quot; id=&quot;markdown-toc-quicksort&quot;&gt;Quicksort&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#partition&quot; id=&quot;markdown-toc-partition&quot;&gt;Partition&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;introdução&quot;&gt;Introdução&lt;/h1&gt;

&lt;p&gt;A ordenação de informação tem impacto relevante em diversos aspectos do nosso cotidiano. Considere, por exemplo, a ordem alfabética em que um dicionário é organizado, ou a ordem crescente (decrescente) em que os preços de um determinado produto são exibidos em uma compra online. Nessas situações, o fato da informação estar organizada (ordenada) de um modo consistente nos permite procurar por determinado item (uma &lt;em&gt;palavra&lt;/em&gt; nos dicionários, um objeto de determinado &lt;em&gt;valor&lt;/em&gt; na lista de compras) de forma muito mais simples.&lt;/p&gt;

&lt;p&gt;Do ponto de vista computacional a ordenação de dados tem influência similar. Ao reorganizarmos a informação de forma consistente, diversas operações que poderiam ser feitas sobre o conteúdo armazenado podem, possivelmente, se tornar mais simples e eficientes.&lt;/p&gt;

&lt;p&gt;Em princípio qualquer sequência de dados pode ser ordenada. Para isso, no entanto, é necessário que exista uma &lt;a href=&quot;https://pt.wikipedia.org/wiki/Rela%C3%A7%C3%A3o_de_ordem&quot;&gt;relação de ordem&lt;/a&gt; para o conjunto dos dados a serem ordenados. Sem perda de generalidade, consideraremos que cada item $i$ na sequência a ser ordenada possui uma chave $k_i\in \mathbb{D}$, tal que essas chaves pertençam a um domínio para o qual exista uma relação de ordem $R \subseteq \mathbb{D}\times \mathbb{D}$. Exemplos de relações de &lt;a href=&quot;https://pt.wikipedia.org/wiki/Rela%C3%A7%C3%A3o_de_ordem#Rela.C3.A7.C3.B5es_de_ordem_linear_ou_total&quot;&gt;ordem totais&lt;/a&gt; mais comuns são: menor ou igual ($\leq$) e maior ou igual ($\geq$).&lt;/p&gt;

&lt;h2 id=&quot;ordenação-de-inteiros&quot;&gt;Ordenação de inteiros&lt;/h2&gt;

&lt;p&gt;Suponha uma sequência finita de números inteiros dispostos em uma ordem arbitrária, gerado de forma aleatória, por exemplo. Podemos representar essa sequência por:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x_1, ~x_2, ~\dots, ~x_n,~\forall x_i\in\mathbb{Z} \mbox{ e } n\in\mathbb{Z}&lt;/script&gt;

&lt;p&gt;Como o conjunto dos números inteiros $\mathbb{Z}$ é totalmente ordenado de acordo com a relação de ordem $\leq$, existe então uma reordenação dos elementos dessa sequência $\alpha : \mathbb{Z}\to\mathbb{Z}$, tal que:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\alpha(1) ~\leq~\alpha(2)~\leq~ \dots ~\leq~\alpha(n)&lt;/script&gt;

&lt;p&gt;O mesmo é verdade para a relação de ordem $\geq$, e portanto existe também uma reordenação $\beta : \mathbb{Z}\to\mathbb{Z}$&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;{\beta(1)} ~\geq~{\beta(2)}~\geq~ \dots ~\geq~{\beta(n)}&lt;/script&gt;

&lt;p&gt;Transformar uma sequência de dados em ordem arbitrária em uma sequência ordenada é o objetivo dos &lt;strong&gt;algoritmos de ordenação&lt;/strong&gt; que veremos a seguir.&lt;/p&gt;

&lt;h2 id=&quot;o-que-são-algoritmos-de-ordenação&quot;&gt;O que são Algoritmos de ordenação?&lt;/h2&gt;

&lt;p&gt;Um algoritmo de ordenação é um procedimento que recebe como entrada uma sequência de dados, os quais assumiremos como números inteiros daqui em diante, e rearranja os items dessa sequência de modo que ao final eles estejam em uma determinada ordem: crescente, decrescente, por exemplo.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(13, 1, 0 -1, 9, 6, 3, 1) \Rightarrow (-1, 0, 1, 1, 3, 6, 9, 13)&lt;/script&gt;

&lt;h1 id=&quot;algoritmos-de-ordenação&quot;&gt;Algoritmos de Ordenação&lt;/h1&gt;

&lt;h2 id=&quot;bubble-sort&quot;&gt;Bubble sort&lt;/h2&gt;

&lt;p&gt;Dada uma sequência de entrada, a &lt;em&gt;ordenação por bolha&lt;/em&gt; compara pares de itens $x_i$ e $x_{i+1}$, levando para posições posteriores aquele elemento que seja o maior. Na prática isso significa que se $x_{i+1}$ for maior que $x_i$ esses elementos devem trocar de posição:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Trocar os elementos nas posições i e i+1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;O Bubble sort percorre do início ao fim do vetor várias vezes, efetuando trocas da forma acima. Na primeira passagem pelo vetor, o maior elemento é levado à posição final $x_{n}$, e, portanto, já estará na posição correta. A próxima iteração levará o segundo maior valor à posição anterior a final $x_{n-1}$ e assim sucessivamente, até que o primeiro elemento seja avaliado. Neste momento, o algoritmo precisa parar pois o vetor estará ordenado e nenhuma troca adicional ocorrerá.&lt;/p&gt;

&lt;h2 id=&quot;selection-sort&quot;&gt;Selection sort&lt;/h2&gt;

&lt;p&gt;Dada uma sequência de entrada, a &lt;em&gt;ordenação por seleção&lt;/em&gt; seleciona a cada passagem pelo vetor o menor elemento e o coloca na posição inicial $x_1$. Na segunda iteração o menor elemento entre $x_2$ e $x_n$ será selecionado e colocado na posição $x_2$. Ou seja, a cada iteração, o algoritmo deixa um elemento a mais na posição correta.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Trocar os elementos nas posições i e posição do menor elemento de i-n. 
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;insertion-sort&quot;&gt;Insertion sort&lt;/h2&gt;

&lt;p&gt;Dada uma sequência de entrada, a &lt;em&gt;ordenação por inserção&lt;/em&gt; percorre a sequência e para cada valor em uma determinada posição $i$, reinsere o valor $x_i$ na sua posição correta no momento. A posição correta $j$ para um elemento qualquer $x_i$ em um dado momento é aquela posição tal que $x_{j} \leq x_i \leq x_{j+1}$.&lt;/p&gt;

&lt;h2 id=&quot;quicksort&quot;&gt;Quicksort&lt;/h2&gt;

&lt;p&gt;Consideremos uma sequência numérica qualquer de tamanho $n$, em ordem arbitrária.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x_1, ~x_2, ~\dots, ~x_n,~\forall x_i\in\mathbb{Z} \mbox{ e } n\in\mathbb{Z}&lt;/script&gt;

&lt;p&gt;Vamos analisar as propriedades produzidas pelo seguinte procedimento, o qual é mais simples que a ordenação em si.&lt;/p&gt;

&lt;p&gt;Dado qualquer elemento desta sequência $x_p$, o qual chamaremos &lt;em&gt;pivô&lt;/em&gt;, &lt;strong&gt;reordene a sequência&lt;/strong&gt; de modo que $\forall x_i$ que preceda $x_p$, $x_i\leq x_p$. Em contrapartida, $\forall x_j$ que suceda $x_p$, $x_p \leq x_j$. Observe que não estamos exigindo que os elementos anteriores ou posteriores a $x_p$ estejam ordenados. No entanto, uma propriedade importante é evidente.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Se todos antes de $x_p$ são menores ou iguais a ele e todos elementos depois são maiores ou iguais, então $x_p$ está na sua posição correta. Ou seja, na posição que ele ocuparia em uma sequência ordenada.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Por essa propriedade concluímos que $x_p$ não precisa mais ser comparado a nenhum outro elemento. Nos restando duas subpsequências a serem ordenadas. Aquela contendo os elementos anteriores e aquela contendo os elementos posteriores a $x_p$.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;[\dots],~ x_p,~ [\dots]&lt;/script&gt;

&lt;p&gt;Podemos então repetir o mesmo procedimento em cada uma dessas subsequências, até que todos elementos tenham sido considerados como pivô e, portanto, colocados em suas devidas posições ordenadas.&lt;/p&gt;

&lt;p&gt;O Algoritmo acima descrito é chamado, no contexto do &lt;em&gt;Quicksort&lt;/em&gt;, de  &lt;em&gt;partition&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;partition&quot;&gt;Partition&lt;/h3&gt;

&lt;p&gt;Dada uma sequência númerica em ordem arbitrária como entrada e um valor &lt;em&gt;pivô&lt;/em&gt; $k$.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x_1, ~x_2, ~\dots, ~x_n,~\forall x_i\in\mathbb{Z} \mbox{ e } n\in\mathbb{Z}&lt;/script&gt;

&lt;p&gt;&lt;em&gt;Partition&lt;/em&gt; irá produzir uma nova sequência, com o pivô numa posição $p$, de modo que $y_i \leq k$, $\forall i \leq p$ e $y_j \geq k$, $\forall j \geq p$.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;y_1,~y_2,~\dots,y_{p-1},~ k_p,~ y_{p+1}, \dots,~ y_{n-1},~ y_{n}&lt;/script&gt;

&lt;p&gt;Outra característica importante dessa nova sequência é que todos elementos $y_1,\dots,y_{p-1}$ são menores que aqueles em $y_{p+1},\dots,y_n$. Portanto, eles não precisam mais ser comparados. As comparações adicionais acontecerão internamente a cada uma das sequências apenas.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Versão Cormen (Lomuto)
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;partition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Versao simples (Hoare)
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;partition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
            &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Partition&lt;/li&gt;
  &lt;li&gt;Complexidade no melhor caso&lt;/li&gt;
  &lt;li&gt;O que afeta o melhor caso&lt;/li&gt;
  &lt;li&gt;Complexidade no pior caso&lt;/li&gt;
  &lt;li&gt;Como contornar o pior caso: escolha do pivô&lt;/li&gt;
  &lt;li&gt;Mediana de três: p, r, (p+r)/2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;-Insertionsort
  -Heapsort
  -Shellsort
  -Mergesort&lt;/p&gt;

</description>
        <pubDate>Fri, 29 Dec 2017 13:50:00 -0200</pubDate>
        <link>http://localhost:4000/ae22cp-172/ordenacao.html</link>
        <guid isPermaLink="true">http://localhost:4000/ae22cp-172/ordenacao.html</guid>
        
        <category>ordenação</category>
        
        
        <category>AE22CP-172</category>
        
      </item>
    
      <item>
        <title>FAQ</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#segmentation-fault&quot; id=&quot;markdown-toc-segmentation-fault&quot;&gt;Segmentation Fault&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo-1&quot; id=&quot;markdown-toc-exemplo-1&quot;&gt;Exemplo 1&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo-2&quot; id=&quot;markdown-toc-exemplo-2&quot;&gt;Exemplo 2&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#programação-estruturada&quot; id=&quot;markdown-toc-programação-estruturada&quot;&gt;Programação estruturada&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#função-list_sizel&quot; id=&quot;markdown-toc-função-list_sizel&quot;&gt;Função &lt;code class=&quot;highlighter-rouge&quot;&gt;list_size(l)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;segmentation-fault&quot;&gt;Segmentation Fault&lt;/h1&gt;

&lt;p&gt;Se seu código está dando falha de segmentação, rode ele dentro do gdb, em muitos casos nem é preciso procurar o erro passo a passo, pois o gdb mostra informações de onde a falha de segmentação ocorreu.&lt;/p&gt;

&lt;h2 id=&quot;exemplo-1&quot;&gt;Exemplo 1&lt;/h2&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;@:~$ &lt;/span&gt;./list &amp;lt; input/input02.txt 
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1] 35 
Falha de segmentação &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;imagem &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;núcleo gravada&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Esta saída não nos dá informação suficiente para a correção do erro. Portanto, utilizarei o gdb. Primeiro passo, compilar com a flag &lt;code class=&quot;highlighter-rouge&quot;&gt;-g&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;@:~$ &lt;/span&gt;gcc main.c list.c -o list -g
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Após isso, inicializar o gdb passando o executável como parâmetro&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;@:~$ &lt;/span&gt;gdb ./list
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;A seguir, utilizar o comando &lt;code class=&quot;highlighter-rouge&quot;&gt;run&lt;/code&gt; do gdb para iniciar a execução do programa.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; run ./list &amp;lt; input/input02.txt &amp;gt; out
Starting program: ./list &amp;lt; input/input02.txt &amp;gt; out
 
Program received signal SIGSEGV, Segmentation fault.
0x00000000004009fb &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;list_erase &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0x7fffffffdfd0, &lt;span class=&quot;nv&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; at list.c:101
101        n-&amp;gt;next&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;j-&amp;gt;next;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Desta saída, podemos focar apenas em algumas partes.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Program received signal SIGSEGV, Segmentation fault.
&lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;list_erase &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;v, &lt;span class=&quot;nv&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; at list.c:101
101        n-&amp;gt;next&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;j-&amp;gt;next;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;SIGSEGV, é uma constante representando o tipo de erro, neste caso &lt;em&gt;segmentation fault&lt;/em&gt;, que se refere à tentativa de acesso de memória não permitido: além dos limites de um vetor, ou em posições de memória que não foram alocadas pelo programador.&lt;/p&gt;

&lt;p&gt;Note, que &lt;code class=&quot;highlighter-rouge&quot;&gt;list_erase (v, i=1)&lt;/code&gt;, nos diz que o erro aconteceu na função &lt;code class=&quot;highlighter-rouge&quot;&gt;list_erase&lt;/code&gt;, quando recebendo a posição &lt;code class=&quot;highlighter-rouge&quot;&gt;i=1&lt;/code&gt; e nos mostra também a linha exata onde a falha de segmentação aconteceu.&lt;/p&gt;

&lt;h2 id=&quot;exemplo-2&quot;&gt;Exemplo 2&lt;/h2&gt;

&lt;p&gt;Seguiremos o mesmo procedimento descrito anteriormente.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;@:~$ &lt;/span&gt;./list &amp;lt; input/input03.txt 
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1] 68
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;2] 68 98
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;3] 16 68 98
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;2] 68 98
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1] 98
Falha de segmentação &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;imagem &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;núcleo gravada&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;@:~$ &lt;/span&gt;gdb ./list
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; run ./list &amp;lt; input/input03.txt 
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1] 68
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;2] 68 98
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;3] 16 68 98
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;2] 68 98
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1] 98
 
Program received signal SIGSEGV, Segmentation fault.
0x0000000000400acb &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;list_pop_back &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0x604020&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; at list.c:183
183 &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;ptr-&amp;gt;next-&amp;gt;next !&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; NULL&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Neste exemplo, a falha de segmentação ocorreu na linha 183, na função &lt;code class=&quot;highlighter-rouge&quot;&gt;list_pop_back&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;in list_pop_back (l=0x604020) at list.c:183
183 while(ptr-&amp;gt;next-&amp;gt;next != NULL)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Como sabemos, &lt;em&gt;segmentation fault&lt;/em&gt; indica acesso indevido de memória. Portanto podemos imaginar que algo errado com a operação&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;183 while(ptr-&amp;gt;next-&amp;gt;next != NULL)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;O que aconteceria se &lt;code class=&quot;highlighter-rouge&quot;&gt;ptr-&amp;gt;next&lt;/code&gt; for &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt;? Bom, neste caso, ao tentar acessar o próximo &lt;code class=&quot;highlighter-rouge&quot;&gt;-&amp;gt;next&lt;/code&gt;, estariamos acessando o endereço indicado por &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt;, e lá procurando o campo &lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt;, algo como: &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL-&amp;gt;next&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Como &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt; é usualmente definido como o endereço &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; da memória, qualquer acesso a esse endereço levará à falha de segmentação. Portanto, sempre que houver falha de segmentação, a primeira suspeita deve ser:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Acesso fora dos limites de um vetor&lt;/li&gt;
  &lt;li&gt;Acesso (dereferenciamento) ao endereço &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;programação-estruturada&quot;&gt;Programação estruturada&lt;/h1&gt;

&lt;h2 id=&quot;função-list_sizel&quot;&gt;Função &lt;code class=&quot;highlighter-rouge&quot;&gt;list_size(l)&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;“Se a estrutura de dados &lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt; duplamente encadeada já possui um campo &lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;, qual a necessidade da função &lt;code class=&quot;highlighter-rouge&quot;&gt;list_size()&lt;/code&gt;.”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Em algumas situações certas funções parecem desnecessárias, é o caso do &lt;code class=&quot;highlighter-rouge&quot;&gt;list_size()&lt;/code&gt;. Para entender o porque de sua utilidade, é bom pensarmos em termos da lista como estrutura abstrata, a qual tem uma interface &lt;code class=&quot;highlighter-rouge&quot;&gt;list.h&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Nesse sentido, ambas implementações, “lista simples”, “listas duplas”, teriam uma implementação de &lt;code class=&quot;highlighter-rouge&quot;&gt;list_size()&lt;/code&gt;. Nas listas simples, preciso percorrer toda lista para saber o tamanho, nas duplas, basta acessar o size já existente. Algo desse tipo&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// forward_list.c
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;list_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// list.c
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;list_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Agora suponha que estejamos utilizando uma estrutura lista para resolver algum problema, soma/multiplicação de inteiros grandes, splice, por exemplo.&lt;/p&gt;

&lt;p&gt;Neste caso, se sempre que precisarmos saber o tamanho de uma lista, utilizarmos &lt;code class=&quot;highlighter-rouge&quot;&gt;list_size()&lt;/code&gt; (e as demais funções de acesso a lista), isso nos permitiria utilizar tanto a implementação da lista de encadeamento simples (&lt;code class=&quot;highlighter-rouge&quot;&gt;forward_list.c&lt;/code&gt;) quanto a de encadeamento duplo (&lt;code class=&quot;highlighter-rouge&quot;&gt;list.c&lt;/code&gt;). Bastando escolher durante a compilação.&lt;/p&gt;

&lt;p&gt;Se pelo contrário, eu utilizasse &lt;code class=&quot;highlighter-rouge&quot;&gt;l-&amp;gt;size&lt;/code&gt; diretamente, eu não conseguiria utilizar a implementação &lt;code class=&quot;highlighter-rouge&quot;&gt;forward_list.c&lt;/code&gt;, visto que nela, esse campo não existe.&lt;/p&gt;

&lt;p&gt;Portanto, a ideia de termos várias funções para acessar certas propriedades da estrutura, nos permite separar a implementação da definição da estrutura de dados. Isso é sugerido quando programamos pensando em reutilização, e programação de bibliotecas.&lt;/p&gt;

&lt;p&gt;Obviamente, podemos também querer implementar uma lista para algo bem específico, sem pensar que tal código será reutilizado para várias coisas diferentes, e então, não precisaríamos nos preocupar com isso.&lt;/p&gt;

&lt;p&gt;Em geral é essa a ideia, e se aplica ao uso das demais funções também.&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Dec 2017 13:50:00 -0200</pubDate>
        <link>http://localhost:4000/ae22cp-172/FAQ.html</link>
        <guid isPermaLink="true">http://localhost:4000/ae22cp-172/FAQ.html</guid>
        
        <category>faq</category>
        
        
        <category>AE22CP-172</category>
        
      </item>
    
      <item>
        <title>Lógica de predicados - Teoremas e regras de equivalência</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#teoremas&quot; id=&quot;markdown-toc-teoremas&quot;&gt;Teoremas&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo-1&quot; id=&quot;markdown-toc-exemplo-1&quot;&gt;Exemplo 1&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo-2&quot; id=&quot;markdown-toc-exemplo-2&quot;&gt;Exemplo 2&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo-3&quot; id=&quot;markdown-toc-exemplo-3&quot;&gt;Exemplo 3&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#equivalências&quot; id=&quot;markdown-toc-equivalências&quot;&gt;Equivalências&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo-1-1&quot; id=&quot;markdown-toc-exemplo-1-1&quot;&gt;Exemplo 1&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo-2-1&quot; id=&quot;markdown-toc-exemplo-2-1&quot;&gt;Exemplo 2&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo-3-1&quot; id=&quot;markdown-toc-exemplo-3-1&quot;&gt;Exemplo 3&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#intercâmbio-de-quantificadores&quot; id=&quot;markdown-toc-intercâmbio-de-quantificadores&quot;&gt;Intercâmbio de quantificadores&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#variáveis-abertas-e-fechadas&quot; id=&quot;markdown-toc-variáveis-abertas-e-fechadas&quot;&gt;Variáveis abertas e fechadas&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo&quot; id=&quot;markdown-toc-exemplo&quot;&gt;Exemplo&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#qual-a-utilidade&quot; id=&quot;markdown-toc-qual-a-utilidade&quot;&gt;Qual a utilidade?&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-1&quot; id=&quot;markdown-toc-exemplo-1&quot;&gt;Exemplo&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;teoremas&quot;&gt;Teoremas&lt;/h1&gt;

&lt;p&gt;Assim como na lógica proposicional, existem fórmulas na lógica de predicados que podem ser demonstradas sem a necessidade de premissas. Tais fórmulas, chamadas &lt;em&gt;teoremas&lt;/em&gt;, são verdades lógicas, ou seja sua verdade é necessária de acordo com as regras da lógica de predicados. Todos os teoremas da lógica proposicional são, também, teoremas na lógica de predicados.&lt;/p&gt;

&lt;h2 id=&quot;exemplo-1&quot;&gt;Exemplo 1&lt;/h2&gt;

&lt;p&gt;O condicional quando aplicado a antecedente e consequente iguais é um teorema na lógica proposicional, $p \to p$, sendo portanto representado em forma de argumento sem premissas&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash p \to p&lt;/script&gt;

&lt;p&gt;Na lógica de predicados temos a versão generalizada deste teorema, a qual é produzida pela introdução do quantificador universal.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall x (Fx\to Fx)&lt;/script&gt;

&lt;p&gt;A demonstração deste teorema segue a estratégia utilizada para demonstrarmos qualquer condicional. Assumimos como hipótese o antecedente e derivamos o consequente.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; Fa                   &amp;   \mbox{Hipótese para prova do condicional}\\
2 &amp; Fa\to Fa     &amp;  \mbox{Introdução do condicional 1}\\
3 &amp; \forall x (Fx\to Fx)             &amp;   \mbox{Introdução do universal em 2}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h2 id=&quot;exemplo-2&quot;&gt;Exemplo 2&lt;/h2&gt;

&lt;p&gt;Provemos o seguinte teorema:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall x Fx \to Fa&lt;/script&gt;

&lt;p&gt;A estratégia de demonstração é a mesma, basta observarmos que $Fa$ é uma instância da fórmula generalizada $\forall x Fx$. Portanto&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall x Fx                   &amp;   \mbox{Hipótese para prova do condicional}\\
2 &amp; \qquad Fa     &amp;  \mbox{Eliminação do universal em 1}\\
3 &amp; \forall x Fx\to Fa             &amp;   \mbox{Prova do condicional 1-2}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h2 id=&quot;exemplo-3&quot;&gt;Exemplo 3&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \neg(\forall x Fx \land \exists x \neg Fx)&lt;/script&gt;

&lt;p&gt;Neste exemplo, não é evidente qual regra de derivação utilizar. Seguindo a estratégia já mencionada anteriormente, tentaremos a demonstração por redução ao absurdo. Assumindo a negação da conclusão como hipótese&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall x Fx \land \exists x \neg Fx    &amp;   \mbox{Hipótese para redução ao absurdo}\\
2 &amp; \qquad \forall x Fx     &amp;  \mbox{Eliminação do condicional em 1}\\
3 &amp; \qquad \exists x \neg Fx     &amp;  \mbox{Eliminação do condicional em 1}\\
4 &amp; \qquad\quad \neg Fa          &amp;   \mbox{Hipótese para eliminação do existencial}\\
5 &amp; \qquad\quad Fa              &amp;    \mbox{Eliminação do universal em 2}\\
6 &amp; \qquad\quad p \land \neg p    &amp;  \mbox{Pela contradição de } Fa\\
7 &amp; \qquad p \land \neg p &amp; \mbox{Eliminação do existencial 4-6}\\
8 &amp; \neg(\forall x Fx \land \exists x \neg Fx) &amp; \mbox{Redução a absurdo 1-7}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h1 id=&quot;equivalências&quot;&gt;Equivalências&lt;/h1&gt;

&lt;p&gt;Assim como vimos para as árvores de refutação da lógica proposicional, nem sempre uma fórmula é facilmente demonstrável ou derivavel. Em alguns desses casos, no entanto, a utilização de uma fórmula equivalente facilita consideravelmente o trabalho.&lt;/p&gt;

&lt;p&gt;Para ilustrar essa ideia, como demonstraríamos o teorema a seguir?&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall x Fx \lor \exists x \neg Fx&lt;/script&gt;

&lt;p&gt;Não é evidente quais regras aplicar, visto que não temos premissas, a regra de eliminação ou introdução da disjunção não são aplicáveis. Podemos então tentar substituir essa fórmula por uma equivalente, mas qual utilizar? Na lógica proposicional demonstramos a equivalência $p \to q \dashv\vdash \neg p \lor q$, seria essa quivalência válida na lógica de predicados.&lt;/p&gt;

&lt;h2 id=&quot;exemplo-1-1&quot;&gt;Exemplo 1&lt;/h2&gt;

&lt;p&gt;Demonstre a equivalência&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x Fx \lor \exists x \neg Fx \dashv\vdash \neg\forall x Fx \to \exists x \neg Fx&lt;/script&gt;

&lt;p&gt;Dada a equivalência acima, demonstrar o teorema $\vdash \forall x Fx \lor \exists x \neg Fx$ é equivalente a demonstrar sua equivalência&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \neg\forall x Fx \to \exists x \neg Fx&lt;/script&gt;

&lt;h2 id=&quot;exemplo-2-1&quot;&gt;Exemplo 2&lt;/h2&gt;

&lt;p&gt;Demonstre a equivalência&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(Fx \to \neg Gx) \dashv\vdash \neg \exists x(Fx \land Gx)&lt;/script&gt;

&lt;h2 id=&quot;exemplo-3-1&quot;&gt;Exemplo 3&lt;/h2&gt;

&lt;p&gt;Demonstre as equivalências&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \forall x \neg Fx \dashv \vdash \exists x Fx \label{eq:1}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \forall x Fx \dashv \vdash \exists x \neg Fx \label{eq:2}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \neg Fx \dashv\vdash \neg \exists x Fx \label{eq:3}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x Fx \dashv\vdash \neg \exists x \neg Fx \label{eq:4}&lt;/script&gt;

&lt;h1 id=&quot;intercâmbio-de-quantificadores&quot;&gt;Intercâmbio de quantificadores&lt;/h1&gt;

&lt;p&gt;As últimas equivalências, descritas no Exemplo 3, são mais genéricas do que parecem à primeira vista. De fato, elas são válidas para quaiquer subfórmulas, desde que sejam subfórmulas dependentes da mesma variável. No entanto, para formalizarmos essa ideia, precisamos definir antes alguns conceitos.&lt;/p&gt;

&lt;h2 id=&quot;variáveis-abertas-e-fechadas&quot;&gt;Variáveis abertas e fechadas&lt;/h2&gt;

&lt;p&gt;Consideremos como exemplo simples a fórmula $\forall x Fx$. Pela definição das regras de formação da linguagem da lógica de predicados, sabemos que $Fx$ só faz sentido, se houver antes um quantificador discriminando $x$.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Uma fórmula é dita fechada em relação a uma variável $x$ qualquer, se existe um quantificador associado a tal variável. Exemplo: $\forall x (Fx \land Gx)$&lt;/li&gt;
  &lt;li&gt;Uma fórmula é dita aberta em relação a uma variável $x$ qualquer, se não existe quantificador que discrimine tal variável. Exemplo: $Fx \land Gx$, $\forall y Fxy$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Essa terminologia permite nos referirmos mais facilmente a fórmulas e subfórmulas com a mesma característica em termos de variáveis. Para melhor exemplificar, consideremos a equivalência $\eqref{eq:4}$ descrita anteriormente.&lt;/p&gt;

&lt;p&gt;Nela, podemos nos referir $Fx$ como uma fórmula &lt;strong&gt;aberta em $x$&lt;/strong&gt; enquanto $\forall x Fx$ é uma fórmula &lt;strong&gt;fechada em $x$&lt;/strong&gt;. Obviamente, existem diversas outras fórmulas abertas em $x$. Por exemplo $Fx\land Gx$ e $Fx\to Gx$ são ambas fórmulas abertas em $x$. Ou seja, todas elas compartilham essa mesma característica com $Fx$. Podemos então, expressar ideias como&lt;/p&gt;

&lt;p&gt;“Seja qualquer fórmula $\phi$ que seja aberta em $\beta$”.&lt;/p&gt;

&lt;p&gt;Em que $\beta$ represente qualquer variável, e.g. $x, y, z,\dots$. Isso nos permite generalizar as equivalências $\eqref{eq:1}-\eqref{eq:4}$ para além de $Fx$, da seguinte forma:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \forall \beta \neg \phi \dashv \vdash \exists \beta \phi \label{eq:5}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \forall \beta \phi \dashv \vdash \exists \beta \neg \phi&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall \beta \neg \phi \dashv\vdash \neg \exists \beta \phi&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall \beta \phi \dashv\vdash \neg \exists \beta \neg \phi \label{eq:8}&lt;/script&gt;

&lt;h2 id=&quot;exemplo&quot;&gt;Exemplo&lt;/h2&gt;

&lt;p&gt;Vejamos um exemplo da aplicação dessa generalização. Considere a forma de argumento a seguir:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x (Fx \to \neg Gx) \vdash \neg \exists x (Fx \land Gx)&lt;/script&gt;

&lt;p&gt;Neste exemplo, $(Fx\to\neg Gx)$ e $(Fx \land Gx)$ são fórmulas abertas em $x$. Se dermos um nome mais simples para cada uma delas, por exemplo, $\phi$ e $\psi$, respectivamente. Então a forma de argumento acima é instância de algo mais genérico&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \phi \vdash \exists x \psi&lt;/script&gt;

&lt;h2 id=&quot;qual-a-utilidade&quot;&gt;Qual a utilidade?&lt;/h2&gt;

&lt;p&gt;A principal utilidade desse tipo de generalização é nos permitir utilizar as equivalências em um contexto amplo, sem necessariamente ter que provar cada uma delas, mostrando que todas são instâncias dos mesmos teoremas. Em outras palavras, se:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall x \neg Fx  \leftrightarrow \neg \exists Fx&lt;/script&gt;

&lt;p&gt;Então o teorema a seguir também é verdadeiro&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall x \neg (Fx \land Gx)  \leftrightarrow \neg \exists (Fx \land Gx)&lt;/script&gt;

&lt;p&gt;pois ambos são instâncias do mesmo teorema genérico.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall \beta \neg \phi \leftrightarrow \neg \exists\beta \phi&lt;/script&gt;

&lt;p&gt;Este tipo de intercâmbio entre equivalências em muitos casos torna as demonstrações muito mais simples.&lt;/p&gt;

&lt;h3 id=&quot;exemplo-1&quot;&gt;Exemplo&lt;/h3&gt;

&lt;p&gt;Demonstre o seguinte teoremas&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall x  Fx \lor \exists x \neg Fx&lt;/script&gt;

&lt;p&gt;Iniciaremos com a tautologia&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x Fx \lor \neg \forall x Fx&lt;/script&gt;

&lt;p&gt;A subfórmula $\neg \forall x Fx$ pode ser interpretada como&lt;/p&gt;

&lt;p&gt;“Nem todo x satisfaz o predicado F”&lt;/p&gt;

&lt;p&gt;Que por sua vez é equivalente a dizermos que&lt;/p&gt;

&lt;p&gt;“Existe x que não satisfaz F”&lt;/p&gt;

&lt;p&gt;A segunda versão pode ser escrita simbolicamente como $\exists x \neg Fx$. Esta equivalência está representada em $\eqref{eq:2}$. Substituindo essa equivalência na tautologia acima, produzimos&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x Fx \lor \exists x \neg Fx&lt;/script&gt;

&lt;p&gt;O qual finaliza a demonstração do teorema.&lt;/p&gt;
</description>
        <pubDate>Wed, 18 Oct 2017 10:20:00 -0200</pubDate>
        <link>http://localhost:4000/lc21cp-172/lp-teoremas-equivalencias.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/lp-teoremas-equivalencias.html</guid>
        
        <category>predicados</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
      <item>
        <title>Lista VIII - Lógica de predicados, dedução</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#exercícios&quot; id=&quot;markdown-toc-exercícios&quot;&gt;Exercícios&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#referências&quot; id=&quot;markdown-toc-referências&quot;&gt;Referências&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;exercícios&quot;&gt;Exercícios&lt;/h1&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x Fx \vdash Fa \land (Fb \land (Fc \land Fd))&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(Fx \lor Gx), \neg Fa \vdash \neg Ga&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg Fa \vdash \neg \forall x (Fx \land Gx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(Fx \leftrightarrow r), r \vdash Fa&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(\neg Fx \lor \neg Gx) \vdash \neg(Fa \land Ga)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(Fx \to Gx) \vdash \forall x(\neg Gx \to \neg Fx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(Fx \to Gx) \vdash \forall x\neg Gx \to \forall x \neg Fx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \forall y Fxy \vdash \forall x Fxx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x Fx \vdash \forall x Gx \to \forall x (Fx \land Gx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \forall y(Fxy \to \neg Fyx) \vdash \forall x \neg Fxx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x Fx \vdash \exists x Fx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x Fx \vdash \neg Fa&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists x \neg Fx \vdash \neg \forall x Fx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(Fx \to Gx) \vdash \exists x Fx \to \exists x Gx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x (Fx \land Gx) \vdash \forall x (\neg Fx \lor \neg Gx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \forall x(Fx \land Gx) \vdash \exists x(\neg Fx \lor \neg Gx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x \exists y Lxy \vdash \forall x \neg Lxx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists x Fx \vdash \exists x \exists y(Fx \land Fy)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \neg Fx \vdash \forall x(Fx \to Gx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \neg Fx \vdash \forall x(Fx \to \neg Gx)&lt;/script&gt;

&lt;h1 id=&quot;referências&quot;&gt;Referências&lt;/h1&gt;

&lt;p&gt;Seção 2.1: Pg. 71, &lt;a href=&quot;http://www.cse.chalmers.se/edu/course/DAT060/huthryan_lics2_sol.pdf&quot;&gt;Logica - Huth &amp;amp; Ryan (PDF).&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Capítulo 6: Pgs. 254-284, &lt;a href=&quot;https://racionalistasusp.files.wordpress.com/2010/01/nolt-john-rohatyn-dennis-lc3b3gica.pdf&quot;&gt;Logica - John Nolt (PDF).&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 05 Oct 2017 10:00:00 -0300</pubDate>
        <link>http://localhost:4000/lc21cp-172/lista8-logica-predicados-deducao.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/lista8-logica-predicados-deducao.html</guid>
        
        <category>predicados</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
      <item>
        <title>Lógica de predicados - Regras de dedução II</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#quantificador-existencial&quot; id=&quot;markdown-toc-quantificador-existencial&quot;&gt;Quantificador existencial&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#regra-de-introdução&quot; id=&quot;markdown-toc-regra-de-introdução&quot;&gt;Regra de introdução&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-1&quot; id=&quot;markdown-toc-exemplo-1&quot;&gt;Exemplo 1&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-2&quot; id=&quot;markdown-toc-exemplo-2&quot;&gt;Exemplo 2&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-4&quot; id=&quot;markdown-toc-exemplo-4&quot;&gt;Exemplo 4&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-5&quot; id=&quot;markdown-toc-exemplo-5&quot;&gt;Exemplo 5&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#regra-eliminação&quot; id=&quot;markdown-toc-regra-eliminação&quot;&gt;Regra Eliminação&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-1-1&quot; id=&quot;markdown-toc-exemplo-1-1&quot;&gt;Exemplo 1&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-2-619---pg277&quot; id=&quot;markdown-toc-exemplo-2-619---pg277&quot;&gt;Exemplo 2 (6.19 - pg.277)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-3-620&quot; id=&quot;markdown-toc-exemplo-3-620&quot;&gt;Exemplo 3 (6.20)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-4-621&quot; id=&quot;markdown-toc-exemplo-4-621&quot;&gt;Exemplo 4 (6.21)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-5-1&quot; id=&quot;markdown-toc-exemplo-5-1&quot;&gt;Exemplo 5&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-6&quot; id=&quot;markdown-toc-exemplo-6&quot;&gt;Exemplo 6&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-7&quot; id=&quot;markdown-toc-exemplo-7&quot;&gt;Exemplo 7&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;quantificador-existencial&quot;&gt;Quantificador existencial&lt;/h2&gt;

&lt;p&gt;Assim como todos os demais operadores o quantificador existencial ($\exists$) também possui duas regras de inferência: introdução e eliminação.&lt;/p&gt;

&lt;h3 id=&quot;regra-de-introdução&quot;&gt;Regra de introdução&lt;/h3&gt;

&lt;p&gt;A regra de introdução do quantificador existencial segue de forma intuitiva e direta a partir de sua definição. Suponhamos, por exemplo, o caso específico $F(a)\land G(a)$. Por si só, este exemplo já nos permite concluir a forma mais geral $\exists x (Fx \land Gx)$, nesta situação $a$ serviu como prova da existência de um determinado $x$ para o qual $Fx \land Gx$ fosse verdadeira.&lt;/p&gt;

&lt;h4 id=&quot;exemplo-1&quot;&gt;Exemplo 1&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x (Fx \lor Gx) \vdash \exists x(Fx \lor Gx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall x (Fx \lor Gx) &amp; \mbox{premissa}\\
2 &amp; Fa \lor Ga       &amp; \mbox{e-}\forall 1 \\
3 &amp; \exists x (Fx \lor Gx) &amp; \mbox{Introdução do existencial em 2}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h4 id=&quot;exemplo-2&quot;&gt;Exemplo 2&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x (Fx \lor Gx) \vdash \exists x Fx \lor \exists x Gx&lt;/script&gt;

&lt;p&gt;Apesar da similaridade como exemplo anterior, a demonstração neste caso é um pouco mais complexa. Precisamos provar que é possível derivar a conclusão a partir de cada disjuncto, utilizando a regra de eliminação da disjunção.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\dfrac{\phi\quad\psi\quad (\phi\to\chi) \quad (\psi\to\chi)}{\chi}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall x (Fx \lor Gx) &amp; \mbox{premissa}\\
2 &amp; Fa \lor Ga       &amp; \mbox{e-}\forall 1 \\
3.1 &amp; \qquad Fa  &amp; \mbox{Hipótese 1 da disjunção}\\
3.2 &amp; \qquad \exists x Fx &amp; \mbox{i-}\exists 3.1 \\
3.3 &amp; \qquad \exists x Fx \lor \exists x Gx &amp; \mbox{i-}\lor 3.2 \\
4   &amp; Fa \to (\exists x Fx \lor \exists x Gx) &amp; \mbox{i-}\to 3.1-3.3 \\
5.1   &amp; \qquad Ga      &amp; \mbox{Hipótese 2 da disjunção} \\
5.2 &amp; \qquad \exists x Gx &amp; \mbox{i-}\exists 5 \\
5.3 &amp; \qquad \exists x Fx \lor \exists x Gx &amp; \mbox{i-}\lor 5.2 \\
6  &amp; Ga \to (\exists x Fx \lor \exists x Gx) &amp; \mbox{i-}\to 5.1-5.3 \\
7  &amp; \exists x Fx \lor \exists x Gx &amp; \mbox{e-}\lor 2, 4, 6
\end{array} %]]&gt;&lt;/script&gt;

&lt;h4 id=&quot;exemplo-4&quot;&gt;Exemplo 4&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x Fx \vdash \forall x \neg Fx&lt;/script&gt;

&lt;p&gt;Para provar a inexistência de um $Fa$, utilizamos a estratégia de redução ao absurdo.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \neg \exists x Fx &amp; \mbox{premissa}\\
2.1 &amp; Fa        &amp; \mbox{Hipótese de absurdo} \\
2.2 &amp; \exists x Fx &amp; \mbox{Introdução do existencial 2.1}\\
2.3 &amp; \exists x Fx \land \neg \exists x Fx &amp; \mbox{Introdução da conjunção 1,2.2}\\
3   &amp; \neg Fa  &amp; \mbox{Por redução ao absurdo 2.1-2.3}\\
4   &amp; \forall x \neg Fx  &amp; \mbox{Introdução do universal 3}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h4 id=&quot;exemplo-5&quot;&gt;Exemplo 5&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x (Fx \land \neg Gx) \vdash \forall x (Fx \to Gx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \neg \exists x (Fx \land \neg Gx) &amp; \mbox{premissa}\\
2.1.0 &amp; \qquad Fa             &amp; \mbox{Hipótese para o condicional}\\
2.1.1 &amp; \qquad\qquad \neg Ga &amp; \mbox{Hipótese para o absurdo}\\
2.1.2 &amp; \qquad\qquad Fa \land \neg Ga &amp; \mbox{Introdução conjunção 2.1,2.1.1}\\
2.1.3 &amp; \qquad\qquad \exists x (Fx \land \neg Gx) &amp; \mbox{Introdução existencial 2.1.2}\\
2.1.4 &amp; \qquad\qquad Ga &amp; \mbox{Absurdo em 1 e 2.1.3}\\
2.2   &amp; \qquad Fa \to Ga &amp; \mbox{Introdução do condicional 2.1.0 - 2.1.4}\\\
3   &amp; \forall x (Fx \to Gx) &amp; \mbox{Introdução universal 2.2}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;regra-eliminação&quot;&gt;Regra Eliminação&lt;/h3&gt;

&lt;p&gt;A eliminação do quantificador existencial segue raciocínio contrário. Da premissa que afirma a existência de algo, por exemplo, $\exists x (Fx \land Gx)$, sabemos que para algum $x$ a propriedade é verdadeira. No entanto, não sabemos qual elemento substituir no lugar de $x$, visto que pode ser o caso de nem todos possíveis elementos satisfazerem $(Fx \land Gx)$.&lt;/p&gt;

&lt;p&gt;Por esse motivo, para eliminarmos um quantificador existencial, temos que o fazer por meio de uma hipótese, a qual irá supor que um determinado objetvo $a$ satisfaça a propriedade em questão.&lt;/p&gt;

&lt;h4 id=&quot;exemplo-1-1&quot;&gt;Exemplo 1&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists (Fx \land Gx) \vdash \exists x Fx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \exists x (Fx \land Gx) &amp; \mbox{premissa}\\
2 &amp; \qquad Fa \land Ga     &amp;  \mbox{Hipótese para eliminação do existencial}\\
3 &amp; \qquad Fa             &amp;   \mbox{Eliminação da conjunção 2}\\
4 &amp; \qquad \exists x Fx   &amp;   \mbox{Introdução do existencial 3}\\
5 &amp; \exists x Fx   &amp;  \mbox{Eliminação do existencial 1, 2-4}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h4 id=&quot;exemplo-2-619---pg277&quot;&gt;Exemplo 2 (6.19 - pg.277)&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x (Fx \to Gx), \exists x Fx \vdash \exists x Gx&lt;/script&gt;

&lt;h4 id=&quot;exemplo-3-620&quot;&gt;Exemplo 3 (6.20)&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists x (Fx \lor Gx) \vdash \exists x Fx \lor \exists x Gx&lt;/script&gt;

&lt;h4 id=&quot;exemplo-4-621&quot;&gt;Exemplo 4 (6.21)&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists Fx \lor \exists x Gx \vdash \exists x (Fx \lor Gx)&lt;/script&gt;

&lt;h4 id=&quot;exemplo-5-1&quot;&gt;Exemplo 5&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists x \forall y Lxy \vdash \forall x \exists y Lyx&lt;/script&gt;

&lt;h4 id=&quot;exemplo-6&quot;&gt;Exemplo 6&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x (Fx \to \exists y Lxy), \exists x (Fx \land Gx) \vdash \exists x\exists y (Gx \land Lxy)&lt;/script&gt;

&lt;h4 id=&quot;exemplo-7&quot;&gt;Exemplo 7&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x (Fx \to \neg Gx) \vdash \neg \exists x (Fx \land Gx)&lt;/script&gt;
</description>
        <pubDate>Wed, 04 Oct 2017 10:20:00 -0300</pubDate>
        <link>http://localhost:4000/lc21cp-172/logica-predicados-deducao-2.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/logica-predicados-deducao-2.html</guid>
        
        <category>predicados</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
      <item>
        <title>Lógica de predicados - Regras de dedução I</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#regras-de-inferência&quot; id=&quot;markdown-toc-regras-de-inferência&quot;&gt;Regras de inferência&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#quantificador-universal&quot; id=&quot;markdown-toc-quantificador-universal&quot;&gt;Quantificador universal&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#regra-de-eliminação&quot; id=&quot;markdown-toc-regra-de-eliminação&quot;&gt;Regra de eliminação&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#exemplo-1&quot; id=&quot;markdown-toc-exemplo-1&quot;&gt;Exemplo 1&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#exemplo-2&quot; id=&quot;markdown-toc-exemplo-2&quot;&gt;Exemplo 2&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#exemplo-3&quot; id=&quot;markdown-toc-exemplo-3&quot;&gt;Exemplo 3&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#regra-de-introdução&quot; id=&quot;markdown-toc-regra-de-introdução&quot;&gt;Regra de introdução&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#exemplo-1-1&quot; id=&quot;markdown-toc-exemplo-1-1&quot;&gt;Exemplo 1&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#exemplo-2-1&quot; id=&quot;markdown-toc-exemplo-2-1&quot;&gt;Exemplo 2&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#exemplo-3-1&quot; id=&quot;markdown-toc-exemplo-3-1&quot;&gt;Exemplo 3&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#exemplo-4&quot; id=&quot;markdown-toc-exemplo-4&quot;&gt;Exemplo 4&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#exemplo-5&quot; id=&quot;markdown-toc-exemplo-5&quot;&gt;Exemplo 5&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;regras-de-inferência&quot;&gt;Regras de inferência&lt;/h1&gt;

&lt;p&gt;O cálculo de predicados usa as mesmas dez regras do cálculo proposicional. Adicionalmente, temos as regras de introdução e de eliminação dos quantificadores. Relembremos um exemplo do cálculo proposicional&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg r \lor q, q \to p \vdash r \to p&lt;/script&gt;

&lt;p&gt;Este exemplo pode ser demonstrado utilizando a abordagem de prova de condicionais: assumir o antecedente como hipótese e derivar o consequente. Vejamos como ficaria&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \neg r \lor q &amp; \mbox{premissa}\\
2 &amp; q \to p       &amp; \mbox{premissa}\\
3 &amp; r             &amp; \mbox{hipótese}\\
4 &amp; \neg\neg r     &amp; \mbox{Dupla negação 3}\\
5 &amp; q            &amp; \mbox{Silogismo disjuntivo 1,4}\\
6 &amp; p           &amp;  \mbox{Modus ponens 2,5}\\
7 &amp; r \to p     &amp; \mbox{Prova do condicional 3-6}
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;Um exemplo similar na lógica de predicados, poderia ser provado utilizando-se das mesmas regras de derivação. Consideremos, por exemplo, a forma de argumento.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg F(a) \lor \exists x F(x), \exists x F(x) \to p \vdash F(a) \to p&lt;/script&gt;

&lt;p&gt;Se substituirmos as subfórmulas análogamente ao exemplo anterior, temos a demonstração a seguir:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \neg F(a) \lor \exists x F(x) &amp; \mbox{premissa}\\
2 &amp; \exists x F(x) \to p       &amp; \mbox{premissa}\\
3 &amp; F(a)             &amp; \mbox{hipótese}\\
4 &amp; \neg\neg F(a)     &amp; \mbox{Dupla negação 3}\\
5 &amp; \exists x F(x)            &amp; \mbox{Silogismo disjuntivo 1,4}\\
6 &amp; p           &amp;  \mbox{Modus ponens 2,5}\\
7 &amp; F(a) \to p     &amp; \mbox{Prova do condicional 3-6}
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;Neste exemplo da lógica de predicados não precisamos utilizar regras de inferência para os quantificadores, deste modo a demonstração se restringiu à utilização das regras já definidas para a lógica proposicional. Como esse não é sempre o caso, precisamos especificar o funcionamento das regras de derivação para os quantificadores: &lt;em&gt;universal&lt;/em&gt; ($\forall$) e &lt;em&gt;existencial&lt;/em&gt; ($\exists$).&lt;/p&gt;

&lt;h2 id=&quot;quantificador-universal&quot;&gt;Quantificador universal&lt;/h2&gt;

&lt;h3 id=&quot;regra-de-eliminação&quot;&gt;Regra de eliminação&lt;/h3&gt;
&lt;p&gt;Iremos iniciar pela definição da regra de eliminação do quantificador universal ($\forall$e). Intuitivamente a regra de eliminação do quantificador universal é bem simples e segue a seguinte ideia:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Se algo é valido para todos objetos, também é válido para um objeto em específico.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Portanto, uma fórmula geral do tipo $\forall x P(x)$, pode ser substituída durante uma demonstração por um caso específico $P(a)$, onde $a$ é um termo qualquer. Vejamos o seguinte exemplo.&lt;/p&gt;

&lt;p&gt;“Todos os homens são mortais”&lt;/p&gt;

&lt;p&gt;“Sócrates é homem”&lt;/p&gt;

&lt;p&gt;“Sócrates é mortal”&lt;/p&gt;

&lt;p&gt;Se definirmos os predicados:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$H(x):$ $x$ é homem&lt;/li&gt;
  &lt;li&gt;$M(x):$ $x$ é mortal&lt;/li&gt;
  &lt;li&gt;$s:$ Sócrates&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Temos o seguinte argumento formalizado:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(H(x)\to M(x)), H(s) \vdash M(s)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall x(H(x)\to M(x)) &amp; \mbox{premissa}\\
2 &amp; H(s)       &amp; \mbox{premissa}\\
3 &amp; H(s)\to M(s) &amp; \mbox{Eliminação do universal 1}\\
4 &amp; M(s)        &amp;  \mbox{Modus Ponens 2, 3}
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;O caso genérico indicado pela premissa $\forall x(H(x)\to M(x))$ pode ser especializado em termos de $s$ (Sócrates), levando à fórmula $H(s)\to M(s)$. Ou seja, se o fato de ser homem implica ser mortal, essa regra se aplica a qualquer homem $x$, inclusive Sócrates $s$. Pode-se dizer que $H(s)\to M(s)$ é uma instanciação da regra universal.&lt;/p&gt;

&lt;h4 id=&quot;exemplo-1&quot;&gt;Exemplo 1&lt;/h4&gt;

&lt;p&gt;Prove a validade da seguinte forma de argumento&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x ~F(x)\to G(x), ~\forall x F(x) ~~~\vdash~~ G(a)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall x ~F(x)\to G(x) &amp; \mbox{premissa}\\
2 &amp; \forall x F(x)       &amp; \mbox{premissa}\\
3 &amp; F(a)\to G(a) &amp; \mbox{Eliminação do universal 1}\\
4 &amp; F(a)        &amp;  \mbox{Eliminação do universal 2}\\
5 &amp; G(A)        &amp;  \mbox{Modus Ponens 3, 4}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h4 id=&quot;exemplo-2&quot;&gt;Exemplo 2&lt;/h4&gt;

&lt;p&gt;Prove a validade da seguinte forma de argumento&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg F(a)~~\vdash ~~\neg \forall x F(x)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \neg F(a)        &amp; \mbox{premissa}\\
2 &amp; \forall x F(x)   &amp; \mbox{Hipótese por absurdo}\\
3 &amp; F(a)             &amp; \mbox{Eliminação do universal 1}\\
4 &amp; \neg F(a) \land F(a)       &amp;  \mbox{Introdução do condicional 1,3}\\
5 &amp; \neg \forall x F(x)        &amp;  \mbox{Redução ao absurdo 2-4}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h4 id=&quot;exemplo-3&quot;&gt;Exemplo 3&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \forall y F(x,y)~~ \vdash F(a,a)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall x \forall y F(x,y)        &amp; \mbox{premissa}\\
2 &amp; \forall y F(a,y)   &amp; \mbox{Eliminação do universal 1}\\
3 &amp; F(a,a)      &amp; \mbox{Eliminação do universal 2}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;regra-de-introdução&quot;&gt;Regra de introdução&lt;/h3&gt;

&lt;p&gt;Em princípio, para introduzirmos uma fórmula do tipo $\forall x F(x)$, teríamos que demonstrar que para qualquer que seja $x$ então o predicado $P(x)$ é verdadeiro. Obviamente, sendo $x$ parte de um domínio possivelmente infinito esse tipo de abordagem não é possível. Como então introduzirmos o quantificador universal?&lt;/p&gt;

&lt;p&gt;A ideia também é simples, apesar de um pouco confusa no início. Se eu consigo demonstrar que para um caso específico $a$, $P(a)$ é verdadeiro, então, se nenhuma consideração/restrição foi feita em termos de $a$, essa demonstração poderia ser utilizada para demonstrar que para qualquer $x$, $P(x)$ também é verdadeiro. Consideremos um exemplo:&lt;/p&gt;

&lt;p&gt;“Todos os peixes são ciprinídeos”&lt;/p&gt;

&lt;p&gt;“Todos ciprinídeos são vistosos”&lt;/p&gt;

&lt;p&gt;“Todos os peixes são vistosos”&lt;/p&gt;

&lt;p&gt;Que formalizada por meio dos predicados:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$P(x)$: $x$ é peixe&lt;/li&gt;
  &lt;li&gt;$C(x)$: $x$ é ciprinídeo&lt;/li&gt;
  &lt;li&gt;$V(x)$: $x$ é vistoso&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(Px\to Cx),~~\forall x(Cx\to Vx) \vdash \forall (Px\to Vx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall x(Px\to Cx)        &amp; \mbox{premissa}\\
2 &amp; \forall x(Cx\to Vx)   &amp; \mbox{premissa}\\
3 &amp; Pa\to Ca      &amp; \mbox{Eliminação do universal 1}\\
4 &amp; Ca\to Va      &amp; \mbox{Eliminação do universal 2}\\
5 &amp; Pa\to Va      &amp; \mbox{Transitividade 3,4}\\
6 &amp; \forall x(Px\to Vx)      &amp; \mbox{Generalização universal 5}
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;Apesar de $a$ neste exemplo ser utilizado para referenciar um caso específico de $x$, nenhuma suposição foi feita acerca de $a$, portanto ele poderia ser utilizado para substituir qualquer $x$. Portanto é possível generalizar a conclusão de $a$ para $\forall x$.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Para que a aplicação dessa regra seja válida, não pode haver suposições sobre o símbolo $a$, ou seja, ele &lt;strong&gt;não pode aparecer nas premissas&lt;/strong&gt; nem e nenhuma &lt;strong&gt;hipótese vigente&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;Pois nesses casos haveria suposições sobre $a$, consequentemente ele não poderia representar um $x$ arbitrário.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;exemplo-1-1&quot;&gt;Exemplo 1&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall (Fx \land Gx) ~~ \vdash ~~\forall x Fx \land \forall x Gx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall (Fx \land Gx)        &amp; \mbox{premissa}\\
2 &amp; Fa \land Ga   &amp; \mbox{Eliminação do universal 1}\\
3 &amp; Fa      &amp; \mbox{Eliminação da conjunção 2}\\
4 &amp; Ga      &amp; \mbox{Eliminação da conjunção 2}\\
5 &amp; \forall x Fx      &amp; \mbox{Introdução do universal 3}\\
6 &amp; \forall x Gx      &amp; \mbox{Introdução do universal 4}\\
7 &amp; \forall x Fx \land \forall x Gx      &amp; \mbox{Introdução da conjunção 5, 6}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h4 id=&quot;exemplo-2-1&quot;&gt;Exemplo 2&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x (Fx \to (Gx \lor Hx)), \forall x \neg Gx  \vdash \forall x Fx \to \forall x Hx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall x (Fx \to (Gx \lor Hx))        &amp; \mbox{premissa}\\
2 &amp; \forall x \neg Gx   &amp; \mbox{premissa}\\
3 &amp; Fa \to (Ga \lor Ha)      &amp; \mbox{Eliminação do universal 1}\\
4 &amp; \neg Ga      &amp; \mbox{Eliminação do universal 2}\\
5 &amp; \qquad \forall x Fx      &amp; \mbox{Hipótese do condicional}\\
6 &amp; \qquad Fa      &amp; \mbox{Eliminação do universal 5}\\
7 &amp; \qquad Ga \lor Ha      &amp; \mbox{Modus Ponens 3, 6}\\
8 &amp; \qquad Ha             &amp; \mbox{Silogismo disjuntivo 4,7}\\
9 &amp; \qquad\forall x Hx   &amp; \mbox{Introdução do universal 8}\\
10 &amp; \forall x Fx \to \forall x Hx &amp; \mbox{Prova do condicional 5-9}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h4 id=&quot;exemplo-3-1&quot;&gt;Exemplo 3&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x (Fx \to (Gx \lor Hx)), \forall x \neg Gx  \vdash \forall x (Fx \to Hx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall x (Fx \to (Gx \lor Hx))        &amp; \mbox{premissa}\\
2 &amp; \forall x \neg Gx   &amp; \mbox{premissa}\\
3 &amp; Fa \to (Ga \lor Ha)      &amp; \mbox{Eliminação do universal 1}\\
4 &amp; \neg Ga      &amp; \mbox{Eliminação do universal 2}\\
5 &amp; \qquad Fa      &amp; \mbox{Hipótese do condicional}\\
6 &amp; \qquad Ga \lor Ha      &amp; \mbox{Modus Ponens 3, 5}\\
7 &amp; \qquad Ha             &amp; \mbox{Silogismo disjuntivo 4,7}\\
8 &amp; Fa \to Ha   &amp; \mbox{Prova do condicional 5-7}\\
9 &amp; \forall x (Fx \to Hx) &amp; \mbox{Introdução do universal 8}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h4 id=&quot;exemplo-4&quot;&gt;Exemplo 4&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x Fax, \forall x \forall y (Fxy \to Gyx) \vdash \forall x Gxa&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall x Fax        &amp; \mbox{premissa}\\
2 &amp; \forall x \forall y (Fxy \to Gyx)  &amp; \mbox{premissa}\\
3 &amp; Fab      &amp; \mbox{Eliminação do universal 1}\\
4 &amp; \forall y (Fay \to Gya)      &amp; \mbox{Eliminação do universal 2}\\
5 &amp; Fab \to Gba      &amp; \mbox{Eliminação do universal 4}\\
6 &amp; Gba      &amp; \mbox{Modus Ponens 3, 5}\\
7 &amp; \forall x Gxa             &amp; \mbox{Introdução do universal 6}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h4 id=&quot;exemplo-5&quot;&gt;Exemplo 5&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x Fx \to \forall x Gx, \neg Ga \vdash \neg \forall x Fx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall x Fx \to \forall x Gx        &amp; \mbox{premissa}\\
2 &amp; \neg Ga  &amp; \mbox{premissa}\\
3 &amp; \qquad \forall x Fx      &amp; \mbox{Hipótese para absurdo}\\
4 &amp; \qquad \forall x Gx      &amp; \mbox{Modus Ponens 1, 3}\\
5 &amp; \qquad Ga      &amp; \mbox{Eliminação do universal 4}\\
6 &amp; \qquad Ga \land \neg Ga      &amp; \mbox{Introdução da conjunção 2,5}\\
7 &amp; \neg \forall x Fx             &amp; \mbox{Redução ao absurdo 3-6}
\end{array} %]]&gt;&lt;/script&gt;
</description>
        <pubDate>Wed, 04 Oct 2017 10:20:00 -0300</pubDate>
        <link>http://localhost:4000/lc21cp-172/logica-predicados-deducao-1.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/logica-predicados-deducao-1.html</guid>
        
        <category>predicados</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
      <item>
        <title>Lista VII - Lógica de predicados, formalização</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#exercícios&quot; id=&quot;markdown-toc-exercícios&quot;&gt;Exercícios&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#0-predicados-unários&quot; id=&quot;markdown-toc-0-predicados-unários&quot;&gt;#0 Predicados unários&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#1--predicados-binários&quot; id=&quot;markdown-toc-1--predicados-binários&quot;&gt;#1  Predicados binários&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#2-predicados-binários&quot; id=&quot;markdown-toc-2-predicados-binários&quot;&gt;#2 Predicados binários&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#3-fórmulas-bem-formadas&quot; id=&quot;markdown-toc-3-fórmulas-bem-formadas&quot;&gt;#3 Fórmulas bem formadas&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#referências&quot; id=&quot;markdown-toc-referências&quot;&gt;Referências&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;exercícios&quot;&gt;Exercícios&lt;/h1&gt;

&lt;h2 id=&quot;0-predicados-unários&quot;&gt;#0 Predicados unários&lt;/h2&gt;

&lt;p&gt;Interpretando como&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$c$: “está chovendo”&lt;/li&gt;
  &lt;li&gt;$R$: “é uma rã”&lt;/li&gt;
  &lt;li&gt;$V$: “é verde”&lt;/li&gt;
  &lt;li&gt;$S$: “é saltitante”&lt;/li&gt;
  &lt;li&gt;$I$: “é iridescente”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Formalize as seguintes sentenças:&lt;/p&gt;

&lt;p&gt;a. Todas as rãs são verdes&lt;/p&gt;

&lt;p&gt;b. Nenhuma rã é verdes&lt;/p&gt;

&lt;p&gt;c. Algumas rãs são verdes&lt;/p&gt;

&lt;p&gt;d. Algumas rãs não são verdes&lt;/p&gt;

&lt;p&gt;e. Toda coisa é uma rã.&lt;/p&gt;

&lt;p&gt;f. Alguma coisa é uma rã.&lt;/p&gt;

&lt;p&gt;g. Nem toda coisa é uma rã.&lt;/p&gt;

&lt;p&gt;h. Nada é uma rã.&lt;/p&gt;

&lt;p&gt;i. Existem rãs verdes&lt;/p&gt;

&lt;p&gt;j. Qualquer coisa ou é rã ou é iridescente.&lt;/p&gt;

&lt;p&gt;k. Qualquer coisa é uma rã verde.&lt;/p&gt;

&lt;p&gt;l. Está chovendo e algumas rãs estão saltitando&lt;/p&gt;

&lt;p&gt;m. Se está chovendo, então todas as rãs estão saltitando&lt;/p&gt;

&lt;p&gt;n. Algumas coisas são verdes e algumas não são&lt;/p&gt;

&lt;p&gt;o. Algumas coisas são verdes e iridescentes simultaneamente&lt;/p&gt;

&lt;p&gt;p. Ou qualquer coisa é uma rã, ou nada é uma rã&lt;/p&gt;

&lt;p&gt;q. Qualquer coisa ou é uma rã ou não é uma rã.&lt;/p&gt;

&lt;p&gt;r. Todas as rãs são rãs.&lt;/p&gt;

&lt;p&gt;s. Somente rãs são verdes.&lt;/p&gt;

&lt;p&gt;t. Não existem rãs iridescentes.&lt;/p&gt;

&lt;p&gt;u. Todas as rãs verdes estão saltitando&lt;/p&gt;

&lt;p&gt;v. Algumas rãs verdes não estão saltitando&lt;/p&gt;

&lt;p&gt;w. Não é verdade que algumas rãs verdes estão saltitando.&lt;/p&gt;

&lt;p&gt;x. Se nada é verde, então não existem rãs verdes.&lt;/p&gt;

&lt;p&gt;y. Rãs verdes saltam se e somente se não está chovendo.&lt;/p&gt;

&lt;h2 id=&quot;1--predicados-binários&quot;&gt;#1  Predicados binários&lt;/h2&gt;

&lt;p&gt;Use os predicados&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$A(x,y)$: $x$ admira $y$&lt;/li&gt;
  &lt;li&gt;$B(x,y)$: $x$ estava presente em $y$&lt;/li&gt;
  &lt;li&gt;$P(x)$: $x$ é um professor&lt;/li&gt;
  &lt;li&gt;$E(x)$: $x$ é um estudante&lt;/li&gt;
  &lt;li&gt;$L(x)$: $x$ é uma aula&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;e o símbolo funcional (constante)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$m$: Maria&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;a. Maria admira todo professor&lt;/p&gt;

&lt;p&gt;b. Algum professor admira Maria&lt;/p&gt;

&lt;p&gt;c. Maria admira a si própria&lt;/p&gt;

&lt;p&gt;d. Nenhum estudante estava presente em todas as aulas.&lt;/p&gt;

&lt;p&gt;e. Nenhuma aula teve a presença de todos os estudantes&lt;/p&gt;

&lt;p&gt;f. Nenhuma aula teve a presença de qualquer estudante.&lt;/p&gt;

&lt;h2 id=&quot;2-predicados-binários&quot;&gt;#2 Predicados binários&lt;/h2&gt;
&lt;p&gt;Suponha&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$F(x,y)$: $x$ é o pai de $y$&lt;/li&gt;
  &lt;li&gt;$M(x,y)$: $x$ é a mãe de $y$&lt;/li&gt;
  &lt;li&gt;$H(x,y)$: $x$ é marido de $y$&lt;/li&gt;
  &lt;li&gt;$S(x,y)$: $x$ é irmã de $y$&lt;/li&gt;
  &lt;li&gt;$B(x,y)$: $x$ é irmão de $y$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;É permitido usar constantes para representar nomes: ‘Ed’, ‘Patsy’&lt;/p&gt;

&lt;p&gt;a. Todos têm uma mãe&lt;/p&gt;

&lt;p&gt;b. Todos têm um pai e uma mãe&lt;/p&gt;

&lt;p&gt;c. Todos que tem uma mãe tem um pai&lt;/p&gt;

&lt;p&gt;d. Ed é um avô&lt;/p&gt;

&lt;p&gt;e. Todos os pais são pais ou mães&lt;/p&gt;

&lt;p&gt;f. Todos os maridos são cônjuges&lt;/p&gt;

&lt;p&gt;g. Nenhum tio é tia&lt;/p&gt;

&lt;p&gt;h. Todos os irmãos são irmãos ou irmãs&lt;/p&gt;

&lt;p&gt;i. Nenhuma avó é pai de alguém&lt;/p&gt;

&lt;p&gt;j. Ed e Patsy são marido e mulher&lt;/p&gt;

&lt;p&gt;k. Carlos é cunhado de Monique.&lt;/p&gt;

&lt;h2 id=&quot;3-fórmulas-bem-formadas&quot;&gt;#3 Fórmulas bem formadas&lt;/h2&gt;

&lt;p&gt;Sejam $m$ uma constante, $f$ um símbolo funcional unário e $S$ e $B$ dois símbolos predicados binários. Quais das cadeias a seguir são fórmulas na lógica de predicados.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;S(m)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;B(m, f(m))&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;B(B(m,x),y)&lt;/script&gt;

&lt;h1 id=&quot;referências&quot;&gt;Referências&lt;/h1&gt;

&lt;p&gt;Seção 2.1: Pg. 71, &lt;a href=&quot;http://www.cse.chalmers.se/edu/course/DAT060/huthryan_lics2_sol.pdf&quot;&gt;Logica - Huth &amp;amp; Ryan (PDF).&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Capítulo 6: Pgs. 239, &lt;a href=&quot;https://racionalistasusp.files.wordpress.com/2010/01/nolt-john-rohatyn-dennis-lc3b3gica.pdf&quot;&gt;Logica - John Nolt (PDF).&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 28 Sep 2017 12:00:00 -0300</pubDate>
        <link>http://localhost:4000/lc21cp-172/lista7-logica-predicados.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/lista7-logica-predicados.html</guid>
        
        <category>predicados</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
      <item>
        <title>Lógica de predicados - Formalização</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#lógica-de-predicados-como-uma-linguagem-formal&quot; id=&quot;markdown-toc-lógica-de-predicados-como-uma-linguagem-formal&quot;&gt;Lógica de predicados como uma linguagem formal&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#termos&quot; id=&quot;markdown-toc-termos&quot;&gt;Termos&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo&quot; id=&quot;markdown-toc-exemplo&quot;&gt;Exemplo&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#fórmulas&quot; id=&quot;markdown-toc-fórmulas&quot;&gt;Fórmulas&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-1&quot; id=&quot;markdown-toc-exemplo-1&quot;&gt;Exemplo&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#prioridades&quot; id=&quot;markdown-toc-prioridades&quot;&gt;Prioridades&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;lógica-de-predicados-como-uma-linguagem-formal&quot;&gt;Lógica de predicados como uma linguagem formal&lt;/h1&gt;

&lt;p&gt;A nossa discussão até então, envolveu apenas a codificação de sentenças como fórmulas da lógica de predicados. Para isso, foi necessário compreender os uso de variáveis, quantificadores e predicados. Dissemos que essa discussão foi informal pois não foram descritas as regras gramaticais de formação das fórmulas válidas. Assunto desta seção.&lt;/p&gt;

&lt;p&gt;O primeiro passo para a formalização da linguagem da lógica de predicados é a identificação/classificação de seus componentes. Essa classificação nos mostra, inicialmente, que há dois tipos de coisas envolvidas em toda fórmula da lógica de predicados. As primeiras são:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Objetos aos quais estamos referenciando:
    &lt;ul&gt;
      &lt;li&gt;Variáveis $x$ e $y$.&lt;/li&gt;
      &lt;li&gt;Símbolos funcionais $m(x)$, $g(x,y)$, $a$, $p$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Toda expressão na lógica de predicados que se refere a um objeto é chamada um &lt;strong&gt;termo&lt;/strong&gt;. O segundo tipo de componentes na lógica de predicados denotam valores lógicos&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Valores lógicos, &lt;em&gt;fórmulas&lt;/em&gt;
    &lt;ul&gt;
      &lt;li&gt;$J(x, m(x))$ ($J$ é um predicado) é uma fórmula, embora $x$ e $m(x)$ sejam termos.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Um vocabulário predicado consiste em dois conjuntos:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Um conjunto de símbolos predicados $P$&lt;/li&gt;
  &lt;li&gt;Um conjunto de símbolos funcionais $F$ (incluindo constantes: funções $0$-árias)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;termos&quot;&gt;Termos&lt;/h2&gt;

&lt;p&gt;Os &lt;em&gt;termos&lt;/em&gt; da linguagem são feitos de variáveis, símbolos constantes e funções aplicadas a ambos. De modo geral, as regras de construção dos termos estão definidas a seguir:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Qualquer variável é um termo&lt;/li&gt;
  &lt;li&gt;Se $c\in F$ é uma função $0$-ária, então $c$ é um termo&lt;/li&gt;
  &lt;li&gt;Se $t_1,t_2,\dots,t_n$ são termos e $f\in F$ é $n$-ária, com $n&amp;gt; 0$, então $f(t_1,t_2,\dots,t_n)$ é um termo.&lt;/li&gt;
  &lt;li&gt;Nada mais é um termo.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;exemplo&quot;&gt;Exemplo&lt;/h3&gt;

&lt;p&gt;Suponha os símbolos funcionais $n, f$ e $g$, respectivamente $0$-ário, unário, binário. De acordo com as regra de construção de &lt;em&gt;termos&lt;/em&gt; bem formados, temos que :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$n$, $f(x)$, $g(x,f(y))$ são termos&lt;/li&gt;
  &lt;li&gt;$n(x)$, $f$, $g(x)$ não são termos.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ou seja, o número de parâmetros deve corresponder à definição da função.&lt;/p&gt;

&lt;h2 id=&quot;fórmulas&quot;&gt;Fórmulas&lt;/h2&gt;

&lt;p&gt;A escolha dos conjuntos $P$ e $F$ depende do que queremos expressar, portanto, dependem do contexto. Porém, ainda sim podemos definir as fórmulas bem formadas sobre esses conjuntos de forma indutiva.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Se $Q\in P$ é um predicado $n$-ário com $n\geq 1$ e se $t_1, t_2, \dots, t_n$ são termos sobre $F$, então $Q(t_1, t_2, \dots, t_n)$ é uma fórmula&lt;/li&gt;
  &lt;li&gt;Se $\phi$ é uma fórmula, então $(\neg\phi)$ também é&lt;/li&gt;
  &lt;li&gt;Se $\phi$ e $\psi$ são fórmulas, então $(\phi\land\psi)$, $(\phi\lor\psi)$ e $(\phi\to\psi)$ também são&lt;/li&gt;
  &lt;li&gt;Se $\phi$ é uma fórmula e $x$ é uma variável, então $(\forall x\phi)$ e $(\exists x\phi)$ são fórmulas&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Em resumo, podemos escrever:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\phi ::= Q(t_1, t_2, \dots, t_n) | (\neg\phi) | (\phi\land\phi) | (\phi\lor\phi) | (\phi\to\phi) | (\forall x \phi) | (\exists x\phi)&lt;/script&gt;

&lt;h3 id=&quot;exemplo-1&quot;&gt;Exemplo&lt;/h3&gt;

&lt;p&gt;Verifique se a fórmula a seguir é bem formada&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x ((P(x)\to Q(x)) \land S(x,y))&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists x( P(y,z) \land (\forall y (\neg Q(y,x) \lor P(y,z))))&lt;/script&gt;

&lt;h2 id=&quot;prioridades&quot;&gt;Prioridades&lt;/h2&gt;

&lt;p&gt;Na prática, muitas vezes preferimos ignorar alguns parenteses, em troca de melhor visibilidade. Nessas situações a prioridade dos quantificadores/operadores deve ser levada em consideração:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$\neg$, $\forall y$, $\exists y$ tem prioridade mais alta;&lt;/li&gt;
  &lt;li&gt;depois vem os símbolos $\lor$ e $\land$;&lt;/li&gt;
  &lt;li&gt;por fim, temos $\to$&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 28 Sep 2017 10:20:00 -0300</pubDate>
        <link>http://localhost:4000/lc21cp-172/logica-predicados-formal.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/logica-predicados-formal.html</guid>
        
        <category>predicados</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
      <item>
        <title>Lógica de predicados - Informal</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#a-necessidade-de-uma-linguagem-mais-rica&quot; id=&quot;markdown-toc-a-necessidade-de-uma-linguagem-mais-rica&quot;&gt;A necessidade de uma linguagem mais rica&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#predicados&quot; id=&quot;markdown-toc-predicados&quot;&gt;Predicados&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#variáveis&quot; id=&quot;markdown-toc-variáveis&quot;&gt;Variáveis&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#quantificadores&quot; id=&quot;markdown-toc-quantificadores&quot;&gt;Quantificadores&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo&quot; id=&quot;markdown-toc-exemplo&quot;&gt;Exemplo&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#símbolos-funcionais&quot; id=&quot;markdown-toc-símbolos-funcionais&quot;&gt;Símbolos funcionais&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-1&quot; id=&quot;markdown-toc-exemplo-1&quot;&gt;Exemplo&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-2&quot; id=&quot;markdown-toc-exemplo-2&quot;&gt;Exemplo&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#referências&quot; id=&quot;markdown-toc-referências&quot;&gt;Referências&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-necessidade-de-uma-linguagem-mais-rica&quot;&gt;A necessidade de uma linguagem mais rica&lt;/h1&gt;

&lt;p&gt;Até então desenvolvemos a lógica proposicional, examinando-a de três ângulos: sua teoria de demonstração (dedução natural), sua sintaxe (árvores das fórmulas) e sua semântica (tabelas-verdade). Toda essa discussão se inicou com &lt;em&gt;frases declarativas&lt;/em&gt;, ou &lt;em&gt;proposições&lt;/em&gt;, as quais sempre é possível atribuir um valor lógico. A linguagem da lógica proposicional, por outro lado, é limitada, e existem tipos de afirmações que nela não podem ser representadas satisfatoriamente.&lt;/p&gt;

&lt;p&gt;Vejamos, por exemplo, a frase declarativa:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“Todo estudante é mais jovem do que algum instrutor.”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;É fácil perceber que esta sentença não faz uso de nenhum dos conectivos da lógica proposicional: &lt;em&gt;não&lt;/em&gt;, &lt;em&gt;e&lt;/em&gt;, &lt;em&gt;ou&lt;/em&gt;, &lt;em&gt;se… então&lt;/em&gt;. Deste modo, o máximo que poderíamos fazer, seria representá-la como uma proposição atômica $p$&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$p$: “Todo estudante é mais jovem do que algum instrutor.”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Obviamente, isto não nos traria nenhuma informação sobre a estrutura da frase.&lt;/p&gt;

&lt;p&gt;No contexto dessas limitações, a &lt;em&gt;lógica de predicados&lt;/em&gt;, ou &lt;em&gt;lógica de segunda ordem&lt;/em&gt;, é proposta como forma de representar modificadores do tipo&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;existe&lt;/em&gt;,&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;todo&lt;/em&gt;,&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;entre&lt;/em&gt; e&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;apenas&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;predicados&quot;&gt;Predicados&lt;/h2&gt;

&lt;p&gt;Na frase acima, podemos identificar algumas propriedades&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;ser um estudante&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;ser um instrutor&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;ser mais jovem do que alguém&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Gostaríamos de algum mecanismo por meio do qual pudéssemos representá-las, juntamente com suas relações lógicas e dependências.&lt;/p&gt;

&lt;p&gt;Tomemos como exemplo &lt;em&gt;ser um estudante&lt;/em&gt;, podemos definir que essa propriedade como um &lt;em&gt;predicado&lt;/em&gt; $E(\cdot)$, o qual quando aplicado a algo nos diz que esse algo é um estudante.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$E($André$)$: nos diz que &lt;em&gt;André&lt;/em&gt; é um estudante.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Seguindo a mesma idéia, podemos definir predicados para as demais propriedades&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$I($Paulo$)$: &lt;em&gt;Paulo&lt;/em&gt; é um instrutor.&lt;/li&gt;
  &lt;li&gt;$J($André, Paulo$)$: &lt;em&gt;André&lt;/em&gt; é mais jovem do que &lt;em&gt;Paulo&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Nestes exemplos, $E,I,J$ são chamados &lt;strong&gt;predicados&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://michaelis.uol.com.br/moderno-portugues/busca/portugues-brasileiro/predicado/&quot;&gt;&lt;strong&gt;pre·di·ca·do&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Atributo de um ser; característica, propriedade, qualidade.&lt;/li&gt;
  &lt;li&gt;Qualidade considerada positiva ou desejável, como bondade, delicadeza, gentileza etc.; mérito, virtude: Encontrou uma pessoa com muitos predicados.&lt;/li&gt;
  &lt;li&gt;GRAM Tudo aquilo que se diz do sujeito da frase: Pedro vendeu o carro (vendeu o carro, o predicado, representa aquilo que se declara a respeito de Pedro, o sujeito).&lt;/li&gt;
  &lt;li&gt;LÓG Numa proposição ou num juízo, atributo de um sujeito, que pode ser afirmado ou negado. Símbolo P.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;variáveis&quot;&gt;Variáveis&lt;/h2&gt;

&lt;p&gt;Os predicados acima nos permitem definir propriedades, as quais podem ser utilizadas para identificar &lt;em&gt;estudantes&lt;/em&gt;, &lt;em&gt;instrutores&lt;/em&gt; e a relação de &lt;em&gt;juventude&lt;/em&gt; entre um estudante e um instrutor. No entanto, ainda não é viável representar todos estudantes&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“&lt;strong&gt;Todo estudante&lt;/strong&gt; é mais jovem do que algum instrutor.”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Sem que para isso tenhamos que defini-los um a um.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$E($André$)$, $E($Pedro$)$, $E($Maria$)$, $E($Joana$)$, etc..&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Claramente isto se torna inviável para qualquer número razoável de alunos, e portanto não é uma bom mecanismo para representar “&lt;strong&gt;Todo estudante…&lt;/strong&gt;”&lt;/p&gt;

&lt;p&gt;Para contornarmos esse problema, utilizaremos o conceito de &lt;em&gt;variável&lt;/em&gt;. Uma variável $u,v,w,x,y,z,\dots$ nada mais é que um substituto para  valores concretos. Utilizando $x,y$, poderíamos formalizar os predicados anteriores.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$E(x)$: $x$ é um estudante.&lt;/li&gt;
  &lt;li&gt;$I(x)$: $x$ é um instrutor.&lt;/li&gt;
  &lt;li&gt;$J(x,y)$: $x$ é mais jovem do que $y$.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;quantificadores&quot;&gt;Quantificadores&lt;/h2&gt;

&lt;p&gt;As váriaveis nos oferecem a formalização necessária, porém ainda não nos permite especificar que um &lt;em&gt;predicado&lt;/em&gt; se aplica a &lt;strong&gt;todo&lt;/strong&gt; ou &lt;strong&gt;algum&lt;/strong&gt;. Para isso, utilizamos os &lt;strong&gt;quantificadores&lt;/strong&gt;, os quais definem o escopo das variáveis.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$\forall$: “para todo”&lt;/li&gt;
  &lt;li&gt;$\exists$: “existe” ou “algum”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Os quantificadores em conjunto com variáveis nos permitem então definir afirmações sobre algo genérico&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$\forall y$: “para todo $y$&lt;/li&gt;
  &lt;li&gt;$\exists z$: “existe $z$” ou “existe algum $z$”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Portanto, se quero dizer que todo $x$ é estudante, utilizo o quantificador $\forall$ em conjunto com o predicado e a variável $x$.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x E(x)&lt;/script&gt;

&lt;p&gt;Retornando à frase original&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“Todo estudante é mais jovem do que algum instrutor.”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Podemos reescrevê-la, de forma a tornar mais óbvia as relações.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“Se $x$ é um estudante, então existe um instrutor $y$, tal que $x$ é mais jovem do que $y$.”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Devemos, no entanto, observar que a segunda frase se aplica a apenas um estudante $x$, como queremos generalizar a todos estudantes, utilizaremos o quantificador $\forall$&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(\dots)&lt;/script&gt;

&lt;p&gt;A parte interna dos parênteses é um condicional que se aplica a todo estudante, e portanto&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(E(x)\to \dots)&lt;/script&gt;

&lt;p&gt;O consequente deste condicional se refere ao trecho:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“existe um instrutor $y$, tal que $x$ é mais jovem do que $y$.”&lt;/li&gt;
  &lt;li&gt;“existe $y$, tal que $y$ é um instrutor e $x$ é mais jovem do que $y$.”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Que pode ser representado por:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists y (I(y) \land J(x,y))&lt;/script&gt;

&lt;p&gt;Por fim, a estrutura da frase exemplo pode ser escrita de maneira simbólica da seguinte forma&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(E(x)\to \exists y (I(y) \land J(x,y)))&lt;/script&gt;

&lt;p&gt;A qual pode ser lida da seguinte forma:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“Para todo $x$, se $x$ é um estudante, então existe algum $y$ que é um instrutor tal que $x$ é mais novo do que $y$”&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;exemplo&quot;&gt;Exemplo&lt;/h3&gt;

&lt;p&gt;Considere os seguintes predicados:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$A(x)$: $x$ é uma ave&lt;/li&gt;
  &lt;li&gt;$V(x)$: $x$ pode voar&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Represente simbolicamente a frase&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;“Nem todas as aves podem voar”
&lt;script type=&quot;math/tex&quot;&gt;\neg(\forall x (A(x)\to V(x)))&lt;/script&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;“Existem aves que não voam”
&lt;script type=&quot;math/tex&quot;&gt;\exists x(A(x)\land \neg V(x))&lt;/script&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;símbolos-funcionais&quot;&gt;Símbolos funcionais&lt;/h2&gt;

&lt;p&gt;A lógica de predicados estende a lógica proposicional não só quanto aos quantificadores, mas também com o conceito de &lt;em&gt;símbolo funcional&lt;/em&gt;. Um símbolo funcional nada mais é que uma função, a qual, dada uma variável, retorna alguma informação não ambígua sobre a variável em questão. Por exemplo, consideremos a sentenças&lt;/p&gt;

&lt;p&gt;“Toda criança é mais jovem do que sua mãe”.&lt;/p&gt;

&lt;p&gt;Ela pode ser representada simbolicamente utilizando os predicados:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$C(x)$: $x$ é uma criança&lt;/li&gt;
  &lt;li&gt;$M(x,y)$: $x$ é mãe de $y$&lt;/li&gt;
  &lt;li&gt;$J(x,y)$: $x$ é mais jovem que $y$&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \forall y(C(x) \land M(y,x) \to J(x,y))&lt;/script&gt;

&lt;p&gt;Não há nada errado com esta fórmula, no entanto ela poderia ser simplificada por meio do uso de um símbolo funcional que retornasse a mãe de $x$.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$m(x)$: retorna a mãe de $x$&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x (C(x) \to J(x, m(x)))&lt;/script&gt;

&lt;p&gt;Símbolos funcionais também podem ser binários, terciários e assim por diante:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$g(x,y)$: nota do aluno $x$ na disciplina $y$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;No caso especial em que nenhuma variável é necessária o simbolo funcional representa uma constante.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$m$: é uma constante para indicar Márcia&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;exemplo-1&quot;&gt;Exemplo&lt;/h3&gt;
&lt;p&gt;Utilizando o predicado $M(x,y)$: $x$ é mãe de $y$, considere a simbolização da frase:&lt;/p&gt;

&lt;p&gt;“André e Paulo têm a mesma avó materna”&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Reescreva de forma simbólica utilizando somente predicados.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Reescreva de forma simbólica utilizando predicados e símbolos funcionais.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;OBS: Utilize o símbolo de igualdade $=$ se necessário.&lt;/p&gt;

&lt;h3 id=&quot;exemplo-2&quot;&gt;Exemplo&lt;/h3&gt;

&lt;p&gt;Considere a simbolização da frase:&lt;/p&gt;

&lt;p&gt;“Todo filho de meu pai é meu irmão”&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Reescreva de forma simbólica utilizando somente predicados.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Reescreva de forma simbólica utilizando predicados e símbolos funcionais.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;referências&quot;&gt;Referências&lt;/h1&gt;

&lt;p&gt;Seção 2.1: Pg. 71, &lt;a href=&quot;http://www.cse.chalmers.se/edu/course/DAT060/huthryan_lics2_sol.pdf&quot;&gt;Logica - Huth &amp;amp; Ryan (PDF).&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 27 Sep 2017 10:20:00 -0300</pubDate>
        <link>http://localhost:4000/lc21cp-172/logica-predicados-informal.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/logica-predicados-informal.html</guid>
        
        <category>predicados</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
      <item>
        <title>Contêiners abstratos - list, forward_list, vector</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#pilhas-usando-um-container-abstrato&quot; id=&quot;markdown-toc-pilhas-usando-um-container-abstrato&quot;&gt;Pilhas usando um &lt;em&gt;container&lt;/em&gt; abstrato&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#implementação-da-interface-containerh&quot; id=&quot;markdown-toc-implementação-da-interface-containerh&quot;&gt;Implementação da interface &lt;em&gt;container.h&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pilhas-usando-um-container-abstrato&quot;&gt;Pilhas usando um &lt;em&gt;container&lt;/em&gt; abstrato&lt;/h2&gt;

&lt;p&gt;Em princípio, não há problemas em utilizar as funções de &lt;code class=&quot;highlighter-rouge&quot;&gt;vector&lt;/code&gt; para implementar as funcionalidades de &lt;code class=&quot;highlighter-rouge&quot;&gt;stack&lt;/code&gt;. Muito pelo contrário, reuso de funções é um dos objetivos da programação estruturada.&lt;/p&gt;

&lt;p&gt;No entanto, como mencionado anteriormente, pilhas podem ser implementadas sobre diferentes &lt;em&gt;contêiners&lt;/em&gt;. A nossa versão atual, porém, está totalmente acoplada ao &lt;em&gt;contêiner&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;vector&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/stack-vector.png&quot; alt=&quot;stack-vector&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Como podemos eliminar essa limitação e tornar nossa implementação mais geral ainda? De modo que outros contêiners sequenciais (&lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;, por exemplo) também pudessem ser facilmente utilizados quando necessário. A ideia é introduzir uma interface entre a implementação de um contêiner e sua definição.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/stack-container.png&quot; alt=&quot;stack-container&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Essa interface nada mais é do que um arquivo que define todas as funcionalidades que as implementações devem ter para serem um &lt;strong&gt;contêiner&lt;/strong&gt;. Tais arquivos, em geral, contém apenas cabeçalhos de funções e possivelmente definições de tipos de dados.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// **** container.h ****
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#define Type int
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_container&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Funções de remoção de elementos
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pop_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pop_front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;erase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Funções de inserção de elementos
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;push_front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Dada uma interface que define um contêiner genérico (abstrato), podemos redefinir nossa estrutura &lt;code class=&quot;highlighter-rouge&quot;&gt;stack&lt;/code&gt; para que ela utilize essas funções, ao invés daquelas específicas de &lt;code class=&quot;highlighter-rouge&quot;&gt;vector&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// **** stack.c ****
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include &quot;container.h&quot;
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// Redefinir o nome vector
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;container&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Alocação desalocação
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;new_stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;initial_capacity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;initial_capacity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;free_stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;free_container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Inserção e remoção de elementos
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pop_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Retorna um ponteiro para o topo da pilha
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;implementação-da-interface-containerh&quot;&gt;Implementação da interface &lt;em&gt;container.h&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;Até este momento a implementação de &lt;code class=&quot;highlighter-rouge&quot;&gt;stack&lt;/code&gt; não existe de forma concreta, pois ela depende da implementação de funções que não foram implementadas em &lt;code class=&quot;highlighter-rouge&quot;&gt;container.h&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Como já mencionado anteriormente, podem existir diferentes implementações da mesma interface. Qual delas será utilizada por &lt;code class=&quot;highlighter-rouge&quot;&gt;stack.c&lt;/code&gt; é uma decisão feita durante a compilação.&lt;/p&gt;

&lt;p&gt;Suponhamos a existência de duas implementações de &lt;code class=&quot;highlighter-rouge&quot;&gt;container.h&lt;/code&gt;, a primeira em &lt;code class=&quot;highlighter-rouge&quot;&gt;vector.c&lt;/code&gt; e a segunda em &lt;code class=&quot;highlighter-rouge&quot;&gt;list.c&lt;/code&gt;. Ao passarmos uma das duas ao compilador, elas fornecerão a implementação das funções abstratas utilizadas em &lt;code class=&quot;highlighter-rouge&quot;&gt;stack.c&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gcc main.c stack.c vector.c -o main-vector

gcc main.c stack.c list.c -o main-list
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 26 Sep 2017 13:50:00 -0300</pubDate>
        <link>http://localhost:4000/ae22cp-172/um-container-abstrato.html</link>
        <guid isPermaLink="true">http://localhost:4000/ae22cp-172/um-container-abstrato.html</guid>
        
        <category>programação-estruturada</category>
        
        
        <category>AE22CP-172</category>
        
      </item>
    
  </channel>
</rss>
