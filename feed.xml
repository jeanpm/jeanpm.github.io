<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jean P. Martins</title>
    <description>Combinatorial optimization, evolutionary optimization, estimation of distribution algorithms, linkage learning, learning and optimization.
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 22 Nov 2017 16:21:20 -0200</pubDate>
    <lastBuildDate>Wed, 22 Nov 2017 16:21:20 -0200</lastBuildDate>
    <generator>Jekyll v3.4.3</generator>
    
      <item>
        <title>FAQ</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#segmentation-fault&quot; id=&quot;markdown-toc-segmentation-fault&quot;&gt;Segmentation Fault&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo-1&quot; id=&quot;markdown-toc-exemplo-1&quot;&gt;Exemplo 1&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo-2&quot; id=&quot;markdown-toc-exemplo-2&quot;&gt;Exemplo 2&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#programação-estruturada&quot; id=&quot;markdown-toc-programação-estruturada&quot;&gt;Programação estruturada&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#função-list_sizel&quot; id=&quot;markdown-toc-função-list_sizel&quot;&gt;Função &lt;code class=&quot;highlighter-rouge&quot;&gt;list_size(l)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;segmentation-fault&quot;&gt;Segmentation Fault&lt;/h1&gt;

&lt;p&gt;Se seu código está dando falha de segmentação, rode ele dentro do gdb, em muitos casos nem é preciso procurar o erro passo a passo, pois o gdb mostra informações de onde a falha de segmentação ocorreu.&lt;/p&gt;

&lt;h2 id=&quot;exemplo-1&quot;&gt;Exemplo 1&lt;/h2&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;@:~$ &lt;/span&gt;./list &amp;lt; input/input02.txt 
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1] 35 
Falha de segmentação &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;imagem &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;núcleo gravada&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Esta saída não nos dá informação suficiente para a correção do erro. Portanto, utilizarei o gdb. Primeiro passo, compilar com a flag &lt;code class=&quot;highlighter-rouge&quot;&gt;-g&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;@:~$ &lt;/span&gt;gcc main.c list.c -o list -g
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Após isso, inicializar o gdb passando o executável como parâmetro&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;@:~$ &lt;/span&gt;gdb ./list
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;A seguir, utilizar o comando &lt;code class=&quot;highlighter-rouge&quot;&gt;run&lt;/code&gt; do gdb para iniciar a execução do programa.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; run ./list &amp;lt; input/input02.txt &amp;gt; out
Starting program: ./list &amp;lt; input/input02.txt &amp;gt; out
 
Program received signal SIGSEGV, Segmentation fault.
0x00000000004009fb &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;list_erase &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0x7fffffffdfd0, &lt;span class=&quot;nv&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; at list.c:101
101        n-&amp;gt;next&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;j-&amp;gt;next;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Desta saída, podemos focar apenas em algumas partes.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Program received signal SIGSEGV, Segmentation fault.
&lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;list_erase &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;v, &lt;span class=&quot;nv&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; at list.c:101
101        n-&amp;gt;next&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;j-&amp;gt;next;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;SIGSEGV, é uma constante representando o tipo de erro, neste caso &lt;em&gt;segmentation fault&lt;/em&gt;, que se refere à tentativa de acesso de memória não permitido: além dos limites de um vetor, ou em posições de memória que não foram alocadas pelo programador.&lt;/p&gt;

&lt;p&gt;Note, que &lt;code class=&quot;highlighter-rouge&quot;&gt;list_erase (v, i=1)&lt;/code&gt;, nos diz que o erro aconteceu na função &lt;code class=&quot;highlighter-rouge&quot;&gt;list_erase&lt;/code&gt;, quando recebendo a posição &lt;code class=&quot;highlighter-rouge&quot;&gt;i=1&lt;/code&gt; e nos mostra também a linha exata onde a falha de segmentação aconteceu.&lt;/p&gt;

&lt;h2 id=&quot;exemplo-2&quot;&gt;Exemplo 2&lt;/h2&gt;

&lt;p&gt;Seguiremos o mesmo procedimento descrito anteriormente.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;@:~$ &lt;/span&gt;./list &amp;lt; input/input03.txt 
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1] 68
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;2] 68 98
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;3] 16 68 98
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;2] 68 98
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1] 98
Falha de segmentação &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;imagem &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;núcleo gravada&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;@:~$ &lt;/span&gt;gdb ./list
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; run ./list &amp;lt; input/input03.txt 
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1] 68
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;2] 68 98
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;3] 16 68 98
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;2] 68 98
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1] 98
 
Program received signal SIGSEGV, Segmentation fault.
0x0000000000400acb &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;list_pop_back &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0x604020&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; at list.c:183
183 &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;ptr-&amp;gt;next-&amp;gt;next !&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; NULL&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Neste exemplo, a falha de segmentação ocorreu na linha 183, na função &lt;code class=&quot;highlighter-rouge&quot;&gt;list_pop_back&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;in list_pop_back (l=0x604020) at list.c:183
183 while(ptr-&amp;gt;next-&amp;gt;next != NULL)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Como sabemos, &lt;em&gt;segmentation fault&lt;/em&gt; indica acesso indevido de memória. Portanto podemos imaginar que algo errado com a operação&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;183 while(ptr-&amp;gt;next-&amp;gt;next != NULL)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;O que aconteceria se &lt;code class=&quot;highlighter-rouge&quot;&gt;ptr-&amp;gt;next&lt;/code&gt; for &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt;? Bom, neste caso, ao tentar acessar o próximo &lt;code class=&quot;highlighter-rouge&quot;&gt;-&amp;gt;next&lt;/code&gt;, estariamos acessando o endereço indicado por &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt;, e lá procurando o campo &lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt;, algo como: &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL-&amp;gt;next&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Como &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt; é usualmente definido como o endereço &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; da memória, qualquer acesso a esse endereço levará à falha de segmentação. Portanto, sempre que houver falha de segmentação, a primeira suspeita deve ser:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Acesso fora dos limites de um vetor&lt;/li&gt;
  &lt;li&gt;Acesso (dereferenciamento) ao endereço &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;programação-estruturada&quot;&gt;Programação estruturada&lt;/h1&gt;

&lt;h2 id=&quot;função-list_sizel&quot;&gt;Função &lt;code class=&quot;highlighter-rouge&quot;&gt;list_size(l)&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;“Se a estrutura de dados &lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt; duplamente encadeada já possui um campo &lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;, qual a necessidade da função &lt;code class=&quot;highlighter-rouge&quot;&gt;list_size()&lt;/code&gt;.”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Em algumas situações certas funções parecem desnecessárias, é o caso do &lt;code class=&quot;highlighter-rouge&quot;&gt;list_size()&lt;/code&gt;. Para entender o porque de sua utilidade, é bom pensarmos em termos da lista como estrutura abstrata, a qual tem uma interface &lt;code class=&quot;highlighter-rouge&quot;&gt;list.h&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Nesse sentido, ambas implementações, “lista simples”, “listas duplas”, teriam uma implementação de &lt;code class=&quot;highlighter-rouge&quot;&gt;list_size()&lt;/code&gt;. Nas listas simples, preciso percorrer toda lista para saber o tamanho, nas duplas, basta acessar o size já existente. Algo desse tipo&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// forward_list.c
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;list_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// list.c
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;list_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Agora suponha que estejamos utilizando uma estrutura lista para resolver algum problema, soma/multiplicação de inteiros grandes, splice, por exemplo.&lt;/p&gt;

&lt;p&gt;Neste caso, se sempre que precisarmos saber o tamanho de uma lista, utilizarmos &lt;code class=&quot;highlighter-rouge&quot;&gt;list_size()&lt;/code&gt; (e as demais funções de acesso a lista), isso nos permitiria utilizar tanto a implementação da lista de encadeamento simples (&lt;code class=&quot;highlighter-rouge&quot;&gt;forward_list.c&lt;/code&gt;) quanto a de encadeamento duplo (&lt;code class=&quot;highlighter-rouge&quot;&gt;list.c&lt;/code&gt;). Bastando escolher durante a compilação.&lt;/p&gt;

&lt;p&gt;Se pelo contrário, eu utilizasse &lt;code class=&quot;highlighter-rouge&quot;&gt;l-&amp;gt;size&lt;/code&gt; diretamente, eu não conseguiria utilizar a implementação &lt;code class=&quot;highlighter-rouge&quot;&gt;forward_list.c&lt;/code&gt;, visto que nela, esse campo não existe.&lt;/p&gt;

&lt;p&gt;Portanto, a ideia de termos várias funções para acessar certas propriedades da estrutura, nos permite separar a implementação da definição da estrutura de dados. Isso é sugerido quando programamos pensando em reutilização, e programação de bibliotecas.&lt;/p&gt;

&lt;p&gt;Obviamente, podemos também querer implementar uma lista para algo bem específico, sem pensar que tal código será reutilizado para várias coisas diferentes, e então, não precisaríamos nos preocupar com isso.&lt;/p&gt;

&lt;p&gt;Em geral é essa a ideia, e se aplica ao uso das demais funções também.&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Dec 2017 13:50:00 -0200</pubDate>
        <link>http://localhost:4000/ae22cp-172/FAQ.html</link>
        <guid isPermaLink="true">http://localhost:4000/ae22cp-172/FAQ.html</guid>
        
        <category>faq</category>
        
        
        <category>AE22CP-172</category>
        
      </item>
    
      <item>
        <title>APS4 - Matrizes esparsas</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#visão-geral&quot; id=&quot;markdown-toc-visão-geral&quot;&gt;Visão Geral&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#objetivo&quot; id=&quot;markdown-toc-objetivo&quot;&gt;Objetivo&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#critérios-de-avaliação&quot; id=&quot;markdown-toc-critérios-de-avaliação&quot;&gt;Critérios de avaliação&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#matrizes-esparsas&quot; id=&quot;markdown-toc-matrizes-esparsas&quot;&gt;Matrizes esparsas&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#tabelas-hash&quot; id=&quot;markdown-toc-tabelas-hash&quot;&gt;Tabelas Hash&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#chaves-únicas&quot; id=&quot;markdown-toc-chaves-únicas&quot;&gt;Chaves únicas&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#listas-de-adjacências&quot; id=&quot;markdown-toc-listas-de-adjacências&quot;&gt;Listas de Adjacências&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#matrizes-esparsas-encadeadas&quot; id=&quot;markdown-toc-matrizes-esparsas-encadeadas&quot;&gt;Matrizes esparsas encadeadas&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;visão-geral&quot;&gt;Visão Geral&lt;/h1&gt;
&lt;h3 id=&quot;objetivo&quot;&gt;Objetivo&lt;/h3&gt;

&lt;p&gt;Implementar o algoritmo de multiplicação de matrizes.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Utilizando tabelas hash como estruturas de dados para armazenar a matriz.&lt;/li&gt;
  &lt;li&gt;Utilizando matrizes esparsas encadeadas como estruturas de dados para armazenar a matriz.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;critérios-de-avaliação&quot;&gt;Critérios de avaliação&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Armazenamento da matriz esparsa em tabela hash.&lt;/li&gt;
  &lt;li&gt;Armazenamento da matriz esparsa em estrutura encadeada.&lt;/li&gt;
  &lt;li&gt;Multiplicação de matriz usando tabelas hash&lt;/li&gt;
  &lt;li&gt;Multiplicação de matriz usando estruturas encadeadas.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;matrizes-esparsas&quot;&gt;Matrizes esparsas&lt;/h1&gt;

&lt;p&gt;Uma matriz $N\times M$ é uma estrutura de dados simples e comumente utilizada em situações nas quais existe uma relação entre um elemento e $M$ outros elementos. Todos elementos numa mesma linha estão relacionados por alguma propriedade que os fez serem armazenados em tais posições, essa propriedade depende da informação sendo armazenada. Consideremos a estrutura ilustrada abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/AE22CP/grafo.png&quot; alt=&quot;grafo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Observamos pela numeração dos elementos que existem 13 nós. Percebemos também que além disso que alguns desses nós estão relacionados, ou seja, estão conectados por uma linha. Estruturas desse tipo são chamadas grafos, os elementos são chamados vértices e as conexões são chamadas arestas. Como representar uma estrutura desse tipo na memória do computador?&lt;/p&gt;

&lt;p&gt;A primeira opção para representarmos um grafo como estruturas de dados é a utilização de uma matriz $N\times N$, onde $N=13$ é o número de vértices. Para cada aresta entre vértices $v_i$ e $v_j$, representada como $(v_i, v_j)$ um valor será inserido na posição $i,j$ da matriz. Na matriz abaixo, marcamos como $X$ todas as arestas no grafo acima.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A primeira linha e primeira coluna servem apenas de referência, não existiriam na prática.&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
M = 
\left[{\begin{array}{lccccccccccccc}
 &amp; 0 &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 &amp; 9 &amp; 10 &amp; 11 &amp; 12 \\
0&amp; 0 &amp; X &amp; X &amp; 0 &amp; 0 &amp; X &amp; X &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
1&amp; X &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
2&amp; X &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
3&amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; X &amp; X &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
4&amp; 0 &amp; 0 &amp; 0 &amp; X &amp; 0 &amp; X &amp; X &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
5&amp; X &amp; 0 &amp; 0 &amp; X &amp; X &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
6&amp; X &amp; 0 &amp; 0 &amp; 0 &amp; X &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
7&amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; X &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
8&amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; X &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
9&amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; X &amp; X &amp; X \\
10&amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; X &amp; 0 &amp; 0 &amp; 0 \\
11&amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; X &amp; 0 &amp; 0 &amp; X \\
12&amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; X &amp; 0 &amp; X &amp; 0 
\end{array}}\right] %]]&gt;&lt;/script&gt;

&lt;p&gt;Usando este exemplo simples, é fácil percebermos que há um grande desperdício de memória ao utilizarmos essa estrutura de dados. Grande parte das conexões não existem no grafo que queremos representar, e portanto, a maioria das posições &lt;code class=&quot;highlighter-rouge&quot;&gt;M[i][j]&lt;/code&gt; na matriz permanecerão inutilizadas.&lt;/p&gt;

&lt;h2 id=&quot;tabelas-hash&quot;&gt;Tabelas Hash&lt;/h2&gt;

&lt;p&gt;Como forma de economia de memória, podemos armazenar a matriz $M$ de outras forma. A primeira que discutiremos utiliza uma tabela hash como estrutura de dados subjacente. Assuma que tenhamos uma tabela hash com tratamento de colisões qualquer. Podemos definir que a informação a ser armazenada será uma estrutura, como um elemento da matriz M (&lt;code class=&quot;highlighter-rouge&quot;&gt;Melem&lt;/code&gt;).&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;valor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Melem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Cada elemento desse tipo representa uma posição na matriz $M$, obviamente só armazenaríamos aqueles elementos representados por $X$, ou seja, aqueles que representem arestas no grafo original.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Neste exemplo, &lt;code class=&quot;highlighter-rouge&quot;&gt;valor&lt;/code&gt; é até desnecessário, mas em outras situações é comum querermos armazenar algo na posição da matriz.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Neste tipo de situação, a existência, na tabela hash, de um elemento&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Melem&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'X'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Significaria a existência de uma aresta entre os vértices $v_{10}$ e $v_{9}$, ou seja $(v_{10}, v_{9})$.&lt;/p&gt;

&lt;h3 id=&quot;chaves-únicas&quot;&gt;Chaves únicas&lt;/h3&gt;

&lt;p&gt;Em uma tabela hash, os elementos armazenados precisam necessariamente possuir uma chave única que o distingua dos demais elementos. No contexto dos elementos de matriz (&lt;code class=&quot;highlighter-rouge&quot;&gt;Melem&lt;/code&gt;) é possível utilizarmos os índices $i$ e $j$ para compor uma chave.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Defina uma função que transforme $i$ e $j$ em uma chave única. Essa chave será utilizada como entrada da função hash.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;listas-de-adjacências&quot;&gt;Listas de Adjacências&lt;/h2&gt;

&lt;p&gt;Uma abordagem alternativa que é uma intermediária entre uma matriz comum e uma estrutura encadeada, são as chamadas listas de adjacências. Numa lista de adjacências, cria-se um vetor de &lt;code class=&quot;highlighter-rouge&quot;&gt;L&lt;/code&gt; tamanho $N$, sendo que cada posição armazenará uma lista encadeada.&lt;/p&gt;

&lt;p&gt;Diferentemente das tabelas hash, no entanto, temos total controle quanto a em qual lista inserir um determinado elemento. Como temos $N$ listas, a escolha óbvia é inserir um determinado elemento de matriz &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;i,j,valor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt; na lista lista da posição &lt;code class=&quot;highlighter-rouge&quot;&gt;L[i]&lt;/code&gt;. A matriz $M$ descrita anteriormente seria então representada como&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
L = 
\left[{\begin{array}{ll}
0:&amp; \rightarrow 1 \rightarrow 2 \rightarrow 5 \rightarrow 6\\
1:&amp; \rightarrow 0 \\
2:&amp; \rightarrow 0 \\
3:&amp; \rightarrow 4 \rightarrow 5\\
4:&amp; \rightarrow 3 \rightarrow 5 \rightarrow 6\\
5:&amp; \rightarrow 0 \rightarrow 3 \rightarrow 4\\
6:&amp; \rightarrow 0 \rightarrow  4\\
7:&amp; \rightarrow 8 \\
8:&amp; \rightarrow 7\\
9:&amp; \rightarrow 10 \rightarrow 11 \rightarrow 12 \\
10:&amp; \rightarrow 9\\
11:&amp; \rightarrow 9 \rightarrow 12\\
12:&amp; \rightarrow 9 \rightarrow 11
\end{array}}\right] %]]&gt;&lt;/script&gt;

&lt;p&gt;Onde por conveniência e melhor visualização representei nas listas apenas o indice $j$ ao invés do elemento de matriz completo (&lt;code class=&quot;highlighter-rouge&quot;&gt;Melem&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Apesar da economia de memória que as listas de adjacências nos oferece, elas possuem um ponto fraco. As informações armazenadas nesse tipo de estrutura somente são facilmente acessadas percorrendo-se uma das linhas em $L$. Em diversas situações precisamos percorrer a matriz por coluna, uma operação que não é facilmente implementada em listas de adjacências.&lt;/p&gt;

&lt;h2 id=&quot;matrizes-esparsas-encadeadas&quot;&gt;Matrizes esparsas encadeadas&lt;/h2&gt;

&lt;p&gt;A implementação de matrizes esparsas por estruturas encadeadas é uma extensão da implementação em listas de adjacências. Neste caso, no entanto, se torna possível percorrer a matriz tanto em ordem definida por linha, quanto em ordem definida por coluna. Como isso é feito?&lt;/p&gt;

&lt;p&gt;As matrizes esparsas encadeadas que trataremos aqui, consideram dois vetores: vetor linha, e vetor coluna, ambos são vetores de listas. Porém, diferentemente das listas que temos tratados até então, essas precisam de informações adicionais.&lt;/p&gt;

&lt;p&gt;Considere que eu deseje percorrer uma linha $i$ da matriz esparsa encadeada. Dado um ponteiro para um nó $p$ da lista &lt;code class=&quot;highlighter-rouge&quot;&gt;L[i]&lt;/code&gt;, basta utilizarmos o campo &lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt; desse nó para acessarmos o próximo elemento na mesma linha.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\rightarrow \{1,10, x\}^p \rightarrow^\mbox{next} \{1, 20, y\}\rightarrow&lt;/script&gt;

&lt;p&gt;Por outro lado, se quisermos percorrer uma coluna $j$ da matriz esparsa encadeada, precisamos ter referência para os elementos abaixo e acima de um determinado elemento de matriz. Em resumo, cada nó dessas listas precisa armazenar pelo menos ponteiros para: &lt;code class=&quot;highlighter-rouge&quot;&gt;abaixo&lt;/code&gt; e &lt;code class=&quot;highlighter-rouge&quot;&gt;proximo&lt;/code&gt;, ou &lt;code class=&quot;highlighter-rouge&quot;&gt;abaixo&lt;/code&gt; e &lt;code class=&quot;highlighter-rouge&quot;&gt;anterior&lt;/code&gt;, ou &lt;code class=&quot;highlighter-rouge&quot;&gt;acima&lt;/code&gt; e &lt;code class=&quot;highlighter-rouge&quot;&gt;anterior&lt;/code&gt; etc; de modo que seja possível percorre a matriz tanto por linhas quanto por colunas. As figuras abaixo ilustram uma matriz esparsa encadeada com nós do tipo &lt;code class=&quot;highlighter-rouge&quot;&gt;acima&lt;/code&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;UP&lt;/code&gt;) e &lt;code class=&quot;highlighter-rouge&quot;&gt;anterior&lt;/code&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;LEFT&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/AE22CP/node.png&quot; alt=&quot;node&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/AE22CP/esparsa.png&quot; alt=&quot;mesparsa&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 22 Nov 2017 13:50:00 -0200</pubDate>
        <link>http://localhost:4000/ae22cp-172/APS4-matrizes.html</link>
        <guid isPermaLink="true">http://localhost:4000/ae22cp-172/APS4-matrizes.html</guid>
        
        <category>ordenação</category>
        
        
        <category>AE22CP-172</category>
        
      </item>
    
      <item>
        <title>PROLOG - Programando com relações</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#introdução&quot; id=&quot;markdown-toc-introdução&quot;&gt;Introdução&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#programando-com-relações&quot; id=&quot;markdown-toc-programando-com-relações&quot;&gt;Programando com relações&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#estruturas-recursivas&quot; id=&quot;markdown-toc-estruturas-recursivas&quot;&gt;Estruturas recursivas&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#listas&quot; id=&quot;markdown-toc-listas&quot;&gt;Listas&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#exercícios&quot; id=&quot;markdown-toc-exercícios&quot;&gt;Exercícios&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;introdução&quot;&gt;Introdução&lt;/h1&gt;

&lt;p&gt;Programação lógica funciona por meio da definição de relações entre informações. Nesta seção definiremos algumas técnicas para definir relações mais complexas a partir de outras mais simples.&lt;/p&gt;

&lt;h2 id=&quot;programando-com-relações&quot;&gt;Programando com relações&lt;/h2&gt;
&lt;p&gt;A forma mais simples de definir uma relação é fornecendo uma lista de fatos. Abaixo listamos alguns fatos sobre usuários de computador: mario, ana, joana; as ferramentas que eles utilizam: compilador, editor, diario, banco de dados, planilha; a arquitetura dos computadores que eles utilizam: sun, pc, mac, e os requisitos de memória de cada aplicação.&lt;/p&gt;

&lt;div class=&quot;language-prolog highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;ss&quot;&gt;usa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;mario&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;compilador&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;sun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;usa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;mario&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;compilador&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;pc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;usa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;mario&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;compilador&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;mac&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;usa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;mario&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;editor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;sun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;usa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;mario&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;editor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;pc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;usa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;mario&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;diario&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;pc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;usa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;ana&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;editor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;mac&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;usa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;ana&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;planilha&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;mac&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;usa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;joana&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;bancodados&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;pc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;usa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;joana&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;compilador&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;pc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;usa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;joana&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;editor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;pc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;

&lt;span class=&quot;ss&quot;&gt;requer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;compilador&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;128&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;requer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;editor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;512&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;requer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;planilha&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;640&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;requer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;bancodados&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;8192&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Da forma que foram definidos, esses fatos podem ser interpretatos como um banco de dados. Do mesmo modo que em um banco de dados é possível formularmos perguntas sobre as informações armazenadas: &lt;strong&gt;query&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Uma possível pergunta seria: “Quais aplicações &lt;code class=&quot;highlighter-rouge&quot;&gt;mario&lt;/code&gt; utiliza num computador &lt;code class=&quot;highlighter-rouge&quot;&gt;sun&lt;/code&gt;?”&lt;/p&gt;

&lt;div class=&quot;language-prolog highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;ss&quot;&gt;uses&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;mario&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;sun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Num banco de dados relacional, temos a possibilidade de formular questões por meio da combinação de informações que estão definidas em relações diferentes. Essa característica pode ser simulada em PROLOG.&lt;/p&gt;

&lt;p&gt;Escreva um trecho de código PROLOG para representar as seguintes questões:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“Quais são os requisitos de memória dos programas utilizados no Mac?”
    &lt;div class=&quot;language-prolog highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;ss&quot;&gt;usa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PESSOA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PROGRAMA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;mac&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;requer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PROGRAMA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;MEMORIA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;“Quais os requisitos de memória dos programas que precisam de mais que 256K?”
    &lt;div class=&quot;language-prolog highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;ss&quot;&gt;requer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PROGRAMA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;MEMORIA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;MEMORIA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;“Quais os requisitos de memória do editor?”
    &lt;div class=&quot;language-prolog highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;ss&quot;&gt;requer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PROGRAMA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;MEMORIA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PROGRAMA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;editor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;requer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;editor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;MEMORIA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;“Quais pessoas usam quais programas em quais máquinas e quanto de memória eles precisam?”
    &lt;div class=&quot;language-prolog highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;ss&quot;&gt;usa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PESSOA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PROGRAMA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;MAQUINA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;requer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PROGRAMA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;MEMORIA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;“Quais os requisitos de memória dos programas que a Ana usa no mac?”
    &lt;div class=&quot;language-prolog highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;ss&quot;&gt;usa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;ana&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;mac&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;requer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;Y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;“Quais programas são usados por pessoas diferentes na mesma máquina?”
    &lt;div class=&quot;language-prolog highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;ss&quot;&gt;usa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PESSOA1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;usa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PESSOA2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PESSOA1&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PESSOA2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;“Quais programas ambas, Ana e Joana, usam?”
    &lt;div class=&quot;language-prolog highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;ss&quot;&gt;usa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;ana&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;M1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;usa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;joana&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;M2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;“Quais programas ambas, Ana e Joana, usam na mesma máquina?”
    &lt;div class=&quot;language-prolog highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;ss&quot;&gt;usa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;ana&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;usa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;joana&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;“Quais programas são usados por Ana ou Joana?”
    &lt;div class=&quot;language-prolog highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;ss&quot;&gt;ana_ou_joana&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:-&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;usa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;ana&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;ana_ou_joana&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:-&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;usa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;joana&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;“Quais programas são usados por Ana mas não por Joana?”
    &lt;div class=&quot;language-prolog highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;ss&quot;&gt;usa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;ana&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;M1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;not&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;usa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;joana&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;M2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)).&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;estruturas-recursivas&quot;&gt;Estruturas recursivas&lt;/h2&gt;

&lt;p&gt;Em situações mais realistas os fatos e as relações utilizadas precisam representar  informações que posssuam estrutura interna mais ricas do que as vistas na seção anterior. Nesta seção veremos como construir regras capazes de modelar situações com mais que um número fixo de escolhas.&lt;/p&gt;

&lt;h3 id=&quot;listas&quot;&gt;Listas&lt;/h3&gt;

&lt;p&gt;Uma lista é uma sequência de elementos definida de acordo com a sintaxe&lt;/p&gt;

&lt;div class=&quot;language-prolog highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;23&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;A definição de regras que utilizam listas como parâmetros aumenta as possibilidades e complexidade das regras. Em geral, operações sobre listas são definidas recursivamente. Por exemplo, suponha que queiramos definir uma regra que diga se um determinado elemento X é ou não um membro da lista.&lt;/p&gt;

&lt;div class=&quot;language-prolog highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/*&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; Notação informal &lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;*/&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;membro&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;H&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;está&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;em&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;23&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;A notação &lt;code class=&quot;highlighter-rouge&quot;&gt;[H|T]&lt;/code&gt; indica uma lista qualquer, cujo inicio &lt;code class=&quot;highlighter-rouge&quot;&gt;head&lt;/code&gt; é &lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt; e o restante da lista é referenciado por &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;tail&lt;/code&gt;. Com esse tipo de notação só temos acesso a variáveis $H$ e $T$, não temos acesso a toda lista de uma vez. Exemplo, dada a lista &lt;code class=&quot;highlighter-rouge&quot;&gt;[1,23,5,6]&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;H=1&lt;/code&gt; e &lt;code class=&quot;highlighter-rouge&quot;&gt;T=[23,5,6]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A seguinte definição recursiva, percorre a lista procurando por uma situação em que $X$ seja o inicio da sublista. Nesta situação teremos que $X$ é membro da lista.&lt;/p&gt;
&lt;div class=&quot;language-prolog highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;ss&quot;&gt;membro&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]).&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;membro&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;H&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:-&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;membro&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;exercícios&quot;&gt;Exercícios&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Escreva um predicado para verificar se um elemento é um membro da lista, ou procurar todos membros da lista. Aplique esse predicado para procurar todos os membros da lista que sejam maior que um determinado inteiro.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-prolog highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;ss&quot;&gt;member&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;H&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;H&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]).&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;member&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:-&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;member&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Escreva um predicado para encontrar o último elemento de uma lista.
    &lt;div class=&quot;language-prolog highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;ss&quot;&gt;find_last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]).&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;find_last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:-&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;find_last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Verificar se duas listas são iguais.
    &lt;div class=&quot;language-prolog highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;ss&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([],[]).&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]).&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;H&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;H&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Escreva um predicado para verificar a existencia de dois elementos consecutivos em uma sequência.
    &lt;div class=&quot;language-prolog highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;ss&quot;&gt;consecutive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;Y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;Y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]).&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;consecutive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;Y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:-&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;consecutive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;Y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Escreva um predicado para apagar todos elementos de uma lista que sejam igual a um determinado valor.
    &lt;div class=&quot;language-prolog highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;ss&quot;&gt;erase_all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]).&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;erase_all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;H&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;H&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;erase_all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;erase_all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;H&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;H&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:-&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;erase_all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Utilize os predicados &lt;code class=&quot;highlighter-rouge&quot;&gt;reverse([H|T], X)&lt;/code&gt; para verificar se uma lista é, ou não, um palindromo.
    &lt;div class=&quot;language-prolog highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;ss&quot;&gt;palindrome&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:-&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Escreva um predicado que ternário &lt;code class=&quot;highlighter-rouge&quot;&gt;seq(I,F, Sequencia)&lt;/code&gt;, o qual crie a sequência com inteiros de &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt; a &lt;code class=&quot;highlighter-rouge&quot;&gt;F&lt;/code&gt;
    &lt;div class=&quot;language-prolog highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;ss&quot;&gt;seq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;seq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;Sequencia&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;I&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;seq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;Sequencia&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Máximo&lt;/li&gt;
  &lt;li&gt;Comprimento da lista&lt;/li&gt;
  &lt;li&gt;Soma da lista&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Referências&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;MICHAEL SPIVEY. An introduction to logic programming through Prolog. Prentice-Hall, Inc. Upper Saddle River, NJ, USA ©1996 
ISBN:0-13-536047-1. &lt;a href=&quot;https://pdfs.semanticscholar.org/6b7d/1f67f9b3c600e530e00f0e255229d93dd881.pdf&quot;&gt;PDF&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Thu, 16 Nov 2017 10:20:00 -0200</pubDate>
        <link>http://localhost:4000/lc21cp-172/prolog-relacoes.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/prolog-relacoes.html</guid>
        
        <category>prolog</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
      <item>
        <title>Tabelas hash</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#introdução&quot; id=&quot;markdown-toc-introdução&quot;&gt;Introdução&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#endereçamento-direto&quot; id=&quot;markdown-toc-endereçamento-direto&quot;&gt;Endereçamento direto&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tabelas-hash&quot; id=&quot;markdown-toc-tabelas-hash&quot;&gt;Tabelas Hash&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#resolução-de-colisões-por-encadeamento&quot; id=&quot;markdown-toc-resolução-de-colisões-por-encadeamento&quot;&gt;Resolução de colisões por encadeamento&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#inserção&quot; id=&quot;markdown-toc-inserção&quot;&gt;Inserção&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#procura&quot; id=&quot;markdown-toc-procura&quot;&gt;Procura&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#remover&quot; id=&quot;markdown-toc-remover&quot;&gt;Remover&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#exercícios&quot; id=&quot;markdown-toc-exercícios&quot;&gt;Exercícios&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#pair-sum-casos-de-teste&quot; id=&quot;markdown-toc-pair-sum-casos-de-teste&quot;&gt;Pair-sum [&lt;a href=&quot;/assets/AE22CP/pair-sum.zip&quot;&gt;casos de teste&lt;/a&gt;]&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;introdução&quot;&gt;Introdução&lt;/h1&gt;

&lt;p&gt;Muitas aplicações precisam manipular informações sem necessariamente se preocupar na ordem em que essas informações estão armazenadas na memória. A maioria das estruturas de dados “lineares” estudadas até então, no entanto, impõe uma ordem específica aos elementos. Em uma lista, por exemplo, a inserção de um novo elemento requer que especifiquemos a posição de inserção desse elemento, o mesmo ocorre para vetores. O uso de fila de prioridades (implementadas sobre uma estrutura Heap) foi a primeira excessão a esta regra que investigamos, onde estavamos interessados sempre no mínimo elemento armazenado, mas sem nos importar necessariamente em que posição da estrutura esse elemento estava armazenado.&lt;/p&gt;

&lt;p&gt;Nesta seção uma nova estrutura de dados será introduzida, a qual nos permitirá efetuar operações como:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Inserção,&lt;/li&gt;
  &lt;li&gt;Remoção, e&lt;/li&gt;
  &lt;li&gt;Procura&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;de forma eficiente e sem nos preocuparmos com o posicionamento em memória dos elementos armazenados. Diferentemente das filas de prioridade, no entanto, tabelas hash permitem remoção de quaisquer elementos armazenados, não somento o mínimo/máximo. A única exigência sendo que cada um dos elementos armazenados tenha uma &lt;em&gt;chave&lt;/em&gt; única que o identifique.&lt;/p&gt;

&lt;p&gt;Exemplos:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Um aluno tem como chave única que o identifica, seu RA.&lt;/li&gt;
  &lt;li&gt;Uma pessoa tem como chave única que a identifica, seu CPF.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;endereçamento-direto&quot;&gt;Endereçamento direto&lt;/h1&gt;

&lt;p&gt;Tabelas hash são uma generalização de uma forma de armazenamento com mais limitações, chamada endereçamento aberto.&lt;/p&gt;

&lt;p&gt;Suponha que desejemos armazenar as informações sobre os funcionários de uma pequena empresa. Cada funcionário tem o seu identificador, um número que indica seu cadastro na empresa. Por se tratar de uma empresa pequena, o número de funcionários $n$ não é grande, $n\leq m$ por exemplo. É natural assumirmos que esses identificadores sejam atribuídos de forma crescente a cada novo funcionário contratado.&lt;/p&gt;

&lt;p&gt;Neste pequeno exemplo, assumimos que tais identificadores são as &lt;em&gt;chaves&lt;/em&gt; únicas de cada funcionário. Como o número $n$ de funcionários nunca ultrapassa $m$, um conjunto universo de chaves possíveis contendo números&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;U=\{0,1,\dots,m-1\}&lt;/script&gt;

&lt;p&gt;é suficiente para identificar todos eles. Ou seja, cada funcionário tem um número identificador $u\in U$. Como armazenar as informações sobre tais funcionários na memória de modo a ser possível inserir, remover, e procurar de forma eficiente?&lt;/p&gt;

&lt;p&gt;Sendo o número total de chaves $m$ de tamanho moderado, poderíamos simplesmente criar um vetor de $m$ posições.&lt;/p&gt;

&lt;p&gt;Dada uma chave, procurar pelo funcionário associado é então trivial. Tão triviais quanto serão as operações de inserção e removação de um funcionário.&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chave&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chave&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chave&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chave&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Info&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chave&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Neste contexto tão específico, em que sabemos que a maior chave possível $m$ é um número razoavelmente pequeno, esta é a implementação mais rápida possível. Porém, não é difícil percebermos suas limitações:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;E se as chaves $m$ forem números de 9 dígitos?
    &lt;ul&gt;
      &lt;li&gt;A tabela seria gigantesca, e se o número de itens armazenados for pequeno, um grande desperdício de memória ocorreria.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;E se as chaves não forem inteiros?
    &lt;ul&gt;
      &lt;li&gt;Não há como indexar a tabela com chaves não-inteiras.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;tabelas-hash&quot;&gt;Tabelas Hash&lt;/h1&gt;

&lt;p&gt;Nas situações em que endereçamento direto não se aplica, devido ao grande número de chaves possíveis, as Tabelas hash são opções interessantes.&lt;/p&gt;

&lt;p&gt;A ideia geral de uma tabela hash é diminuir o número de chaves que precisam ser tratadas, saindo de $|U|$ para um número $m \ll |U|$ (“muito menor que”). Para isso precisamos de uma função&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;h: U \to \{0,\dots,m-1\}&lt;/script&gt;

&lt;p&gt;que mapeie cada possível chave $k\in U$ para um número $h(k)$, onde $h$ é chamada &lt;strong&gt;função hash&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Neste contexto, se utilizarmos $h(k)$ como índice na tabela, precisaríamos de uma tabela de tamanho $m$ ao invés de $|U|$. Como, por definição $m\ll|U|$, uma grande economia de espaço é possível. O exemplo mais simples de função hash é o uso do operador de &lt;em&gt;resto&lt;/em&gt; (mod, &lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt;), o qual quando aplicado com o parâmetro $m$ produz um valor em ${0,\dots,m-1}$ (ver Figura).&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;h(k) = k \mod m.&lt;/script&gt;

&lt;p&gt;&lt;img src=&quot;/assets/AE22CP/hash.png&quot; alt=&quot;hash&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Mas antes de finalizarmos uma implementação de tabelas hash, precisamos lidar com um importante problema. A função hash mapeia cada valor em $U$ para um valor entre $0$ e $m$, porém, como $m\ll |U|$, é inevitável que alguns valores $k_1,k_2 \in U$ tenham o mesmo valor de hash, ou seja, $h(k_1) = h(k_2)$. Isto é chamado &lt;em&gt;colisão&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A menos que não nos importemos em sobrescrever elementos com memso hash, a existência de colisões nos impede uma implementação simples, em que inserimos os elementos na posição dada pela função de hash.&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Implementação inviável
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Info&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chave&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Pois esse tipo de implementação somente aceitaria um dos elementos que tenham o mesmo valor de hash. Por exemplo, se houvéssemos inserido $k_1$ e posteriormente tentado inserir $k_2$, o valor $k_1$ que estava armazenado em &lt;code class=&quot;highlighter-rouge&quot;&gt;t[h(k1)]&lt;/code&gt; seria sobrescrito, visto que $h(k_1)=h(k_2)$.&lt;/p&gt;

&lt;p&gt;A seguir, analisaremos formas de tratar colisões, de modo que a tabela hash permita o armazenamento simultâneo de diversos itens com mesmo valor de hash.&lt;/p&gt;

&lt;h2 id=&quot;resolução-de-colisões-por-encadeamento&quot;&gt;Resolução de colisões por encadeamento&lt;/h2&gt;

&lt;p&gt;A resolução, ou tratamento, de colisões mais intuitiva consiste em simplesmente armazenar todos elementos cujos hash tenham colidido em uma lista encadeada.  A figura abaixo ilustra essa situação&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/AE22CP/chain.png&quot; alt=&quot;hash&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Esta forma de tratarmos colisões define como as funcionalidades devem ser implementadas: inserção, remoção, procura.&lt;/p&gt;

&lt;h3 id=&quot;inserção&quot;&gt;Inserção&lt;/h3&gt;

&lt;p&gt;Nesta situação, a tabela hash é simplesmente um vetor $T$, com uma lista em cada uma de suas $m$ posições (um vetor de listas: &lt;code class=&quot;highlighter-rouge&quot;&gt;list** T&lt;/code&gt;). Cada uma das listas $T[i]$ armazenará elementos $x$ cujo hash seja igual ao índice $i$, i.e. $h(x)=i$. Deste modo, se o elemento $x$ ainda não existe na lista $T[i]$, basta inserí-lo.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Info&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chave&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contains&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;procura&quot;&gt;Procura&lt;/h3&gt;

&lt;p&gt;De forma análoga à inserção, podemos com certeza afirmar que se um elemento $x$, com hash $h(x)$, não é encontrado na lista $T[h(x)]$, então ele não existe na tabela hash. A função &lt;code class=&quot;highlighter-rouge&quot;&gt;search&lt;/code&gt;, deste modo, é implementada em duas etapas apenas:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;calcular o hash da chave $k$ sendo procurada,&lt;/li&gt;
  &lt;li&gt;percorrer a lista $T[h(k)]$ procurando por um item cuja chave seja igual a $k$.
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contains&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;an&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;null&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;remover&quot;&gt;Remover&lt;/h3&gt;

&lt;p&gt;A funcionalidade remover procede a partir de uma chave $k$. Similarmente a &lt;code class=&quot;highlighter-rouge&quot;&gt;search&lt;/code&gt;, a primeira etapa consiste em calcular o hash da chave $k$, $h(k)$. A partir de $h(k)$, sabemos em qual das listas procurar, $T[h(k)]$. A remoção precisa então percorrer a lista $T[h(k)]$ procurando por um elemento cuja chave seja igual $k$. Caso esse elemento exista, basta removê-lo da lista, caso ele não exista, não há nada a ser feito.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;exercícios&quot;&gt;Exercícios&lt;/h1&gt;

&lt;h2 id=&quot;pair-sum-casos-de-teste&quot;&gt;Pair-sum [&lt;a href=&quot;/assets/AE22CP/pair-sum.zip&quot;&gt;casos de teste&lt;/a&gt;]&lt;/h2&gt;
&lt;p&gt;Dada uma constante $K&amp;gt;0$ e sequência de inteiros não negativos&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;a_1, a_2,\dots, a_n.&lt;/script&gt;

&lt;p&gt;Verifique se existe um par $a_i$ e $a_j$, tal que $a_i + a_j = K$.&lt;/p&gt;

&lt;p&gt;a) Implemente uma solução que utilize apenas comparações&lt;/p&gt;

&lt;p&gt;b) Implemente uma solução com tratamento de colisões por encadeamento&lt;/p&gt;

&lt;p&gt;c) Implemente uma solução com tratamento de colisões por endereçamento aberto.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Referências&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;CORMEN, Thomas H. et al. Algoritmos: teoria e prática. Rio de Janeiro, RJ: Campus, 2002. xvii, 916 p. ISBN 8535209263. &lt;a href=&quot;http://www.inf.ufrgs.br/~tsrodrigues/utilidades/cormem.pdf&quot;&gt;(pdf: Algoritmos - cap. 11)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;iframe width=&quot;360&quot; height=&quot;205&quot; src=&quot;https://www.youtube.com/embed/0M_kIqhwbFo&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;
&lt;/iframe&gt;

&lt;iframe width=&quot;360&quot; height=&quot;205&quot; src=&quot;https://www.youtube.com/embed/BRO7mVIFt08&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;
&lt;/iframe&gt;

</description>
        <pubDate>Tue, 07 Nov 2017 13:50:00 -0200</pubDate>
        <link>http://localhost:4000/ae22cp-172/tabelas-hash.html</link>
        <guid isPermaLink="true">http://localhost:4000/ae22cp-172/tabelas-hash.html</guid>
        
        <category>tabelas-hash</category>
        
        
        <category>AE22CP-172</category>
        
      </item>
    
      <item>
        <title>Algoritmos ótimos para Ordenação por comparação</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#introdução&quot; id=&quot;markdown-toc-introdução&quot;&gt;Introdução&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ordenação-por-comparações&quot; id=&quot;markdown-toc-ordenação-por-comparações&quot;&gt;Ordenação por comparações&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#Árvore-de-decisão&quot; id=&quot;markdown-toc-Árvore-de-decisão&quot;&gt;Árvore de decisão&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#altura-da-árvore-de-decisão&quot; id=&quot;markdown-toc-altura-da-árvore-de-decisão&quot;&gt;Altura da árvore de decisão&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#limitante-inferior&quot; id=&quot;markdown-toc-limitante-inferior&quot;&gt;Limitante Inferior&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#qual-seria-o-limitante-inferior-para-a-busca-binária&quot; id=&quot;markdown-toc-qual-seria-o-limitante-inferior-para-a-busca-binária&quot;&gt;Qual seria o limitante inferior para a busca binária?&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;introdução&quot;&gt;Introdução&lt;/h1&gt;

&lt;p&gt;Até então discutimos vários algoritmo de ordenação como alternativas para solucionar o mesmo problema. Dada uma sequência numérica $x_1,\dots,x_n$, reordenar a sequência de modo a produzir uma nova que respeite uma relação de ordem:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x_i \leq x_{i+1}, \qquad i=1,\dots,n-1&lt;/script&gt;

&lt;p&gt;A comparação de eficiência entre os algoritmos discutidos tem sido feita considerando principalmente o pior caso de cada um, ou seja, sequências de entrada que levam esses algoritmos a terem seu pior desempenho, seja em tempo de execução ou número de comparações. Tal comparação teórica também pode ser feita em ao menos dois casos adicionais:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;melhor caso, e&lt;/li&gt;
  &lt;li&gt;caso médio.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;De forma genérica, o melhor caso de qualquer algoritmo representa tipos de entradas para as quais ele tem o seu melhor desempenho (menor número de comparações). Nos algoritmos de ordenação, isso geralmente ocorre quando a sequência já está ordenada da forma correta (ver tabela: buble sort e insertion sort).&lt;/p&gt;

&lt;p&gt;O caso médio, por outro lado, representa o comportamento médio do algoritmo em todas as entradas possíveis. O desempenho médio desses algoritmos pode ser avaliado de forma aproximada por meio de experimentos. A tabela abaixo nos indica a complexidade de cada um dos algoritmos vistos até então nesses três casos.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Algoritmo&lt;/th&gt;
      &lt;th&gt;Melhor caso&lt;/th&gt;
      &lt;th&gt;Caso médio&lt;/th&gt;
      &lt;th&gt;Pior caso&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Bubble sort&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
      &lt;td&gt;$O(n^2)$&lt;/td&gt;
      &lt;td&gt;$O(n^2)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Selection sort&lt;/td&gt;
      &lt;td&gt;$O(n^2)$&lt;/td&gt;
      &lt;td&gt;$O(n^2)$&lt;/td&gt;
      &lt;td&gt;$O(n^2)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Insertion sort&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
      &lt;td&gt;$O(n^2)$&lt;/td&gt;
      &lt;td&gt;$O(n^2)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Quicksort&lt;/td&gt;
      &lt;td&gt;$O(n \log n)$&lt;/td&gt;
      &lt;td&gt;$O(n \log n)$&lt;/td&gt;
      &lt;td&gt;$O(n^2)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Mergesort&lt;/td&gt;
      &lt;td&gt;$O(n \log n)$&lt;/td&gt;
      &lt;td&gt;$O(n \log n)$&lt;/td&gt;
      &lt;td&gt;$O(n \log n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Heapsort&lt;/td&gt;
      &lt;td&gt;$O(n \log n)$&lt;/td&gt;
      &lt;td&gt;$O(n \log n)$&lt;/td&gt;
      &lt;td&gt;$O(n \log n)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Tais resultados teóricos nos dão um bom indicativo da eficiência relativa de cada um desses algoritmos. No entanto, caso dois algoritmos tenham a mesma complexidade teórica (ex.: quicksort, mergesort e heapsort) eles não são suficientes para dizermos qual algoritmo será mais “rápido” do ponto de vista prático. Isso ocorre pois na prática existem outras características que influenciarão o desempenho do algoritmo, como exemplo, podemos citar: forma de acesso à memória, menor número de trocas, qualidade da implementação, etc.&lt;/p&gt;

&lt;p&gt;Algoritmos como o &lt;code class=&quot;highlighter-rouge&quot;&gt;quicksort&lt;/code&gt; são muito úteis na prática. Porém, como eficiência nunca é demais, podemos nos perguntar: – &lt;strong&gt;“Não existiria algoritmo mais rápido?”&lt;/strong&gt; –. O objetivo desta seção é oferecer uma resposta a essa pergunta.&lt;/p&gt;

&lt;h1 id=&quot;ordenação-por-comparações&quot;&gt;Ordenação por comparações&lt;/h1&gt;

&lt;h2 id=&quot;Árvore-de-decisão&quot;&gt;Árvore de decisão&lt;/h2&gt;
&lt;p&gt;Ao examinarmos a implementação dos algoritmos acima podemos notar algo em comum. Todos eles utilizam comparações entre pares de elementos $x_i, x_j$ para determinar a ordem relativa entre esses elementos. Obviamente, cada uma dessas comparações pode oferecer como resposta, apenas uma dentre duas possibilidades que existem como resposta:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$x_i \leq x_j$, ou&lt;/li&gt;
  &lt;li&gt;$x_j \leq x_i$.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A ordem que os elementos serão comparados, ou a quantidade de vezes que um mesmo par de elementos será comparado depende de um algoritmo específico e portanto deve ser ignorado nessa análise.&lt;/p&gt;

&lt;p&gt;O ponto mais importante seria notar que a cada comparação $x_i \leq x_j$, um determinado algoritmo ganha informação sobre a ordem relativa desses dois elementos. Se representarmos todas as possíveis sequências de comparações, temos uma estrutura chamada &lt;strong&gt;árvore binária de decisão&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/AE22CP/decision-tree.png&quot; alt=&quot;decision-tree&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Esse tipo de árvore representa as decisões tomadas por um algoritmo qualquer, em que cada nó inicia com a informação adicional obtida da comparação feita acima dele. Por exemplo, o nó &lt;code class=&quot;highlighter-rouge&quot;&gt;2:3&lt;/code&gt; (o qual representa a comparação entre $x_2$ e $x_3$) já assume que $x_1\leq x_2$.&lt;/p&gt;

&lt;h2 id=&quot;altura-da-árvore-de-decisão&quot;&gt;Altura da árvore de decisão&lt;/h2&gt;

&lt;p&gt;Os nós folhas da árvore indicam qual permutação da sequência original tornaria essa sequência ordenada de forma não decrescente. Por exemplo, &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;3,1,2&amp;gt;&lt;/code&gt;, no diz que a sequência ordenada é $x_3,x_1,x_2$.&lt;/p&gt;

&lt;p&gt;É de se esperar que um algoritmo correto permita uma resposta correta para toda possível entrada. Se os nós folhas da árvore nos dão a permutação da entrada que produz a resposta correta, então devem existir ao menos $n!$ permutações como nós folhas, uma para cada possível entrada. Sabendo disso,&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Qual seria o limitante inferior para a complexidade de qualquer algoritmo de ordenação por comparação?&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A ordenação de uma sequência é o procedimento descrito como um caminho que inicia na raíz da árvore de decisão e chega até uma de suas folhas, portanto o número total de comparações é equivalente a altura da árvore.&lt;/p&gt;

&lt;h2 id=&quot;limitante-inferior&quot;&gt;Limitante Inferior&lt;/h2&gt;

&lt;p&gt;Um limitante inferior (&lt;em&gt;lower-bound&lt;/em&gt;), como o próprio nome diz, limita por baixo a complexidade de algo. No nosso caso, esse algo é o &lt;em&gt;problema de ordenação de uma sequência&lt;/em&gt;. Como temos discutido complexidade da ordenação em termos do número de comparações, esse limitante inferior nos dará uma estimativa do menor número comparações possível, que um algoritmo teria que fazer para conseguir ordenar uma sequência qualquer. Este limitante inferior é equivalente a altura da árvore de decisão.&lt;/p&gt;

&lt;p&gt;Uma árvore binária qualquer tem, em seu $\ell$-ésimo nível, $2^\ell$ nós. Sabemos que o último nível dessa árvore deve ter no mínimo $n!$ nós, portanto, no último nível&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;n! \leq 2^\ell&lt;/script&gt;

&lt;p&gt;Aplicando o logaritmo em ambos os lados&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\log(n!) \leq \ell&lt;/script&gt;

&lt;p&gt;Não nos preocuparemos com os detalhes da demonstração, mas a partir dessa desigualdade é possível chegar ao resultado.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ell \geq n \log n&lt;/script&gt;

&lt;p&gt;O qual significa que qualquer algoritmo de ordenação baseado em comparações terá que fazer no mínimo $n \log n$ comparações.&lt;/p&gt;

&lt;h2 id=&quot;qual-seria-o-limitante-inferior-para-a-busca-binária&quot;&gt;Qual seria o limitante inferior para a busca binária?&lt;/h2&gt;

&lt;p&gt;Siga a mesma ideia descrita acima para obter um limitante inferior para busca binária.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Referências&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;CORMEN, Thomas H. Desmistificando algoritmos. 1. ed. Rio de Janeiro, RJ: Elsevier, c2014. xii, 188 p. ISBN 9788535271775.&lt;a href=&quot;https://book-store.github.io/cse/thirdyear/%5BThomas_H._Cormen%5D_Algorithms_unlocked(BookZZ.org).pdf&quot;&gt;(pdf:Algorithms Unlocked)&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CORMEN, Thomas H. et al. Algoritmos: teoria e prática. Rio de Janeiro, RJ: Campus, 2002. xvii, 916 p. ISBN 8535209263. &lt;a href=&quot;http://www.inf.ufrgs.br/~tsrodrigues/utilidades/cormem.pdf&quot;&gt;(pdf: Algoritmos)&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MIT - https://www.youtube.com/watch?v=Nz1KZXbghj8&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
&lt;iframe width=&quot;360&quot; height=&quot;205&quot; src=&quot;https://www.youtube.com/embed/Nz1KZXbghj8&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;
&lt;/iframe&gt;

&lt;iframe width=&quot;360&quot; height=&quot;205&quot; src=&quot;https://www.youtube.com/embed/tVjVaO3KD0w&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;
&lt;/iframe&gt;

</description>
        <pubDate>Mon, 06 Nov 2017 13:50:00 -0200</pubDate>
        <link>http://localhost:4000/ae22cp-172/limite-inferior-ordenacao.html</link>
        <guid isPermaLink="true">http://localhost:4000/ae22cp-172/limite-inferior-ordenacao.html</guid>
        
        <category>ordenação</category>
        
        
        <category>AE22CP-172</category>
        
      </item>
    
      <item>
        <title>Lógica de predicados - Árvores de refutação</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#introdução&quot; id=&quot;markdown-toc-introdução&quot;&gt;Introdução&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#Árvores-de-refutação&quot; id=&quot;markdown-toc-Árvores-de-refutação&quot;&gt;Árvores de refutação&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#generalização-das-Árvores-de-refutação&quot; id=&quot;markdown-toc-generalização-das-Árvores-de-refutação&quot;&gt;Generalização das Árvores de Refutação&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#quantificador-universal-forall&quot; id=&quot;markdown-toc-quantificador-universal-forall&quot;&gt;Quantificador universal ($\forall$)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#quantificador-existencial-negado-neg-exists&quot; id=&quot;markdown-toc-quantificador-existencial-negado-neg-exists&quot;&gt;Quantificador existencial negado ($\neg \exists$)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#quantificador-existencial-exists&quot; id=&quot;markdown-toc-quantificador-existencial-exists&quot;&gt;Quantificador existencial ($\exists$)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#quantificador-universal-negado-neg-forall&quot; id=&quot;markdown-toc-quantificador-universal-negado-neg-forall&quot;&gt;Quantificador universal negado ($\neg \forall$)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;introdução&quot;&gt;Introdução&lt;/h1&gt;

&lt;p&gt;Estudamos na lógica proposicional dois algoritmos principais para demonstrarmos a validade e invalidade de formas de argumentos: tabelas verdade, árvores de refutação. Deste modo, dada qualquer forma de argumento com premissas e uma conclusão&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\phi,\psi \vdash \chi&lt;/script&gt;

&lt;p&gt;é possível na lógica proposicional determinarmos se tal forma de argumento é válida ou não é valida.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Uma forma de argumento é válida&lt;/strong&gt;, se sempre que suas premissas forem verdadeiras ($\phi,\psi$) sua conclusão seja verdadeira ($\chi$)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Apesar de ineficientes em certas situações, tanto tabelas verdade quanto árvores de refutação podem, em princípio, ser utilizados para implementarmos um programa que verifique a validade de formas de argumento. Esse programa hipotético, pode tomar um tempo consideravelmente grande para chegar a uma decisão, mas ele eventualmente chegará a essa decisão, portanto diz-se que:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;A lógica proposicional é decidível&lt;/strong&gt;. Pois existem algoritmos que decidem se &lt;em&gt;qualquer&lt;/em&gt; forma de argumento é válida ou não.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Na lógica de predicados, a situação é diferente. Apesar de existirem procedimentos que nos permitem verificar a validade e invalidade de alguns tipos de formas de argumentos, não existe, e não pode existir, um procedimento que verifique &lt;em&gt;qualquer&lt;/em&gt; forma de argumento da lógica de predicados. Portanto, diz-se que:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;A lógica de predicados é indecidível&lt;/strong&gt;. Pois não existe algoritmo que decida a validade de &lt;em&gt;qualquer&lt;/em&gt; forma de argumento.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;Árvores-de-refutação&quot;&gt;Árvores de refutação&lt;/h1&gt;

&lt;p&gt;As árvores de refutação para a lógica de predicados são generalizadas pela introdução de seis novas regras, as quais tratarão fórmulas precedidas pelos quantificadores universal ou existencial. No entanto, existirão situações em que apenas as regras utilizadas na lógica proposicional serão úteis. Vejamos um exemplo:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x Fx \to \forall x Gx, \neg \forall x Gx \vdash \neg \forall x Fx&lt;/script&gt;

&lt;p&gt;Na primeira etapa da demonstração, apenas listamos as premissas e a negação da conclusão. Neste momento a árvore possui apenas um ramo contendo todas essas três fórmulas.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{lclr}
&amp; 1 &amp; \forall x Fx \to \forall x Gx &amp; \mbox{(premissa)} \\
&amp; 2&amp; \neg \forall x Gx &amp; \mbox{(premissa)} \\
&amp; 3&amp; \neg \neg \forall x Fx &amp; \mbox{(negação da conclusão)} \\
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;Como visto nas árvores de refutação da lógica proposicional, existem apenas duas regras para expansão da árvore: conjunção, disjunção. Qualquer outro operador lógico deve ser tratado por meio de fórmulas equivalentes que utilizem apenas conjunção e/ou disjunção.&lt;/p&gt;

&lt;p&gt;Neste exemplo, temos uma fórmula condicional do tipo $\phi\to\psi$, representada por $\forall x Fx \to \forall x Gx$, devemos então utilizar em seu lugar uma fórmula equivalente. Como $\phi\to\psi \dashv\vdash \neg\phi\lor\psi$, podemos utilizar a equivalência.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{lclr}
\checkmark&amp;  1&amp; \forall x Fx \to \forall x Gx &amp; \mbox{(premissa)} \\
&amp; 2&amp; \neg \forall x Gx &amp; \mbox{(premissa)} \\
&amp; 3&amp; \neg \neg \forall x Fx &amp; \mbox{(negação da conclusão)} \\
&amp; 4&amp; \neg \forall x Fx \lor \forall x Gx &amp; \mbox{(Equivalência de 1)}\\
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;Das três fórmulas restantes não marcadas, apenas aquela na linha 4 pode ser expandida, para tal aplicamos a regra da disjunção, a qual cria dois ramos, um para cada disjuncto.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{lclr}
\checkmark&amp; 1 &amp; \forall x Fx \to \forall x Gx &amp; \mbox{(premissa)} \\
&amp; 2&amp; \neg \forall x Gx &amp; \mbox{(premissa)} \\
&amp; 3&amp; \neg \neg \forall x Fx &amp; \mbox{(negação da conclusão)} \\
\checkmark&amp; 4&amp; \neg \forall x Fx \lor \forall x Gx &amp; \mbox{(Equivalência de 1)}\\
&amp; 5&amp; \neg \forall x Fx \qquad\qquad \forall x Gx&amp; \mbox{(Regra da disjunção)}\\
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;Neste momento, encontramos uma contradição em cada um dos ramos.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{lclr}
\checkmark&amp; 1 &amp; \forall x Fx \to \forall x Gx &amp; \mbox{(premissa)} \\
&amp; 2&amp; \neg \forall x Gx &amp; \mbox{(premissa)} \\
&amp; 3&amp; \neg \neg \forall x Fx &amp; \mbox{(negação da conclusão)} \\
\checkmark&amp;4&amp; \neg \forall x Fx \lor \forall x Gx &amp; \mbox{(Equivalência de 1)}\\
&amp; 5&amp; \neg \forall x Fx \qquad \forall x Gx&amp; \mbox{(Regra da disjunção)}\\
&amp; 6&amp; \perp (5,3) \qquad \perp(5,2) &amp; \\
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;As contradições fecharam todos os ramos, portanto essa é uma forma de argumento válida, significando que sempre que $\forall x Fx \to \forall x Gx$ e $\neg \forall x Gx$ forem verdadeiras, então $\neg \forall x Fx$ também será verdadeira. Esta fórmula é a versão em lógica de predicados da regra &lt;em&gt;Modus Tollens&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&quot;generalização-das-Árvores-de-refutação&quot;&gt;Generalização das Árvores de Refutação&lt;/h1&gt;

&lt;h2 id=&quot;quantificador-universal-forall&quot;&gt;Quantificador universal ($\forall$)&lt;/h2&gt;

&lt;p&gt;Se uma fórmla $\forall x Fx$ aparece num ramo aberto da árvore de refutação, e $a$ é uma letra nominal que aparece numa fórmula desse ramo, então podemos instanciar a fórmula, obtendo: $Fa$. Diferente do que ocorreria para as demais regras, a fórmula $\forall x Fx$ não é marcada com $\checkmark$ neste caso, pois ela pode ser instanciada novamente com outras letras nominais que também apareçam no mesmo ramo. Apenas nos casos em que não existam letras nominais no ramo é que uma letra pode ser introduzida.&lt;/p&gt;

&lt;p&gt;Demonstre a validade ou invalidade das seguintes forma de argumento.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x (Fx \to Gx), \forall x Fx \vdash Ga&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Fa\to Gb, \forall x \neg Fx \vdash \neg Gb&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x (Fx \to Gx), \forall x Gx \vdash Fa&lt;/script&gt;

&lt;h2 id=&quot;quantificador-existencial-negado-neg-exists&quot;&gt;Quantificador existencial negado ($\neg \exists$)&lt;/h2&gt;

&lt;p&gt;Se uma fórmula da forma $\neg \exists x Fx$ aparece num ramo aberto, ela deverá ser marcada e substituída por sua equivalente $\forall x\neg Fx$ no final de cada ramo aberto que a contém. $\neg \exists x Fx \dashv \vdash \forall x \neg Fx$&lt;/p&gt;

&lt;p&gt;Demonstre a validade ou invalidade das seguintes forma de argumento.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x (Fx \to Gx), \neg \exists x Gx \vdash \neg Fa&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x(Fx \land Gx) \vdash \neg Fa&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x Fx \to \forall x Gx, \neg \exists x Gx \vdash \exists x \neg Fx&lt;/script&gt;

&lt;h2 id=&quot;quantificador-existencial-exists&quot;&gt;Quantificador existencial ($\exists$)&lt;/h2&gt;

&lt;p&gt;Se uma fórmula da forma $\exists x Fx$ aparece num ramo aberto, ela deve ser marcada. Escolhemos então, uma letra nominal $a$ que ainda não apareceu no mesmo ramo e instanciamos a fórmula, como $Fa$, no final de todo ramo aberto que a contenha.&lt;/p&gt;

&lt;h2 id=&quot;quantificador-universal-negado-neg-forall&quot;&gt;Quantificador universal negado ($\neg \forall$)&lt;/h2&gt;

&lt;p&gt;Se uma fórmula da forma $\neg \forall x Fx$ aparece num ramo aberto, ela deve ser marcada e substituída por sua equivalente $\exists x \neg Fx$.&lt;/p&gt;

&lt;p&gt;Demonstre a validade ou invalidade das seguintes forma de argumento.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists x Fx \vdash \forall x Fx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists x (Fx \land Gx) \vdash \exists Fx \land \exists Gx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists x Fx, \exists x Gx \vdash \exists x(Fx \land Gx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \neg(\exists x Fx \land \forall x \neg Fx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \exists y Lxy \vdash Laa&lt;/script&gt;

</description>
        <pubDate>Wed, 01 Nov 2017 10:20:00 -0200</pubDate>
        <link>http://localhost:4000/lc21cp-172/logica-predicados-arvores-de-refutacao.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/logica-predicados-arvores-de-refutacao.html</guid>
        
        <category>predicados</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
      <item>
        <title>Filas de prioridades e Ordenação - Heapsort</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#introdução&quot; id=&quot;markdown-toc-introdução&quot;&gt;Introdução&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#filas-de-prioridades&quot; id=&quot;markdown-toc-filas-de-prioridades&quot;&gt;Filas de prioridades&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#heap&quot; id=&quot;markdown-toc-heap&quot;&gt;Heap&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;introdução&quot;&gt;Introdução&lt;/h1&gt;

&lt;p&gt;Para compreendermos o significado e a utilidade de &lt;em&gt;filas de prioridade&lt;/em&gt;, vamos utilizar como referência inicial o algoritmo de ordenação &lt;em&gt;selection sort&lt;/em&gt;. Esse algoritmo de ordenação funciona de forma bastante intuitiva&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;A cada passo, selecione o menor elemento e o insira na posição adequada.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Se assumirmos que o objetivo seja ordenar a sequência de forma crescente, o menor elemento deve ser inserido na parte inicial da sequência. Na primeira iteração, portanto, o menor elemento de toda a sequência será identificado e inserido na posição zero. Na segunda iteração, o próximo menor elemento será identificado e inserido na posição um, até que toda a sequência esteja ordenada.&lt;/p&gt;

&lt;p&gt;Podemos perceber que em todo o procedimento acima descrito, a etapa principal é a identificação do menor elemento da sequência. Uma forma simples de implementarmos essa ideia seria uma função &lt;code class=&quot;highlighter-rouge&quot;&gt;min&lt;/code&gt;, que retorna o índice do menor elemento num intervalo de $i$ a $f$.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;menor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;menor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;menor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;menor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Utilizando a função &lt;code class=&quot;highlighter-rouge&quot;&gt;min&lt;/code&gt;, o algoritmo de ordenação selection sort se torna bastante simples.&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;selectsort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Observemos que a repetição do laço &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; em &lt;code class=&quot;highlighter-rouge&quot;&gt;selectsort&lt;/code&gt; acontece $n$ vezes. Em cada uma dessas vezes, a função &lt;code class=&quot;highlighter-rouge&quot;&gt;min&lt;/code&gt; é chamada para identificar o menor elemento. Na primeira chamada, &lt;code class=&quot;highlighter-rouge&quot;&gt;min&lt;/code&gt; tem que percorrer toda a sequência para identificar o menor elemento, ou seja $n-1$ comparações. Na segunda chamada, &lt;code class=&quot;highlighter-rouge&quot;&gt;min&lt;/code&gt; terá que percorrer um elemento a menos, pois o primeiro já foi identificado, ou seja, $n-2$ comparações.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{lr}
[9 &amp; 8 &amp; 1 &amp; 2 &amp; 3 &amp; 7 &amp; 9 &amp; 0] &amp; i=0 &amp; O(n-1)\\
0 &amp; [8 &amp; 1 &amp; 2 &amp; 3 &amp; 7 &amp; 9 &amp; 9] &amp; i=1 &amp;  O(n-2)\\
0 &amp; 1 &amp; [8 &amp; 2 &amp; 3 &amp; 7 &amp; 9 &amp; 9] &amp; i=2 &amp;  O(n-3)\\
0 &amp; 1 &amp; 2 &amp; [8 &amp; 3 &amp; 7 &amp; 9 &amp; 9] &amp; i=3 &amp;  O(n-4)\\
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;Para contabilizarmos todas as etapas efetuadas por &lt;code class=&quot;highlighter-rouge&quot;&gt;min&lt;/code&gt;, basta somar o número de comparações feito em cada uma delas.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(n-1) + (n-2) + \dots + (1) = \sum_{i=1}^n (n-i)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\sum_{i=1}^n (n-i) = n(n+1)/2 = O(n^2)&lt;/script&gt;

&lt;h1 id=&quot;filas-de-prioridades&quot;&gt;Filas de prioridades&lt;/h1&gt;
&lt;p&gt;A análise simples do selection sort, nos indica claramente que o maior processamento feito por este algoritmo ocorre durante a identificação do menor elemento da sequência. Sendo o custo de &lt;code class=&quot;highlighter-rouge&quot;&gt;min&lt;/code&gt; determinante para o custo total do algoritmo. Em cada iteração, o único objetivo é identificar o elemento mínimo, o que nos leva a uma pergunta.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Não haveria uma estrutura de dados que nos permitisse sempre obter o menor elemento de forma mais rápida do que a feita por &lt;code class=&quot;highlighter-rouge&quot;&gt;min&lt;/code&gt;?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Uma das respostas para essa pergunta são as filas de prioridades. Tais estruturas tem como principal objetivo organizar os dados de modo que obter o mínimo/máximo elemento seja tão rápido quanto possível. Diferentemente das filas comuns, em que a ordem de inserção de um elemento determina sua ordem de remoção, nas filas de prioridade é a prioridade que determina a ordem de saída de um elemento. A prioridade, no caso mais simples é o próprio valor do elemento.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;selectsort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;heap&quot;&gt;Heap&lt;/h2&gt;

</description>
        <pubDate>Mon, 30 Oct 2017 13:50:00 -0200</pubDate>
        <link>http://localhost:4000/ae22cp-172/heapsort.html</link>
        <guid isPermaLink="true">http://localhost:4000/ae22cp-172/heapsort.html</guid>
        
        <category>ordenação</category>
        
        
        <category>AE22CP-172</category>
        
      </item>
    
      <item>
        <title>Lógica de predicados - Identidade</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#identidades&quot; id=&quot;markdown-toc-identidades&quot;&gt;Identidades&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplos&quot; id=&quot;markdown-toc-exemplos&quot;&gt;Exemplos&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#introdução-da-identidade&quot; id=&quot;markdown-toc-introdução-da-identidade&quot;&gt;Introdução da identidade&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplos-1&quot; id=&quot;markdown-toc-exemplos-1&quot;&gt;Exemplos&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#eliminação-da-identidade&quot; id=&quot;markdown-toc-eliminação-da-identidade&quot;&gt;Eliminação da identidade&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;identidades&quot;&gt;Identidades&lt;/h1&gt;

&lt;p&gt;Na lógica de predicados podemos definir um predicado $I(x,y)$ para denotar a igualdade entre $x$ e $y$.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$I(x,y)$: $x$ igual a $y$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;No entanto, por esse predicado ser de uso bastante comum, se torna às vezes conveniente representá-lo de forma mais compacta. O mesmo aconteceria se quiséssemos definir um predicado $M(x,y)$ para denotar $x$ é menor que $y$. Como tais predicados são comumente representado pelos símbolos $=$ e $&amp;lt;$ não há motivos para que não utilizemos os mesmos símbolos também na linguagem da lógica de predicados.&lt;/p&gt;

&lt;p&gt;Enquanto a letra ‘I’ pode ser utilizada para denotar o predicado de igualdade/identidade, ou seja $I(x,y)$ indicando a igualdade entre $x$ e $y$; ela também poderia ser utilizada em outras situações para denotar outro predicado qualquer, exemplo $I(x)$ indicando que $x$ é impar. Por outro lado, o símbolo ‘=’ também representa o predicado identidade, no entanto, ele nunca assumirá um significado diferente, ou seja, é um símbolo específico para representar o predicado de igualdade.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$x=y$: $x$ igual a $y$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Diferentemente dos demais predicados, $=$ é utilizado na forma infixa, ou seja, entre os operandos. Isso facilita pois mantém a forma de representação convencionalmente utilizada nas demais áreas da matemática.&lt;/p&gt;

&lt;h2 id=&quot;exemplos&quot;&gt;Exemplos&lt;/h2&gt;

&lt;p&gt;Formalize as seguintes sentenças utilizando o predicado identidade ‘$=$’&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$a$: Álvaro de Campos&lt;/li&gt;
  &lt;li&gt;$t$: Tabacaria&lt;/li&gt;
  &lt;li&gt;$f$: Fernando Pessoa&lt;/li&gt;
  &lt;li&gt;$A(x)$: $x$ é um autor português&lt;/li&gt;
  &lt;li&gt;$M(x,y)$: $x$ é melhor autor que $y$&lt;/li&gt;
  &lt;li&gt;$E(x,y)$: $x$ escreveu $y$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;a. Fernando Pessoa não é Álvaro de Campos&lt;/p&gt;

&lt;p&gt;b. Existe Fernando Pessoa&lt;/p&gt;

&lt;p&gt;c. Se Fernando Pessoa é Álvaro de Campos, então Álvaro de Campos escreveu Tabacaria&lt;/p&gt;

&lt;p&gt;d. Somente Fernando Pessoa escreveu Tabacaria&lt;/p&gt;

&lt;p&gt;e. Fernando Pessoa é o melhor autor português&lt;/p&gt;

&lt;p&gt;f. Existem ao menos duas coisas diferentes.&lt;/p&gt;

&lt;p&gt;g. Existe somente uma coisa.&lt;/p&gt;

&lt;p&gt;h. Existem exatamente duas coisas.&lt;/p&gt;

&lt;h2 id=&quot;introdução-da-identidade&quot;&gt;Introdução da identidade&lt;/h2&gt;

&lt;p&gt;Para qualquer letra nominal $\alpha$, podemos sempre introduzir a identidade $\alpha = \alpha$. Esse tipo de regra é útil para produzir exemplos para outras regras de derivação. Considere, por exemplo, a introdução dos quantificadores universal e existencial, a introdução de ambos depende da existência de um exemplo.&lt;/p&gt;

&lt;p&gt;Para o quantificador universal, esse exemplo deve utilizar uma letra nominal genérica, de modo que seja possível generalizar a afirmação. Nesse caso, uma instância/exemplo $Fa\land Ga$ pode ser generalizada à $\forall x (Fx \land Gx)$, desde que não haja restrições quanto à letra $a$.&lt;/p&gt;

&lt;p&gt;Para o quantificador existencial, por outro lado, o funcionamento é mais simples. Se tivermos um exemplo, então podemos generalizá-lo. Deste modo, a partir de $(Fa\land Ga)$ podemos imediatamente concluir $\exists x(Fx \land Gx)$.&lt;/p&gt;

&lt;h3 id=&quot;exemplos-1&quot;&gt;Exemplos&lt;/h3&gt;

&lt;p&gt;Dada a interpretação acima, como demonstraríamos os seguintes argumentos?&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall x (x=x)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \exists x (a=x)&lt;/script&gt;

&lt;h2 id=&quot;eliminação-da-identidade&quot;&gt;Eliminação da identidade&lt;/h2&gt;

&lt;p&gt;A regra de eliminação da identidade é apenas uma formalização da nossa intuição. Se duas coisas são iguais, posso utilizar tanto uma quanto a outra em qualquer situação.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Fa, a=b \vdash Fb&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Fa, \neg Fb \vdash \neg (a = b)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall x \forall y (x=y)\to(y=x)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall x \forall y \forall z (x=y\land y=z)\to (x=z))&lt;/script&gt;
</description>
        <pubDate>Thu, 26 Oct 2017 10:20:00 -0200</pubDate>
        <link>http://localhost:4000/lc21cp-172/lp-identidade.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/lp-identidade.html</guid>
        
        <category>predicados</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
      <item>
        <title>PROVA 2 - sub</title>
        <description>&lt;p&gt;&lt;strong&gt;NOME:&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;equivalências&quot;&gt;Equivalências&lt;/h1&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;eq.1&lt;/td&gt;
      &lt;td&gt;$\phi\to\psi$&lt;/td&gt;
      &lt;td&gt;$\neg\phi\lor\psi$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;eq.2&lt;/td&gt;
      &lt;td&gt;$\phi\leftrightarrow\psi$&lt;/td&gt;
      &lt;td&gt;$(\phi\land\psi)\lor(\neg\phi\land\neg\psi)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;eq.3&lt;/td&gt;
      &lt;td&gt;$\neg(\phi\land\psi)$&lt;/td&gt;
      &lt;td&gt;$\neg\phi \lor \neg \psi$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;eq.4&lt;/td&gt;
      &lt;td&gt;$\neg(\phi\lor\psi)$&lt;/td&gt;
      &lt;td&gt;$\neg\phi\land\neg\psi$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;eq.5&lt;/td&gt;
      &lt;td&gt;$\neg(\phi\to\psi)$&lt;/td&gt;
      &lt;td&gt;$\phi\land \neg \psi$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;eq.6&lt;/td&gt;
      &lt;td&gt;$\neg(\phi\leftrightarrow\psi)$&lt;/td&gt;
      &lt;td&gt;$(\phi\land \neg\psi)\lor (\neg\phi\land\psi)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;(2,0pts)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; Verifique se as formas de argumento a seguir são válidas ou inválidas utilizando árvores de refutação.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \to \neg q \vdash \neg (p\land q)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p\lor q, \neg p, \neg q \vdash r&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash (p\to q) \leftrightarrow \neg (p \land \neg q)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg (p\lor q), r\leftrightarrow p \vdash  r&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p\leftrightarrow q, \neg(q \leftrightarrow r) \vdash p \leftrightarrow r&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;(2,0pts)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; Utilize árvores de refutação para determinar quais das fórmulas a seguir são satifazíveis ou insatisfatíveis.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg((p\land q) \leftrightarrow(p\lor q))&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \leftrightarrow \neg(p\lor q)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\land q) \land \neg(p\lor r)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg ((p\to(q\land r)) \to (p\to r))&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;(2,0pt)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; Reescreva as sentenças a seguir como fórmulas da lógica de predicados. Utilize os predicados:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$G(x,y)$ : $x$ ganha de $y$&lt;/li&gt;
  &lt;li&gt;$F(x)$ : $x$ é um time de futebol&lt;/li&gt;
  &lt;li&gt;$Z(x,y)$: $x$ é zagueiro de $y$&lt;/li&gt;
  &lt;li&gt;$P(x,y)$: $x$ perde para $y$&lt;/li&gt;
  &lt;li&gt;“c”: Coritiba&lt;/li&gt;
  &lt;li&gt;“j”: Joinville&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;a. Todo time de futebol tem um zagueiro&lt;/p&gt;

&lt;p&gt;b. Se o Joinville ganha do Coritiba, então o Joinville não perde para todos os times de futebol&lt;/p&gt;

&lt;p&gt;c. O Coritiba ganha de algum time de futebol.&lt;/p&gt;

&lt;p&gt;d. O Joinville ganhha de algum time que ganha do Coritiba&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(1,0pts)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; a) Descreva em linguagem natural cada uma das fórmulas. b) Reescreva as fórmulas utilizando outro quantificador.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \forall x \neg Fx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists x \neg Fx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \neg Fx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x \neg Fx&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;(3,0pts)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt; Demonstre 5 das seguintes formas de argumento da lógica de predicados.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists x Fx \vdash \exists x \exists y(Fx \land Fy)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(Fx \leftrightarrow r), r \vdash Fa&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \forall x(Fx \land Gx) \vdash \exists x(\neg Fx \lor \neg Gx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x \exists y Lxy \vdash \forall x \neg Lxx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(Fx \to Gx) \vdash \exists x Fx \to \exists x Gx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \forall y(Fxy \to \neg Fyx) \vdash \forall x \neg Fxx&lt;/script&gt;

</description>
        <pubDate>Wed, 25 Oct 2017 10:20:00 -0200</pubDate>
        <link>http://localhost:4000/lc21cp-172/PROVA2-sub.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/PROVA2-sub.html</guid>
        
        <category>predicados</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
      <item>
        <title>PROVA 2</title>
        <description>&lt;p&gt;&lt;strong&gt;NOME:&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;equivalências&quot;&gt;Equivalências&lt;/h1&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;$\phi\to\psi$&lt;/td&gt;
      &lt;td&gt;$\neg\phi\lor\psi$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;$\phi\leftrightarrow\psi$&lt;/td&gt;
      &lt;td&gt;$(\phi\land\psi)\lor(\neg\phi\land\neg\psi)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;$\neg(\phi\land\psi)$&lt;/td&gt;
      &lt;td&gt;$\neg\phi \lor \neg \psi$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;$\neg(\phi\lor\psi)$&lt;/td&gt;
      &lt;td&gt;$\neg\phi\land\neg\psi$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;$\neg(\phi\to\psi)$&lt;/td&gt;
      &lt;td&gt;$\phi\land \neg \psi$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;$\neg(\phi\leftrightarrow\psi)$&lt;/td&gt;
      &lt;td&gt;$(\phi\land \neg\psi)\lor (\neg\phi\land\psi)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;(2,0pts)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; Verifique se as formas de argumento a seguir são válidas ou inválidas utilizando árvores de refutação.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \vdash (p\to (q\land p)) \to (p\land q)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(q\land r)\to p, \neg q, \neg r \vdash \neg p&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg(p\land q), r \leftrightarrow p \vdash \neg r&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p\leftrightarrow q, q \leftrightarrow r \vdash p \leftrightarrow r&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;(2,0pts)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; Verifique se as fórmulas a seguir são tautologias utilizando árvores de refutação.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \leftrightarrow \neg(p\lor q)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\land q) \land \neg(p\lor r)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\land q) \to p&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg((p\land q) \leftrightarrow(p\lor q))&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\to(q\land r)) \to (p\to r)&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;(1,0pt)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; Reescreva as sentenças a seguir como fórmulas da lógica de predicados. Utilize os predicados:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$A(x,y)$ : $x$ ama $y$&lt;/li&gt;
  &lt;li&gt;$L(x,y)$ : $x$ é mais alto que $y$&lt;/li&gt;
  &lt;li&gt;“Benedito”: $b$&lt;/li&gt;
  &lt;li&gt;“Cassandra”: $c$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;a. Para quaisquer três objetos, se o primeiro é mais alto que o segundo e o segundo mais alto que o terceiro, então o primeiro é mais alto que o terceiro.&lt;/p&gt;

&lt;p&gt;b. Todo mundo é amado por alguém&lt;/p&gt;

&lt;p&gt;c. Benedito e Cassandra amam todo mundo.&lt;/p&gt;

&lt;p&gt;d. Se alguém ama o Benedito então Cassandra ama esse alguém.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(4,0pts)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; Demonstre 5 das seguintes formas de argumento da lógica de predicados.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x (Fx \land Gx) \vdash \forall x (Fx \to \neg Gx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(\neg Fx \lor \neg Gx) \vdash \neg(Fa \land Ga)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(Fx \to Gx) \vdash \forall x(\neg Gx \to \neg Fx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \forall y(Fxy \to \neg Fyx) \vdash \forall x \neg Fxx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x (Fx \land Gx) \vdash \forall x (\neg Fx \lor \neg Gx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \forall x(Fx \land Gx) \vdash \exists x(\neg Fx \lor \neg Gx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x \exists y Lxy \vdash \forall x \neg Lxx&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;(1,0pts)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt; Descreva em linguagem natural cada uma das fórmulas e as reescreva utilizando outro quantificador&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \forall x \neg Fx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists x \neg Fx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \neg Fx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x \neg Fx&lt;/script&gt;

</description>
        <pubDate>Wed, 25 Oct 2017 10:20:00 -0200</pubDate>
        <link>http://localhost:4000/lc21cp-172/PROVA2.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/PROVA2.html</guid>
        
        <category>predicados</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
  </channel>
</rss>
