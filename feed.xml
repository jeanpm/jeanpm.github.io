<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jean P. Martins</title>
    <description>Combinatorial optimization, evolutionary optimization, estimation of distribution algorithms, linkage learning, learning and optimization.
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 27 Sep 2017 09:15:56 -0300</pubDate>
    <lastBuildDate>Wed, 27 Sep 2017 09:15:56 -0300</lastBuildDate>
    <generator>Jekyll v3.4.3</generator>
    
      <item>
        <title>Lógica de predicados - Informal</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#a-necessidade-de-uma-linguagem-mais-rica&quot; id=&quot;markdown-toc-a-necessidade-de-uma-linguagem-mais-rica&quot;&gt;A necessidade de uma linguagem mais rica&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#predicados&quot; id=&quot;markdown-toc-predicados&quot;&gt;Predicados&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#variáveis&quot; id=&quot;markdown-toc-variáveis&quot;&gt;Variáveis&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#quantificadores&quot; id=&quot;markdown-toc-quantificadores&quot;&gt;Quantificadores&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo&quot; id=&quot;markdown-toc-exemplo&quot;&gt;Exemplo&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#exercícios&quot; id=&quot;markdown-toc-exercícios&quot;&gt;Exercícios&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#0&quot; id=&quot;markdown-toc-0&quot;&gt;#0&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#1&quot; id=&quot;markdown-toc-1&quot;&gt;#1&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#2&quot; id=&quot;markdown-toc-2&quot;&gt;#2&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#referências&quot; id=&quot;markdown-toc-referências&quot;&gt;Referências&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-necessidade-de-uma-linguagem-mais-rica&quot;&gt;A necessidade de uma linguagem mais rica&lt;/h1&gt;

&lt;p&gt;Até então desenvolvemos a lógica proposicional, examinando-a de três ângulos: sua teoria de demonstração (dedução natural), sua sintaxe (árvores das fórmulas) e sua semântica (tabelas-verdade). Toda essa discussão se inicou com &lt;em&gt;frases declarativas&lt;/em&gt;, ou &lt;em&gt;proposições&lt;/em&gt;, as quais sempre é possível atribuir um valor lógico. A linguagem da lógica proposicional, por outro lado, é limitada, e existem tipos de afirmações que nela não podem ser representadas satisfatoriamente.&lt;/p&gt;

&lt;p&gt;Vejamos, por exemplo, a frase declarativa:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“Todo estudante é mais jovem do que algum instrutor.”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;É fácil perceber que esta sentença não faz uso de nenhum dos conectivos da lógica proposicional: &lt;em&gt;não&lt;/em&gt;, &lt;em&gt;e&lt;/em&gt;, &lt;em&gt;ou&lt;/em&gt;, &lt;em&gt;se… então&lt;/em&gt;. Deste modo, o máximo que poderíamos fazer, seria representá-la como uma proposição atômica $p$&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$p$: “Todo estudante é mais jovem do que algum instrutor.”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Obviamente, isto não nos traria nenhuma informação sobre a estrutura da frase.&lt;/p&gt;

&lt;p&gt;No contexto dessas limitações, a &lt;em&gt;lógica de predicados&lt;/em&gt;, ou &lt;em&gt;lógica de segunda ordem&lt;/em&gt;, é proposta como forma de representar modificadores do tipo&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;existe&lt;/em&gt;,&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;todo&lt;/em&gt;,&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;entre&lt;/em&gt; e&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;apenas&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;predicados&quot;&gt;Predicados&lt;/h2&gt;

&lt;p&gt;Na frase acima, podemos identificar algumas propriedades&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;ser um estudante&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;ser um instrutor&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;ser mais jovem do que alguém&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Gostaríamos de algum mecanismo por meio do qual pudéssemos representá-las, juntamente com suas relações lógicas e dependências.&lt;/p&gt;

&lt;p&gt;Tomemos como exemplo &lt;em&gt;ser um estudante&lt;/em&gt;, podemos definir que essa propriedade como um &lt;em&gt;predicado&lt;/em&gt; $E(\cdot)$, o qual quando aplicado a algo nos diz que esse algo é um estudante.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$E($André$)$: nos diz que &lt;em&gt;André&lt;/em&gt; é um estudante.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Seguindo a mesma idéia, podemos definir predicados para as demais propriedades&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$I($Paulo$)$: &lt;em&gt;Paulo&lt;/em&gt; é um instrutor.&lt;/li&gt;
  &lt;li&gt;$J($André, Paulo$)$: &lt;em&gt;André&lt;/em&gt; é mais jovem do que &lt;em&gt;Paulo&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Nestes exemplos, $E,I,J$ são chamados &lt;strong&gt;predicados&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://michaelis.uol.com.br/moderno-portugues/busca/portugues-brasileiro/predicado/&quot;&gt;&lt;strong&gt;pre·di·ca·do&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Atributo de um ser; característica, propriedade, qualidade.&lt;/li&gt;
  &lt;li&gt;Qualidade considerada positiva ou desejável, como bondade, delicadeza, gentileza etc.; mérito, virtude: Encontrou uma pessoa com muitos predicados.&lt;/li&gt;
  &lt;li&gt;GRAM Tudo aquilo que se diz do sujeito da frase: Pedro vendeu o carro (vendeu o carro, o predicado, representa aquilo que se declara a respeito de Pedro, o sujeito).&lt;/li&gt;
  &lt;li&gt;LÓG Numa proposição ou num juízo, atributo de um sujeito, que pode ser afirmado ou negado. Símbolo P.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;variáveis&quot;&gt;Variáveis&lt;/h2&gt;

&lt;p&gt;Os predicados acima nos permitem definir propriedades, as quais podem ser utilizadas para identificar &lt;em&gt;estudantes&lt;/em&gt;, &lt;em&gt;instrutores&lt;/em&gt; e a relação de &lt;em&gt;juventude&lt;/em&gt; entre um estudante e um instrutor. No entanto, ainda não é viável representar todos estudantes&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“&lt;strong&gt;Todo estudante&lt;/strong&gt; é mais jovem do que algum instrutor.”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Sem que para isso tenhamos que defini-los um a um.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$E($André$)$, $E($Pedro$)$, $E($Maria$)$, $E($Joana$)$, etc..&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Claramente isto se torna inviável para qualquer número razoável de alunos, e portanto não é uma bom mecanismo para representar “&lt;strong&gt;Todo estudante…&lt;/strong&gt;”&lt;/p&gt;

&lt;p&gt;Para contornarmos esse problema, utilizaremos o conceito de &lt;em&gt;variável&lt;/em&gt;. Uma variável $u,v,w,x,y,z,\dots$ nada mais é que um substituto para  valores concretos. Utilizando $x,y$, poderíamos formalizar os predicados anteriores.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$E(x)$: $x$ é um estudante.&lt;/li&gt;
  &lt;li&gt;$I(x)$: $x$ é um instrutor.&lt;/li&gt;
  &lt;li&gt;$J(x,y)$: $x$ é mais jovem do que $y$.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;quantificadores&quot;&gt;Quantificadores&lt;/h2&gt;

&lt;p&gt;As váriaveis nos oferecem a formalização necessária, porém ainda não nos permite especificar que um &lt;em&gt;predicado&lt;/em&gt; se aplica a &lt;strong&gt;todo&lt;/strong&gt; ou &lt;strong&gt;algum&lt;/strong&gt;. Para isso, utilizamos os &lt;strong&gt;quantificadores&lt;/strong&gt;, os quais definem o escopo das variáveis.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$\forall$: “para todo”&lt;/li&gt;
  &lt;li&gt;$\exists$: “existe” ou “algum”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Os quantificadores em conjunto com variáveis nos permitem então definir afirmações sobre algo genérico&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$\forall y$: “para todo $y$&lt;/li&gt;
  &lt;li&gt;$\exists z$: “existe $z$” ou “existe algum $z$”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Portanto, se quero dizer que todo $x$ é estudante, utilizo o quantificador $\forall$ em conjunto com o predicado e a variável $x$.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x E(x)&lt;/script&gt;

&lt;p&gt;Retornando à frase original&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“Todo estudante é mais jovem do que algum instrutor.”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Podemos reescrevê-la, de forma a tornar mais óbvia as relações.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“Se $x$ é um estudante, então existe um instrutor $y$, tal que $x$ é mais jovem do que $y$.”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Devemos, no entanto, observar que a segunda frase se aplica a apenas um estudante $x$, como queremos generalizar a todos estudantes, utilizaremos o quantificador $\forall$&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(\dots)&lt;/script&gt;

&lt;p&gt;A parte interna dos parênteses é um condicional que se aplica a todo estudante, e portanto&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(E(x)\to \dots)&lt;/script&gt;

&lt;p&gt;O consequente deste condicional se refere ao trecho:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“existe um instrutor $y$, tal que $x$ é mais jovem do que $y$.”&lt;/li&gt;
  &lt;li&gt;“existe $y$, tal que $y$ é um instrutor e $x$ é mais jovem do que $y$.”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Que pode ser representado por:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists y (I(y) \land J(x,y))&lt;/script&gt;

&lt;p&gt;Por fim, a estrutura da frase exemplo pode ser escrita de maneira simbólica da seguinte forma&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(E(x)\to \exists y (I(y) \land J(x,y)))&lt;/script&gt;

&lt;p&gt;A qual pode ser lida da seguinte forma:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“Para todo $x$, se $x$ é um estudante, então existe algum $y$ que é um instrutor tal que $x$ é mais novo do que $y$”&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;exemplo&quot;&gt;Exemplo&lt;/h3&gt;

&lt;p&gt;Considere os seguintes predicados:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$A(x)$: $x$ é uma ave&lt;/li&gt;
  &lt;li&gt;$V(x)$: $x$ pode voar&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Represente simbolicamente a frase&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;“Nem todas as aves podem voar”
&lt;script type=&quot;math/tex&quot;&gt;\neg(\forall x (A(x)\to V(x)))&lt;/script&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;“Existem aves que não voam”
&lt;script type=&quot;math/tex&quot;&gt;\exists x(A(x)\land \neg V(x))&lt;/script&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;exercícios&quot;&gt;Exercícios&lt;/h1&gt;

&lt;h2 id=&quot;0&quot;&gt;#0&lt;/h2&gt;

&lt;p&gt;Interpretando como&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$c$: “está chovendo”&lt;/li&gt;
  &lt;li&gt;$R$: “é uma rã”&lt;/li&gt;
  &lt;li&gt;$V$: “é verde”&lt;/li&gt;
  &lt;li&gt;$S$: “é saltitante”&lt;/li&gt;
  &lt;li&gt;$I$: “é iridescente”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Formalize as seguintes sentenças:&lt;/p&gt;

&lt;p&gt;a. Todas as rãs são verdes&lt;/p&gt;

&lt;p&gt;b. Nenhuma rã é verdes&lt;/p&gt;

&lt;p&gt;c. Algumas rãs são verdes&lt;/p&gt;

&lt;p&gt;d. Algumas rãs não são verdes&lt;/p&gt;

&lt;p&gt;e. Toda coisa é uma rã.&lt;/p&gt;

&lt;p&gt;f. Alguma coisa é uma rã.&lt;/p&gt;

&lt;p&gt;g. Nem toda coisa é uma rã.&lt;/p&gt;

&lt;p&gt;h. Nada é uma rã.&lt;/p&gt;

&lt;p&gt;i. Existem rãs verdes&lt;/p&gt;

&lt;p&gt;j. Qualquer coisa ou é rã ou é iridescente.&lt;/p&gt;

&lt;p&gt;k. Qualquer coisa é uma rã verde.&lt;/p&gt;

&lt;p&gt;l. Está chovendo e algumas rãs estão saltitando&lt;/p&gt;

&lt;p&gt;m. Se está chovendo, então todas as rãs estão saltitando&lt;/p&gt;

&lt;p&gt;n. Algumas coisas são verdes e algumas não são&lt;/p&gt;

&lt;p&gt;o. Algumas coisas são verdes e iridescentes simultaneamente&lt;/p&gt;

&lt;p&gt;p. Ou qualquer coisa é uma rã, ou nada é uma rã&lt;/p&gt;

&lt;p&gt;q. Qualquer coisa ou é uma rã ou não é uma rã.&lt;/p&gt;

&lt;p&gt;r. Todas as rãs são rãs.&lt;/p&gt;

&lt;p&gt;s. Somente rãs são verdes.&lt;/p&gt;

&lt;p&gt;t. Não existem rãs iridescentes.&lt;/p&gt;

&lt;p&gt;u. Todas as rãs verdes estão saltitando&lt;/p&gt;

&lt;p&gt;v. Algumas rãs verdes não estão saltitando&lt;/p&gt;

&lt;p&gt;w. Não é verdade que algumas rãs verdes estão saltitando.&lt;/p&gt;

&lt;p&gt;x. Se nada é verde, então não existem rãs verdes.&lt;/p&gt;

&lt;p&gt;y. Rãs verdes saltam se e somente se não está chovendo.&lt;/p&gt;

&lt;h2 id=&quot;1&quot;&gt;#1&lt;/h2&gt;

&lt;p&gt;Use os predicados&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$A(x,y)$: $x$ admira $y$&lt;/li&gt;
  &lt;li&gt;$B(x,y)$: $x$ estava presente em $y$&lt;/li&gt;
  &lt;li&gt;$P(x)$: $x$ é um professor&lt;/li&gt;
  &lt;li&gt;$E(x)$: $x$ é um estudante&lt;/li&gt;
  &lt;li&gt;$L(x)$: $x$ é uma aula&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;e o símbolo funcional (constante)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$m$: Maria&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;a. Maria admira todo professor&lt;/p&gt;

&lt;p&gt;b. Algum professor admira Maria&lt;/p&gt;

&lt;p&gt;c. Maria admira a si própria&lt;/p&gt;

&lt;p&gt;d. Nenhum estudante estava presente em todas as aulas.&lt;/p&gt;

&lt;p&gt;e. Nenhuma aula teve a presença de todos os estudantes&lt;/p&gt;

&lt;p&gt;f. Nenhuma aula teve a presença de qualquer estudante.&lt;/p&gt;

&lt;h2 id=&quot;2&quot;&gt;#2&lt;/h2&gt;
&lt;p&gt;Suponha&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$F(x,y)$: $x$ é o pai de $y$&lt;/li&gt;
  &lt;li&gt;$M(x,y)$: $x$ é a mãe de $y$&lt;/li&gt;
  &lt;li&gt;$H(x,y)$: $x$ é marido de $y$&lt;/li&gt;
  &lt;li&gt;$S(x,y)$: $x$ é irmã de $y$&lt;/li&gt;
  &lt;li&gt;$B(x,y)$: $x$ é irmão de $y$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;É permitido usar constantes para representar nomes: ‘Ed’, ‘Patsy’&lt;/p&gt;

&lt;p&gt;a. Todos têm uma mãe&lt;/p&gt;

&lt;p&gt;b. Todos têm um pai e uma mãe&lt;/p&gt;

&lt;p&gt;c. Todos que tem uma mãe tem um pai&lt;/p&gt;

&lt;p&gt;d. Ed é um avô&lt;/p&gt;

&lt;p&gt;e. Todos os pais são pais ou mães&lt;/p&gt;

&lt;p&gt;f. Todos os maridos são cônjuges&lt;/p&gt;

&lt;p&gt;g. Nenhum tio é tia&lt;/p&gt;

&lt;p&gt;h. Todos os irmãos são irmãos ou irmãs&lt;/p&gt;

&lt;p&gt;i. Nenhuma avó é pai de alguém&lt;/p&gt;

&lt;p&gt;j. Ed e Patsy são marido e mulher&lt;/p&gt;

&lt;p&gt;k. Carlos é cunhado de Monique.&lt;/p&gt;

&lt;h1 id=&quot;referências&quot;&gt;Referências&lt;/h1&gt;

&lt;p&gt;Seção 1.3: Pgs. 25-28, &lt;a href=&quot;http://www.cse.chalmers.se/edu/course/DAT060/huthryan_lics2_sol.pdf&quot;&gt;Logica - Huth &amp;amp; Ryan (PDF).&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 27 Sep 2017 10:20:00 -0300</pubDate>
        <link>http://localhost:4000/lc21cp-172/logica-predicados-informal.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/logica-predicados-informal.html</guid>
        
        <category>predicados</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
      <item>
        <title>Contêiners abstratos - list, forward_list, vector</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#pilhas-usando-um-container-abstrato&quot; id=&quot;markdown-toc-pilhas-usando-um-container-abstrato&quot;&gt;Pilhas usando um &lt;em&gt;container&lt;/em&gt; abstrato&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#implementação-da-interface-containerh&quot; id=&quot;markdown-toc-implementação-da-interface-containerh&quot;&gt;Implementação da interface &lt;em&gt;container.h&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pilhas-usando-um-container-abstrato&quot;&gt;Pilhas usando um &lt;em&gt;container&lt;/em&gt; abstrato&lt;/h2&gt;

&lt;p&gt;Em princípio, não há problemas em utilizar as funções de &lt;code class=&quot;highlighter-rouge&quot;&gt;vector&lt;/code&gt; para implementar as funcionalidades de &lt;code class=&quot;highlighter-rouge&quot;&gt;stack&lt;/code&gt;. Muito pelo contrário, reuso de funções é um dos objetivos da programação estruturada.&lt;/p&gt;

&lt;p&gt;No entanto, como mencionado anteriormente, pilhas podem ser implementadas sobre diferentes &lt;em&gt;contêiners&lt;/em&gt;. A nossa versão atual, porém, está totalmente acoplada ao &lt;em&gt;contêiner&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;vector&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/stack-vector.png&quot; alt=&quot;stack-vector&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Como podemos eliminar essa limitação e tornar nossa implementação mais geral ainda? De modo que outros contêiners sequenciais (&lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;, por exemplo) também pudessem ser facilmente utilizados quando necessário. A ideia é introduzir uma interface entre a implementação de um contêiner e sua definição.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/stack-container.png&quot; alt=&quot;stack-container&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Essa interface nada mais é do que um arquivo que define todas as funcionalidades que as implementações devem ter para serem um &lt;strong&gt;contêiner&lt;/strong&gt;. Tais arquivos, em geral, contém apenas cabeçalhos de funções e possivelmente definições de tipos de dados.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// **** container.h ****
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#define Type int
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_container&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Funções de remoção de elementos
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pop_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pop_front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;erase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Funções de inserção de elementos
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;push_front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Dada uma interface que define um contêiner genérico (abstrato), podemos redefinir nossa estrutura &lt;code class=&quot;highlighter-rouge&quot;&gt;stack&lt;/code&gt; para que ela utilize essas funções, ao invés daquelas específicas de &lt;code class=&quot;highlighter-rouge&quot;&gt;vector&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// **** stack.c ****
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include &quot;container.h&quot;
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// Redefinir o nome vector
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;container&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Alocação desalocação
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;new_stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;initial_capacity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;initial_capacity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;free_stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;free_container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Inserção e remoção de elementos
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pop_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Retorna um ponteiro para o topo da pilha
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;implementação-da-interface-containerh&quot;&gt;Implementação da interface &lt;em&gt;container.h&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;Até este momento a implementação de &lt;code class=&quot;highlighter-rouge&quot;&gt;stack&lt;/code&gt; não existe de forma concreta, pois ela depende da implementação de funções que não foram implementadas em &lt;code class=&quot;highlighter-rouge&quot;&gt;container.h&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Como já mencionado anteriormente, podem existir diferentes implementações da mesma interface. Qual delas será utilizada por &lt;code class=&quot;highlighter-rouge&quot;&gt;stack.c&lt;/code&gt; é uma decisão feita durante a compilação.&lt;/p&gt;

&lt;p&gt;Suponhamos a existência de duas implementações de &lt;code class=&quot;highlighter-rouge&quot;&gt;container.h&lt;/code&gt;, a primeira em &lt;code class=&quot;highlighter-rouge&quot;&gt;vector.c&lt;/code&gt; e a segunda em &lt;code class=&quot;highlighter-rouge&quot;&gt;list.c&lt;/code&gt;. Ao passarmos uma das duas ao compilador, elas fornecerão a implementação das funções abstratas utilizadas em &lt;code class=&quot;highlighter-rouge&quot;&gt;stack.c&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gcc main.c stack.c vector.c -o main-vector

gcc main.c stack.c list.c -o main-list
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 26 Sep 2017 13:50:00 -0300</pubDate>
        <link>http://localhost:4000/ae22cp-172/um-container-abstrato.html</link>
        <guid isPermaLink="true">http://localhost:4000/ae22cp-172/um-container-abstrato.html</guid>
        
        <category>programação-estruturada</category>
        
        
        <category>AE22CP-172</category>
        
      </item>
    
      <item>
        <title>Lista VI - Árvores de análise e formas normais</title>
        <description>&lt;h1 id=&quot;exercícios&quot;&gt;Exercícios&lt;/h1&gt;

&lt;h2 id=&quot;fórmulas-bem-formuladas&quot;&gt;Fórmulas bem formuladas&lt;/h2&gt;

&lt;p&gt;Dadas as fórmulas a seguir, construa suas árvores de análise e diga quais são bem formuladas:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \land q&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p\land \neg(p \lor q \land s) \to (r\to s)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \land \neg q \to \neg p&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \land (\neg q \to \neg p)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg((\neg q \land (p\to r))\land (r\to q))&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p\land \neg(p\lor \land s) \to (r \to s)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\land q)\to (\neg r\lor(q \to r))&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(((s\to(r\lor \ell))\lor((\neg q)\land r))\to((\neg(p\to s))\to r))&lt;/script&gt;

&lt;h2 id=&quot;subfórmulas&quot;&gt;Subfórmulas&lt;/h2&gt;

&lt;p&gt;Para cada uma das fórmulas, construa suas árvores de análise e liste todas subfórmulas.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \to (\neg p \lor (\neg\neg q \to (p\land q)))&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(s \to r \lor \ell) \lor (\neg q\land r) \to (\neg(p \to s) \to r)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\to q) \land (\neg r \to (q \lor(\neg p\land r)))&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg(s\to(\neg(p\to(q\lor\neg s))))&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;((p\to \neg q))\lor(p\land r)\to s) \lor \neg r&lt;/script&gt;

&lt;h2 id=&quot;formas-normais&quot;&gt;Formas normais&lt;/h2&gt;

&lt;p&gt;Transformar as seguinte fórmulas para a forma normal conjuntiva e disjuntiva (FNC, FND), utilizando tabelas-verdade. Verificar se algumas das fórmulas contém cláusulas de Horn.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;((p\to q)\to p)\to p&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg(p\land \neg p)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\lor q)\to \neg(q \lor r)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\to q) \leftrightarrow (r\land p)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\leftrightarrow q) \to (p \lor q)&lt;/script&gt;

&lt;h1 id=&quot;referências&quot;&gt;Referências&lt;/h1&gt;
&lt;p&gt;Capítulo 4: Pgs. 185 - 203, &lt;a href=&quot;https://racionalistasusp.files.wordpress.com/2010/01/nolt-john-rohatyn-dennis-lc3b3gica.pdf&quot;&gt;Logica - John Nolt (PDF).&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 21 Sep 2017 18:20:00 -0300</pubDate>
        <link>http://localhost:4000/lc21cp-172/lista6-arvores-de-analise.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/lista6-arvores-de-analise.html</guid>
        
        <category>formalização</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
      <item>
        <title>Linguagem da Lógica proposicional - Formas normais</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#formas-normais&quot; id=&quot;markdown-toc-formas-normais&quot;&gt;Formas normais&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#forma-normal-conjuntiva&quot; id=&quot;markdown-toc-forma-normal-conjuntiva&quot;&gt;Forma normal conjuntiva&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#forma-normal-disjuntiva&quot; id=&quot;markdown-toc-forma-normal-disjuntiva&quot;&gt;Forma normal disjuntiva&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#conversão-para-forma-normal&quot; id=&quot;markdown-toc-conversão-para-forma-normal&quot;&gt;Conversão para forma normal&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#forma-normal-disjuntiva-fnd&quot; id=&quot;markdown-toc-forma-normal-disjuntiva-fnd&quot;&gt;Forma normal disjuntiva (FND)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#forma-normal-conjuntiva-fnc&quot; id=&quot;markdown-toc-forma-normal-conjuntiva-fnc&quot;&gt;Forma normal conjuntiva (FNC)&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#benefícios-das-formas-normais&quot; id=&quot;markdown-toc-benefícios-das-formas-normais&quot;&gt;Benefícios das formas normais&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#cláusulas-de-horn&quot; id=&quot;markdown-toc-cláusulas-de-horn&quot;&gt;Cláusulas de Horn&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#exercícios&quot; id=&quot;markdown-toc-exercícios&quot;&gt;Exercícios&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#referências&quot; id=&quot;markdown-toc-referências&quot;&gt;Referências&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;formas-normais&quot;&gt;Formas normais&lt;/h1&gt;

&lt;p&gt;Dada uma fórmula qualquer $\phi$ na linguagem da lógica proposicional, existe uma fórmula $\psi$ equivalente que está na &lt;em&gt;forma normal&lt;/em&gt;. As formas normais são fórmulas com estruturas predefinidas. Tais estruturas são definidas em termos de &lt;em&gt;literais&lt;/em&gt;, que são nada mais que uma definição que engloba tanto símbolos proposicionais quanto suas negações. Exemplos de literais.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p,\neg p, q, r, \neg s&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Definição (literal):&lt;/strong&gt; Um literal é um símbolo proposicional ou sua negação.&lt;/p&gt;

&lt;p&gt;Consideraremos nesta seção dois tipos de formas normais.&lt;/p&gt;

&lt;h2 id=&quot;forma-normal-conjuntiva&quot;&gt;Forma normal conjuntiva&lt;/h2&gt;

&lt;p&gt;Uma fórmula está na &lt;em&gt;forma normal conjuntiva&lt;/em&gt; se ela é uma conjunção de disjunção de literais. Para compreendermos essa definição, iremos por partes, primeiro, considere que uma disjunção de literais é qualquer fórmula do tipos&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p \lor \neg q \lor \dots)&lt;/script&gt;

&lt;p&gt;Portanto, a forma normal conjuntiva é a conjunção de diversas fórmulas desse tipo. Como exemplo temos a seguinte fórmulas&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(\neg p \lor q) \land (\neg r \lor \neg q \lor p) \land (p \lor s)&lt;/script&gt;

&lt;h2 id=&quot;forma-normal-disjuntiva&quot;&gt;Forma normal disjuntiva&lt;/h2&gt;

&lt;p&gt;Uma fórmula está na &lt;em&gt;forma normal disjuntiva&lt;/em&gt; se ela é uma disjunção de conjunção de literais. Uma conjunção de literais, é qualquer fórmula do tipo&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p \land \neg q \land \dots)&lt;/script&gt;

&lt;p&gt;Portanto, a forma normal disjuntiva é a disjunção de diversas fórmulas desse tipo. Como exemplo&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(\neg p \land q) \lor (\neg r \land \neg q \land p) \lor (p \land s)&lt;/script&gt;

&lt;h2 id=&quot;conversão-para-forma-normal&quot;&gt;Conversão para forma normal&lt;/h2&gt;

&lt;p&gt;Como mencionado no início desta seção, a toda fórmula há uma outra fórmula equivalente escrita na forma normal; tanto conjuntiva quanto disjuntiva. Como podemos garantir que essa afirmação seja verdadeira?&lt;/p&gt;

&lt;p&gt;A justificativa para a veracidade dessa afirmação é o fato de que as formas normais conjuntiva e disjuntiva refletem os valores verdade presente em uma tabela-verdade. Como toda fórmula pode ser analizada por uma tabela-verdade, então toda fórmula pode ser escrita na forma normal. Vejamos como isso funciona na prática, considere a seguinte fórmula&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\to q) \land r&lt;/script&gt;

&lt;p&gt;Sua tabela verdade possui 8 linhas, e está descrita a seguir:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$p$&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$q$&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$r$&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$(p\to q)$&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$(p\to q) \land r$&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;forma-normal-disjuntiva-fnd&quot;&gt;Forma normal disjuntiva (FND)&lt;/h3&gt;

&lt;p&gt;Vamos primeiro analisar como utilizar a tabela-verdade acima para  transformar a fórmula $(p\to q) \land r$ em uma fórmula equivalente na forma normal disjuntiva. Para isso observemos as linhas da tabela que tornam a fórmula verdadeira, as quais estão indicadas por um * na tabela abaixo.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$p$&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$q$&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$r$&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$(p\to q)$&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$(p\to q) \land r$&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Se essas são as únicas atribuições de valores-verdade às variáveis $p, q, r$ que tornam a fórmula verdadeira, podemos as utilizar para definir uma outra fórmula, que sempre será verdadeira quando $(p\to q) \land r$ for verdadeira. Para isso, iremos escrever cada uma dessas linhas como uma conjunção. A primeira linha marcada seria representada pela fórmulas&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p \land q \land r)&lt;/script&gt;

&lt;p&gt;A segunda linha marcada seria representada portanto como&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(\neg p \land q \land r)&lt;/script&gt;

&lt;p&gt;E seguindo a mesma ideia, a terceira seria&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(\neg p \land \neg q \land r)&lt;/script&gt;

&lt;p&gt;Como cada uma dessas fórmulas representa uma determinada atribuição de valores-verdade que torna a fórmula original verdadeira, a sua disjunção cobre todas as situações de veracidade da fórmula original&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p \land q \land r) \lor (\neg p \land q \land r) \lor (\neg p \land \neg q \land r)&lt;/script&gt;

&lt;h3 id=&quot;forma-normal-conjuntiva-fnc&quot;&gt;Forma normal conjuntiva (FNC)&lt;/h3&gt;

&lt;p&gt;Para convertermos uma fórmula na forma normal conjuntiva utilizaremos ideia similar à usada anteriormente. No entanto, ao invés de nos focar nas linhas que tornam a fórmula verdadeira, consideraremos àquelas que a torma falsa, as quais estão indicadas na tabela a seguir.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$p$&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$q$&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$r$&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$(p\to q)$&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$(p\to q) \land r$&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;A ideia a ser seguida neste caso é que, estas atribuições de valores-verdade são as únicas alternativas em que a fórmula $(p\to q) \land r$ é falsa. Se falharmos em encontrar uma atribuição que se encaixe numa dessas alternativas, então a fórmula, por consequência, será verdadeira. A forma normal conjuntiva dessa fórmula será a conjunção desses casos.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(\neg p \lor \neg q \lor r)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(\neg p \lor q \lor \neg r)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(\neg p \lor q \lor r)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p \lor \neg q \lor r)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p \lor q \lor r)&lt;/script&gt;

&lt;p&gt;Em resumo, para a fórmula $(p\to q) \land r$ ser verdadeira, todos os casos em que ela poderia ser falsificada (linhas da tabela) devem falhar.&lt;/p&gt;

&lt;h2 id=&quot;benefícios-das-formas-normais&quot;&gt;Benefícios das formas normais&lt;/h2&gt;

&lt;p&gt;Por que nos preocuparíamos em utilizar fórmulas na forma normal conjuntiva, por exemplo? Visto que muitas vezes isso gera fórmulas maiores que a original, não parece evidente tal motivação. No entanto, com uma análise adicional perceberemos que facilmente que a forma normal conjuntiva nos permite muito mais facilmente verificar a satisfabilidade de uma fórmula. Consideremos, como exemplo, a fórmula na forma normal conjuntiva definida a seguir&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(\neg q \lor p \lor r) \land (\neg p\lor r) \land q&lt;/script&gt;

&lt;p&gt;Por definição da conjunção, esta fórmula completa apenas será verdadeira se cada um de seus conjuctos forem verdadeiros. Por outro lado, cada um dos conjuctos é uma disjunção. Suponhamos agora que queremos verificar se a fórmula é uma &lt;strong&gt;tautologia&lt;/strong&gt;. Para isso, o seguinte lema se aplica:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lema:&lt;/strong&gt; Uma disjunção de proposições literais $\ell_1 \lor \ell_2 \lor \dots \lor \ell_n$ é uma tautologia se e somente se exitem $1\leq i, j\leq m$ tais que $\ell_i$ é $\neg\ell_j$.&lt;/p&gt;

&lt;p&gt;Em outras palavras, uma disjunção é uma tautologia apenas se contiver um símbolo e sua negação. Como é evidente, do ponto de vista computacional, isso pode ser verificado muito mais facilmente em uma fórmula em forma normal.&lt;/p&gt;

&lt;p&gt;Se por outro lado, precisarmos demonstrar que uma fórmula em forma normal conjuntiva é &lt;strong&gt;satisfatível&lt;/strong&gt;, podemos nos basear na seguinte proposição.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Proposição:&lt;/strong&gt; Seja uma fórmula $\phi$ da lógica proposicional. Então $\phi$ pode ser satisfeita se e somente se $\neg \phi$ não for uma tautologia.&lt;/p&gt;

&lt;h2 id=&quot;cláusulas-de-horn&quot;&gt;Cláusulas de Horn&lt;/h2&gt;

&lt;p&gt;As cláusulas de Horn são compostas por no máximo um literal positivo. Este tipo de fórmula posssui características interessantes em termos da verificação de satisfabilidade, que verificaremos depois. Uma cláusula de Horn tem a forma&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg p \lor \neg q \lor \dots \lor r&lt;/script&gt;

&lt;p&gt;Deste modo, para satisfazer cláusulas desse tipo, basta atribuir valores-verdade falso para todas as variáveis envolvidas. Como toda cláusula de Horn é a disjunção de vários literais negados, um deles sendo verdadeiro torna toda a cláusula verdadeira.&lt;/p&gt;

&lt;h1 id=&quot;exercícios&quot;&gt;Exercícios&lt;/h1&gt;

&lt;p&gt;Transformar as seguinte fórmulas para a forma normal conjuntiva e disjuntiva (FNC, FND), utilizando tabelas-verdade. Verificar se algumas das fórmulas contém cláusulas de Horn.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;((p\to q)\to p)\to p&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg(p\land \neg p)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\lor q)\to \neg(q \lor r)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\to q) \leftrightarrow (r\land p)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\leftrightarrow q) \to (p \lor q)&lt;/script&gt;

&lt;h1 id=&quot;referências&quot;&gt;Referências&lt;/h1&gt;

&lt;p&gt;Seção 1.3: Pgs. 25-28, &lt;a href=&quot;http://www.cse.chalmers.se/edu/course/DAT060/huthryan_lics2_sol.pdf&quot;&gt;Logica - Huth &amp;amp; Ryan (PDF).&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 21 Sep 2017 10:20:00 -0300</pubDate>
        <link>http://localhost:4000/lc21cp-172/formas-normais.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/formas-normais.html</guid>
        
        <category>linguagem</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
      <item>
        <title>Linguagem da Lógica proposicional - Formalização</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#a-linguagem-da-lógica-proposicional&quot; id=&quot;markdown-toc-a-linguagem-da-lógica-proposicional&quot;&gt;A linguagem da lógica proposicional&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#regras-de-construção&quot; id=&quot;markdown-toc-regras-de-construção&quot;&gt;Regras de construção&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#Árvores-de-análise&quot; id=&quot;markdown-toc-Árvores-de-análise&quot;&gt;Árvores de análise&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tamanho-de-fórmulas&quot; id=&quot;markdown-toc-tamanho-de-fórmulas&quot;&gt;Tamanho de fórmulas&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#subfórmulas&quot; id=&quot;markdown-toc-subfórmulas&quot;&gt;Subfórmulas&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#exercícios&quot; id=&quot;markdown-toc-exercícios&quot;&gt;Exercícios&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#referências&quot; id=&quot;markdown-toc-referências&quot;&gt;Referências&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-linguagem-da-lógica-proposicional&quot;&gt;A linguagem da lógica proposicional&lt;/h1&gt;

&lt;p&gt;A definição da linguagem da lógica proposicional é semelhante à definição de outras linguagens, como por exemplo, a língua portuguesa. Define-se, inicialmente, o conjunto de símbolos disponíveis na linguagem: na língua portuguesa podemos definir&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\{a, b,\dots, z, A, B,\dots, Z\}&lt;/script&gt;

&lt;p&gt;A seguir temos as regras gramaticais que são utilizadas na construção de palavras e sentenças. Em linguagem natural, as palavras não são, necessariamente, originadas a partir de regras bem definidas. Em uma linguagem formal, por outro lado, toda palavra ou sentença deve ser gerada pela aplicação de alguma regra gramatical.&lt;/p&gt;

&lt;p&gt;Na linguagem da lógica proposicional, podemos então apenas dizer que seu alfabeto será composto por um conjunto de &lt;em&gt;proposições atômicas&lt;/em&gt;: $p, q, r,\dots$ ou $p_1, p_2, p_3\dots$ e um o conjunto de &lt;em&gt;conectivos lógicos&lt;/em&gt;: $\neg,\land,\lor,\to,(,)$. Portanto, se designarmos o alfabeto por $\sigma$, teríamos:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\Sigma = \{p_1, p_2, p_3\dots\} \cup \{\neg,\land,\lor,\to,(,)\}&lt;/script&gt;

&lt;p&gt;No entanto, logo percebemos que somente o alfabeto não é suficiente para garantir “palavras” válidas na lógica proposicional, visto que algumas strings compostas por símbolos em $\Sigma$, não são bem formuladas, isto é, não fazem sentido. Veja o exemplo abaixo:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(\neg)()\lor pq\to&lt;/script&gt;

&lt;p&gt;Deste modo, para a formalização da linguagem da lógica proposicional, além de definirmos os símbolos do alfabeto da lógica proposicional, temos que definir as regras de formação das &lt;em&gt;fórmulas bem formuladas&lt;/em&gt; (&lt;em&gt;well-formed-formulas&lt;/em&gt;). Nessas condições, podemos dizer que uma fórmula é bem formulada se ela pode ser construída a partir da aplicação das regras de construção.&lt;/p&gt;

&lt;h2 id=&quot;regras-de-construção&quot;&gt;Regras de construção&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;átomo: Toda proposição atômica $p, q, r, \dots, p_1, p_2, \dots$ é uma fórmula bem formulada.&lt;/li&gt;
  &lt;li&gt;$\neg$: Se $\phi$ é uma fórmula bem formulada, então $(\neg\phi)$ também é.&lt;/li&gt;
  &lt;li&gt;$\land$: Se $\phi$ e $\psi$ são fórmulas bem formuladas, então $(\phi\land\psi)$ também é.&lt;/li&gt;
  &lt;li&gt;$\lor$: Se $\phi$ e $\psi$ são fórmulas bem formuladas, então $(\phi\lor\psi)$ também é.&lt;/li&gt;
  &lt;li&gt;$\to$: Se $\phi$ e $\psi$ são fórmulas bem formuladas, então $(\phi\to\psi)$ também é.&lt;/li&gt;
  &lt;li&gt;$\leftrightarrow$: Se $\phi$ e $\psi$ são fórmulas bem formuladas, então $(\phi\leftrightarrow\psi)$ também é.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Observe que os parênteses são parte das fórmulas bem formuladas. Consideraremos então, que qualquer concatenação de símbolos de $\Sigma$ forma uma fórmula apenas se a string puder ser gerada pela aplicação sucessiva das regras acima.&lt;/p&gt;

&lt;h2 id=&quot;Árvores-de-análise&quot;&gt;Árvores de análise&lt;/h2&gt;

&lt;p&gt;Até então descrevemos características obrigatórias de fórmulas bem formuladas (sintaticamente corretas). Essas fórmulas são aquelas que compõem a linguagem da lógica proposicional. No entanto, nada foi dito quanto a verificação dessas fórmulas, ou seja, como saber se uma dada fórmula está bem formada? Considere o caso&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(((\neg p)\land q)\to(p\land(q\lor(\neg r))))&lt;/script&gt;

&lt;p&gt;&lt;img src=&quot;../assets/LC21CP/tree.png&quot; alt=&quot;tree&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;tamanho-de-fórmulas&quot;&gt;Tamanho de fórmulas&lt;/h2&gt;

&lt;p&gt;Seja $\phi$ uma fórmula da lógica proposicional. O tamanho (ou comprimento) de $\phi$ é definido pelas regras:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;átomo: Toda proposição atômica tem tamanho $|\phi|=1$.&lt;/li&gt;
  &lt;li&gt;$\neg\phi$: tem tamanho $|\neg\phi| = 1 + |\phi|$.&lt;/li&gt;
  &lt;li&gt;$|\phi\land\psi| = |\phi| + 1 + |\psi|$&lt;/li&gt;
  &lt;li&gt;$|\phi\lor\psi| = |\phi| + 1 + |\psi|$&lt;/li&gt;
  &lt;li&gt;$|\phi\to\psi| = |\phi| + 1 + |\psi|$&lt;/li&gt;
  &lt;li&gt;$|\phi\leftrightarrow\psi| = |\phi| + 1 + |\psi|$&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;subfórmulas&quot;&gt;Subfórmulas&lt;/h2&gt;

&lt;p&gt;Toda subárvore de uma árvore de análise é uma subfórmula.&lt;/p&gt;

&lt;h1 id=&quot;exercícios&quot;&gt;Exercícios&lt;/h1&gt;

&lt;p&gt;Dadas as fórmulas a seguir, construa suas árvores de análise:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \land q&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \land \neg q \to \neg p&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \land (\neg q \to \neg p)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg((\neg q \land (p\to r))\land (r\to q))&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\land q)\to (\neg r\lor(q \to r))&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(((s\to(r\lor \ell))\lor((\neg q)\land r))\to((\neg(p\to s))\to r))&lt;/script&gt;

&lt;p&gt;Para cada uma das fórmulas, construa suas árvores de análise e liste todas subfórmulas.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \to (\neg p \lor (\neg\neg q \to (p\land q)))&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(s \to r \lor \ell) \lor (\neg q\land r) \to (\neg(p \to s) \to r)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\to q) \land (\neg r \to (q \lor(\neg p\land r)))&lt;/script&gt;

&lt;h1 id=&quot;referências&quot;&gt;Referências&lt;/h1&gt;

&lt;p&gt;Seção 1.3: Pgs. 25-28, &lt;a href=&quot;http://www.cse.chalmers.se/edu/course/DAT060/huthryan_lics2_sol.pdf&quot;&gt;Logica - Huth &amp;amp; Ryan (PDF).&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 20 Sep 2017 10:20:00 -0300</pubDate>
        <link>http://localhost:4000/lc21cp-172/arvores-de-analise.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/arvores-de-analise.html</guid>
        
        <category>linguagem</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
      <item>
        <title>Exercícios (Listas)</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#exercícios&quot; id=&quot;markdown-toc-exercícios&quot;&gt;Exercícios&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#swap&quot; id=&quot;markdown-toc-swap&quot;&gt;swap&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#splice&quot; id=&quot;markdown-toc-splice&quot;&gt;splice&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#merge&quot; id=&quot;markdown-toc-merge&quot;&gt;merge&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#reverse&quot; id=&quot;markdown-toc-reverse&quot;&gt;reverse&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#removeif&quot; id=&quot;markdown-toc-removeif&quot;&gt;removeif&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#unique&quot; id=&quot;markdown-toc-unique&quot;&gt;unique&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#referências&quot; id=&quot;markdown-toc-referências&quot;&gt;Referências&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;exercícios&quot;&gt;Exercícios&lt;/h1&gt;

&lt;h2 id=&quot;swap&quot;&gt;swap&lt;/h2&gt;

&lt;p&gt;Dadas duas listas encadeadas &lt;code class=&quot;highlighter-rouge&quot;&gt;list* a&lt;/code&gt; e &lt;code class=&quot;highlighter-rouge&quot;&gt;list* b&lt;/code&gt;. Implemente uma função que troque o conteúdo das listas.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Exemplo:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Suponhamos como exemplo as listas encadeadas&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a: 1 -&amp;gt;  2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; NULL&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;b: 11-&amp;gt; 12 -&amp;gt;13 -&amp;gt;14 -&amp;gt; NULL&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Após a aplicação de &lt;code class=&quot;highlighter-rouge&quot;&gt;swap(a, b)&lt;/code&gt;, elas se tornariam:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a: 11-&amp;gt; 12 -&amp;gt;13 -&amp;gt;14 -&amp;gt; NULL&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;b: 1 -&amp;gt;  2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; NULL&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;splice&quot;&gt;splice&lt;/h2&gt;

&lt;p&gt;Dadas duas listas encadeadas &lt;code class=&quot;highlighter-rouge&quot;&gt;list* a&lt;/code&gt; e &lt;code class=&quot;highlighter-rouge&quot;&gt;list* b&lt;/code&gt;. Implemente uma função que insira todos os elementos de &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; em uma dada posição &lt;code class=&quot;highlighter-rouge&quot;&gt;int pos&lt;/code&gt;. Os nós de &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; devem ser removidos neste processo, ou seja, ao final, &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; estará vazia.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;splice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Exemplo:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Suponhamos como exemplo as listas encadeadas&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a: 1 -&amp;gt;  2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; NULL&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;b: 11-&amp;gt; 12 -&amp;gt;13 -&amp;gt;14 -&amp;gt; NULL&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Após a aplicação de &lt;code class=&quot;highlighter-rouge&quot;&gt;splice(a, b, 2)&lt;/code&gt;, elas se tornariam:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a: 1 -&amp;gt;  2 -&amp;gt; ( 11-&amp;gt; 12 -&amp;gt;13 -&amp;gt;14 ) -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; NULL&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;b: NULL&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Os parenteses servem apenas para indicar a inclusão de &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; em &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;merge&quot;&gt;merge&lt;/h2&gt;

&lt;p&gt;Dadas duas listas encadeadas contendo números ordenados: &lt;code class=&quot;highlighter-rouge&quot;&gt;list* a&lt;/code&gt; e &lt;code class=&quot;highlighter-rouge&quot;&gt;list* b&lt;/code&gt;. Implemente uma função que insira todos os elementos de &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; na lista &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; de modo que ao final, a lista &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; ainda esteja ordenada. Os nós de &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; devem ser removidos neste processo, ou seja, ao final, &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; estará vazia.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;merge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Exemplo:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Suponhamos como exemplo duas listas encadeadas ordenadas.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a: 1 -&amp;gt; 2 -&amp;gt; 12 -&amp;gt; 14 -&amp;gt; NULL&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;b: 3 -&amp;gt; 4 -&amp;gt; 11 -&amp;gt; 13 -&amp;gt; NULL&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Após a aplicação de &lt;code class=&quot;highlighter-rouge&quot;&gt;merge(a, b)&lt;/code&gt;, elas se tornariam:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a: 1 -&amp;gt;  2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 11-&amp;gt; 12 -&amp;gt;13 -&amp;gt;14 -&amp;gt; NULL&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;b: NULL&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;DICA: é possível obter a lista final ordenada percorrendo ambas as listas apenas uma vez!&lt;/p&gt;

&lt;h2 id=&quot;reverse&quot;&gt;reverse&lt;/h2&gt;

&lt;p&gt;Dada uma lista encadeada qualquer &lt;code class=&quot;highlighter-rouge&quot;&gt;list* a&lt;/code&gt;. Implemente uma função que retorne outra lista encadeada em que a ordem dos elementos de &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; esteja invertida.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Exemplo:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Suponhamos como exemplo a listas encadeadas a seguir.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a: 1 -&amp;gt; 2 -&amp;gt; 12 -&amp;gt; 14 -&amp;gt; NULL&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A aplicação de &lt;code class=&quot;highlighter-rouge&quot;&gt;reverse(a)&lt;/code&gt; deve retornar uma lista:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;b: 14 -&amp;gt; 12 -&amp;gt; 2 -&amp;gt; 1 -&amp;gt; NULL&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;removeif&quot;&gt;removeif&lt;/h2&gt;

&lt;p&gt;Assim como demais operadores da linguagem C, uma função também pode ser passada como referência. Isto é, também podemos utilizar ponteiros para funções. Por exemplo, considere uma função que verifique se um dado número é par.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;iseven&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Um ponteiro para uma função deste tipo, pode ser declarado da seguinte forma:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;functionPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;functionPtr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iseven&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Após a atribuição, &lt;code class=&quot;highlighter-rouge&quot;&gt;functionPtr&lt;/code&gt; pode ser utilizado para verificar se um número é par.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;par&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;functionPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Agora suponhamos que tivéssemos outra função de mesmo tipo, a qual apenas verifica se um dado número é igual a outro predefinido (&lt;code class=&quot;highlighter-rouge&quot;&gt;989&lt;/code&gt; neste exemplo).&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;is989&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;989&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Observe que apesar de diferentes, essas funções tem a mesma estrutura, ambas recebem um valor e retornam um &lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt;. Assim, poderíamos atribui-las a &lt;code class=&quot;highlighter-rouge&quot;&gt;functionPtr&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;functionPtr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is989&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Após a atribuição, &lt;code class=&quot;highlighter-rouge&quot;&gt;functionPtr&lt;/code&gt; pode ser utilizada para verificar se um número é igual a 989.&lt;/p&gt;

&lt;p&gt;Para exemplificarmos um tipo de situação onde ponteiros para função se tornam úteis. Consideremos o caso da função &lt;code class=&quot;highlighter-rouge&quot;&gt;removeif&lt;/code&gt;, a qual recebe uma lista &lt;code class=&quot;highlighter-rouge&quot;&gt;list* a&lt;/code&gt; e um ponteiro para função.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;removeif&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Como &lt;code class=&quot;highlighter-rouge&quot;&gt;fptr&lt;/code&gt; pode apontar para diferentes funções (todas avaliam uma característica do valor recebido), &lt;code class=&quot;highlighter-rouge&quot;&gt;removeif&lt;/code&gt; se torna mais genérica, e poderia ser utilizada para remover todos números pares, passando-se a função de comparação como argumento:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;removeif&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iseven&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Ou, de forma análoga, poderia ser utilizada para remover todos nós com valor &lt;code class=&quot;highlighter-rouge&quot;&gt;989&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;removeif&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is989&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Dada essa descrição, implemente a função &lt;code class=&quot;highlighter-rouge&quot;&gt;removeif&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;unique&quot;&gt;unique&lt;/h2&gt;

&lt;p&gt;Dada uma lista qualquer &lt;code class=&quot;highlighter-rouge&quot;&gt;list* a&lt;/code&gt;. Implemente uma função que remova nós com valores repetidos, deixando apenas um nó com cada valor.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unique&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Exemplo:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Considere como exemplo a lista a seguir:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a: 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 2 -&amp;gt; 10 -&amp;gt; 1 -&amp;gt; 3 -&amp;gt; 12 -&amp;gt; 10 -&amp;gt; NULL&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Após a aplicação de &lt;code class=&quot;highlighter-rouge&quot;&gt;unique(a)&lt;/code&gt;, ela se tornaria&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a: 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 10 -&amp;gt; 12 -&amp;gt; NULL&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;referências&quot;&gt;Referências&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Linked_list&quot;&gt;wikipedia/linked_list&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://pt.wikipedia.org/wiki/Lista_ligada&quot;&gt;wikipedia/lista_ligada&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.san.uri.br/~ober/arquivos/disciplinas/estruturaII_SI/(ebook)Estruturas%20de%20Dados%20Usando%20C%20(Tenenbaum).pdf&quot;&gt;book/Tenenbaum/cap.4.2&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Tue, 19 Sep 2017 18:40:00 -0300</pubDate>
        <link>http://localhost:4000/ae22cp-172/exercicios-listas.html</link>
        <guid isPermaLink="true">http://localhost:4000/ae22cp-172/exercicios-listas.html</guid>
        
        <category>listas</category>
        
        
        <category>AE22CP-172</category>
        
      </item>
    
      <item>
        <title>Listas de encadeamento duplo</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#listas-de-encadeamento-duplo&quot; id=&quot;markdown-toc-listas-de-encadeamento-duplo&quot;&gt;Listas de encadeamento duplo&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#detalhes-de-implementação&quot; id=&quot;markdown-toc-detalhes-de-implementação&quot;&gt;Detalhes de implementação&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#encadeamento-dos-nós&quot; id=&quot;markdown-toc-encadeamento-dos-nós&quot;&gt;Encadeamento dos nós&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#implementação-de-listas-de-encadeamento-duplo&quot; id=&quot;markdown-toc-implementação-de-listas-de-encadeamento-duplo&quot;&gt;Implementação de listas de encadeamento duplo&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#&quot; id=&quot;markdown-toc-&quot;&gt;#&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#referências&quot; id=&quot;markdown-toc-referências&quot;&gt;Referências&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;listas-de-encadeamento-duplo&quot;&gt;Listas de encadeamento duplo&lt;/h2&gt;

&lt;p&gt;Uma lista de encadeamento duplo (&lt;em&gt;doubly-linked list&lt;/em&gt;) implementa a ideia de uma lista bidirecional. Isto significa que cada elemento  tem conhecimento sobre seu próximo e seu anterior na lista. Esta característica é ilustrada através de uma aresta bidirecionada ligando o elemento ao seu próximo.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a:(NULL, valor, b) &amp;lt;-&amp;gt; b:(a, valor, c) &amp;lt;-&amp;gt; c:(b, valor, NULL)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Assim como nas listas de encadeamento simples, o primeiro aspecto a ser notado é que um elemento de lista (um nó, &lt;em&gt;node&lt;/em&gt;), não é um tipo de dado simples. Isto é necessário visto que cada elemento precisa, além de armazenar um valor, armazenar um ponteiro para o próximo e um ponteiro para o anterior.&lt;/p&gt;

&lt;p&gt;Na linguagem C, este tipo de estrutura é implementada por uma &lt;strong&gt;struct&lt;/strong&gt;. Utilizaremos a seguinte definição:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define Type int
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_node&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;// Valor armazenado
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// Endereço do próximo nó
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// Endereço do próximo nó
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Antes de implementarmos funções para a manipulação da &lt;em&gt;list&lt;/em&gt; é importante compreendermos na prática o que os conceitos até então descritos realmente significam. Com esse fim, algums exemplos serão demonstrados a seguir.&lt;/p&gt;

&lt;h2 id=&quot;detalhes-de-implementação&quot;&gt;Detalhes de implementação&lt;/h2&gt;

&lt;p&gt;Como tem sido convencionado até então, vamos definir uma função que implemente a alocação de memória para &lt;code class=&quot;highlighter-rouge&quot;&gt;node&lt;/code&gt; que serão utilizados como elementos da nossa lista de encadeamento duplo &lt;em&gt;list&lt;/em&gt;.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Aloca memória para um 'node' e define o endereço do próximo como NULL
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;valor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;valor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Observe que a única diferença deste &lt;code class=&quot;highlighter-rouge&quot;&gt;node&lt;/code&gt; para aquele utilizado em listas de encadeamento simples é o campo adicional &lt;code class=&quot;highlighter-rouge&quot;&gt;prev&lt;/code&gt;, que também precisa ser inicializado.&lt;/p&gt;

&lt;p&gt;Consideremos agora a criação de uma lista de encadeamento simples feita manualmente. Para isso a única coisa que precisamos é criar vários &lt;code class=&quot;highlighter-rouge&quot;&gt;node&lt;/code&gt; e definir qual apontará para qual.&lt;/p&gt;

&lt;h3 id=&quot;encadeamento-dos-nós&quot;&gt;Encadeamento dos nós&lt;/h3&gt;

&lt;p&gt;O &lt;em&gt;encadeamento&lt;/em&gt; no contexto de listas duplamente encadeadas implica em dizer para cada nó, qual será o seu próximo e qual será seu anterior. Para clarificar, vamos criar o encadeamento ilustrado a seguir.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a:(NULL, 0, b) &amp;lt;-&amp;gt; b:(a, 1, c) &amp;lt;-&amp;gt; c:(b, 2, NULL)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Observe, que tanto &lt;em&gt;b&lt;/em&gt; quanto &lt;em&gt;c&lt;/em&gt; são ponteiros, portanto representam o endereço de memória no Heap de uma estrutura &lt;code class=&quot;highlighter-rouge&quot;&gt;node&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Criação dos nós
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (0, NULL)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (1, NULL)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (2, NULL)
&lt;/span&gt;    
    &lt;span class=&quot;c1&quot;&gt;// Encadeamento
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (NULL, 0, b)
&lt;/span&gt;    
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// b:(a, 1, NULL)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// b:(a, 1, c)
&lt;/span&gt;    
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// c:(b, 2, NULL)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Este exemplo criou manualmente uma lista encadeada simples de três elementos. Como o último elemento, o nó &lt;em&gt;c&lt;/em&gt;, não possui referência a próximo (&lt;code class=&quot;highlighter-rouge&quot;&gt;c-&amp;gt;next == NULL&lt;/code&gt;) isso nos indica que ele está no final da lista (&lt;em&gt;tail&lt;/em&gt;). Pela mesma ideia, o nó &lt;em&gt;a&lt;/em&gt; está no início da lista (&lt;em&gt;head&lt;/em&gt;) pois ele não possui antecessor (&lt;code class=&quot;highlighter-rouge&quot;&gt;a-&amp;gt;prev == NULL&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Todas as formas de inserção e remoção funcionam da mesma forma em uma lista duplamente encadeada, a única diferença é que neste caso ponteiros para o nó anterior também precisam ser atualizados.&lt;/p&gt;

&lt;h1 id=&quot;implementação-de-listas-de-encadeamento-duplo&quot;&gt;Implementação de listas de encadeamento duplo&lt;/h1&gt;

&lt;p&gt;Nesta implementação de lista, armazenaremos informações adicionais na estrutura &lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;. Esses campos adicionais tem como objetivo melhorar a eficiência das operações de inserção no final da lista. Para isso consideraremos as seguintes informações.&lt;/p&gt;

&lt;p&gt;Considerando a estrutura &lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt; definida a seguir, implemente todas as funcionalidades que foram implementadas para &lt;code class=&quot;highlighter-rouge&quot;&gt;vector&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// *** list.h *** 
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#define Type int
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_node&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;// Valor armazenado
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// Endereço do próximo nó
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// Endereço do nó anterior
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// Número de elementos na lista
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Ponteiro para o primeiro elemento
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Ponteiro para o último elemento
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Aloca memória inicial para o vetor
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Desaloca a memória de v-&amp;gt;data e do próprio v.
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;free_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Funções de remoção de elementos
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_pop_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_pop_front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_erase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Funções de inserção de elementos
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_push_front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1&gt;#&lt;/h1&gt;

&lt;h1 id=&quot;referências&quot;&gt;Referências&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Linked_list&quot;&gt;wikipedia/linked_list&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://pt.wikipedia.org/wiki/Lista_ligada&quot;&gt;wikipedia/lista_ligada&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.san.uri.br/~ober/arquivos/disciplinas/estruturaII_SI/(ebook)Estruturas%20de%20Dados%20Usando%20C%20(Tenenbaum).pdf&quot;&gt;book/Tenenbaum/cap.4.2&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 19 Sep 2017 13:50:00 -0300</pubDate>
        <link>http://localhost:4000/ae22cp-172/listas-encadeamento-duplo.html</link>
        <guid isPermaLink="true">http://localhost:4000/ae22cp-172/listas-encadeamento-duplo.html</guid>
        
        <category>listas</category>
        
        
        <category>AE22CP-172</category>
        
      </item>
    
      <item>
        <title>Listas de encadeamento simples</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#listas-encadeadas&quot; id=&quot;markdown-toc-listas-encadeadas&quot;&gt;Listas encadeadas&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#listas-de-encadeamento-simples&quot; id=&quot;markdown-toc-listas-de-encadeamento-simples&quot;&gt;Listas de encadeamento simples&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#detalhes-de-implementação&quot; id=&quot;markdown-toc-detalhes-de-implementação&quot;&gt;Detalhes de implementação&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#criação-dos-nós&quot; id=&quot;markdown-toc-criação-dos-nós&quot;&gt;Criação dos nós&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#encadeamento-dos-nós&quot; id=&quot;markdown-toc-encadeamento-dos-nós&quot;&gt;Encadeamento dos nós&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#inserção-de-um-novo-nó&quot; id=&quot;markdown-toc-inserção-de-um-novo-nó&quot;&gt;Inserção de um novo nó&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#implementação-de-listas-de-encadeamento-simples&quot; id=&quot;markdown-toc-implementação-de-listas-de-encadeamento-simples&quot;&gt;Implementação de listas de encadeamento simples&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#referências&quot; id=&quot;markdown-toc-referências&quot;&gt;Referências&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;listas-encadeadas&quot;&gt;Listas encadeadas&lt;/h1&gt;

&lt;p&gt;Da mesma forma que vetores (arrays), listas encadeadas também são estruturas sequenciais. Ou seja, os elementos armazenados em tais estruturas de dados obedecem uma certa ordem linear, em que um sucede (ou precede) outro elemento. Nos vetores, essa ordem é implementada diretamente em memória, ou seja, dado um elemento $v[i]$ em um vetor, o elemento $v[i+1]$ está na posição de memória subsequente.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;valor    := v[0]    v[1]    v[2]    ... v[n-1]
endereço := x       x+1     x+2     ... x+n-1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Já listas encadeadas, a situação é um pouco diferente. Apesar dos elementos ainda sim manterem uma ordem sequencial, essa ordem não precisa ser refletida nas posições de memória que eles ocupam. Deste modo, estruturas adicionais são necessárias para indicar qual elemento sucede ou precede outro. Nesta seção iremos tratar de uma implementação bem restrita de listas encadeadas, as listas de encadeamento simples &lt;em&gt;forward_list&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;listas-de-encadeamento-simples&quot;&gt;Listas de encadeamento simples&lt;/h2&gt;

&lt;p&gt;Uma lista de encadeamento simples (&lt;em&gt;singly-linked list&lt;/em&gt;) implementa a ideia de uma lista unidirecional. Isto significa que cada elemento somente tem conhecimento sobre o próximo elemento da lista, e não do anterior. Esta característica é ilustrada através de uma aresta direcionada (seta) ligando o elemento ao seu próximo.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a:(valor, b) -&amp;gt; b:(valor, c) -&amp;gt; c:(valor, prox) -&amp;gt; ...&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;O primeiro aspecto a ser notado é que um elemento de lista (um nó, &lt;em&gt;node&lt;/em&gt;), não é um tipo de dado simples. Isto é necessário visto que cada elemento precisa, além de armazenar um valor, armazenar um ponteiro para o próximo.&lt;/p&gt;

&lt;p&gt;Na linguagem C, este tipo de estrutura é implementada por uma &lt;strong&gt;struct&lt;/strong&gt;. Utilizaremos a seguinte definição:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define Type int
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_node&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;// Valor armazenado
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// Endereço do próximo nó
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Antes de implementarmos funções para a manipulação da &lt;em&gt;forward_list&lt;/em&gt; é importante compreendermos na prática o que os conceitos até então descritos realmente significam. Com esse fim, algums exemplos serão demonstrados a seguir.&lt;/p&gt;

&lt;h2 id=&quot;detalhes-de-implementação&quot;&gt;Detalhes de implementação&lt;/h2&gt;

&lt;p&gt;Como tem sido convencionado até então, vamos definir uma função que implemente a alocação de memória para &lt;code class=&quot;highlighter-rouge&quot;&gt;node&lt;/code&gt; que serão utilizados como elementos da nossa lista de encadeamento simples &lt;em&gt;forward_list&lt;/em&gt;.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Aloca memória para um 'node' e define o endereço do próximo como NULL
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;valor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;valor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Consideremos agora a criação de uma lista de encadeamento simples feita manualmente. Para isso a única coisa que precisamos é criar vários &lt;code class=&quot;highlighter-rouge&quot;&gt;node&lt;/code&gt; e definir qual apontará para qual.&lt;/p&gt;

&lt;h3 id=&quot;criação-dos-nós&quot;&gt;Criação dos nós&lt;/h3&gt;
&lt;p&gt;Dada a função &lt;code class=&quot;highlighter-rouge&quot;&gt;new_node&lt;/code&gt;, a etapa de criação (alocação de memória no Heap) dos nós é trivial. Neste exemplo criamos três nós, $a$, $b$ e $c$; contendo, respectivamente, os valores inteiros $0, 1, 2$.&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Etapa de criação dos nós de lista
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (0, NULL)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (1, NULL)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (2, NULL)
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;encadeamento-dos-nós&quot;&gt;Encadeamento dos nós&lt;/h3&gt;

&lt;p&gt;Como cada nó foi alocado por uma chamada independente à &lt;code class=&quot;highlighter-rouge&quot;&gt;malloc&lt;/code&gt;, fica evidente que não temos controle sobre suas posições de memória. Isso implica que o nó &lt;em&gt;b&lt;/em&gt;, por exemplo, pode não estar em uma posição de memória subsequente à posição de &lt;em&gt;a&lt;/em&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;valor    := (b, NULL)   ... (c, NULL)   ...  (a, NULL)
endereço :=  x          ...  y          ...   z
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Nessas condições, o que definirá a ordem desses nós será o encadeamento entre eles. O termo &lt;em&gt;encadear&lt;/em&gt;, neste contexto, significa apenas dizer qual dos nós será o próximo de qual outro nó. Para clarificar, vamos estender o exemplo acima de modo a criar o encadeamento ilustrado a seguir.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a:(0, b) -&amp;gt; b:(1, c) -&amp;gt; c:(2, NULL)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Observe, que tanto &lt;em&gt;b&lt;/em&gt; quanto &lt;em&gt;c&lt;/em&gt; são ponteiros, portanto representam o endereço de memória no Heap de uma estrutura &lt;code class=&quot;highlighter-rouge&quot;&gt;node&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Criação dos nós
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (0, NULL)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (1, NULL)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (2, NULL)
&lt;/span&gt;    
    &lt;span class=&quot;c1&quot;&gt;// Encadeamento
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (0, b)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (1, c), (2, NULL)
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Este exemplo criou manualmente uma lista encadeada simples de três elementos. Como o último elemento, o nó &lt;em&gt;c&lt;/em&gt;, não possui referência a próximo (&lt;code class=&quot;highlighter-rouge&quot;&gt;c-&amp;gt;next == NULL&lt;/code&gt;) isso nos indica que ele está no final da lista (&lt;em&gt;tail&lt;/em&gt;). Pela mesma ideia, o nó &lt;em&gt;a&lt;/em&gt; está no início da lista (&lt;em&gt;head&lt;/em&gt;).&lt;/p&gt;

&lt;h3 id=&quot;inserção-de-um-novo-nó&quot;&gt;Inserção de um novo nó&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Inserção no início&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;De acordo com a posição de inserção, existem três formas de se inserir um novo nó em uma lista já existente. A primeira, e mais simples neste caso, é a inserção no início da lista. Esse tipo de inserção exige apenas que um novo nó aponte para o atual início. Considerando o exemplo anterior, vamos inserir &lt;code class=&quot;highlighter-rouge&quot;&gt;node* d&lt;/code&gt; no início da lista atual, criando a lista ilustrada abaixo.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;d:(3, a) -&amp;gt; a:(0, b) -&amp;gt; b:(1, c) -&amp;gt; c:(2, NULL)&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Criação dos nós
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (0, NULL)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (1, NULL)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (2, NULL)
&lt;/span&gt;    
    &lt;span class=&quot;c1&quot;&gt;// Encadeamento
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (0, b)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (1, c), (2, NULL)
&lt;/span&gt;    
    &lt;span class=&quot;c1&quot;&gt;// Inserção no início
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Criação do nó (3, NULL)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (3, a)
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Observemos então, que para a inserção no início precisamos apenas de referências ao nó que atualmente está no início (&lt;code class=&quot;highlighter-rouge&quot;&gt;node* a&lt;/code&gt;) e ao novo nó (&lt;code class=&quot;highlighter-rouge&quot;&gt;node* d&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Inserção no final&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;O segundo tipo mais simples de inserção é aquela que introduz um novo elemento no final da lista encadeada. Para isso, precisaremos apenas de referências ao nó que atualmente é o último da lista (&lt;code class=&quot;highlighter-rouge&quot;&gt;node* c&lt;/code&gt;), e o novo nó (&lt;code class=&quot;highlighter-rouge&quot;&gt;node* e&lt;/code&gt;).Considerando o exemplo anterior, vamos inserir &lt;code class=&quot;highlighter-rouge&quot;&gt;node* e&lt;/code&gt; ao fim da lista atual, criando a lista ilustrada abaixo.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;d:(3, a) -&amp;gt; a:(0, b) -&amp;gt; b:(1, c) -&amp;gt; c:(2, e) -&amp;gt; e:(4, NULL)&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Criação dos nós
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (0, NULL)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (1, NULL)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (2, NULL)
&lt;/span&gt;    
    &lt;span class=&quot;c1&quot;&gt;// Encadeamento
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (0, b)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (1, c), (2, NULL)
&lt;/span&gt;    
    &lt;span class=&quot;c1&quot;&gt;// Inserção no início
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Criação do nó c:(3, NULL)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (3, a)
&lt;/span&gt;    
    &lt;span class=&quot;c1&quot;&gt;// Inserção no final
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Criação do nó e:(4, NULL)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Inserção no meio&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Por fim, trataremos do tipo de inserção mais genérico, o que nos permite inserir um novo nó em qualquer posição da lista encadeada. Como forma de exemplo, suponhamos que queremos inserir um novo nó (&lt;code class=&quot;highlighter-rouge&quot;&gt;node* f&lt;/code&gt;) na posição $2$ da lista, ou seja, entre os nós &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; e &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;. Após essa inserção a lista teria a seguinte ordem.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;d:(3, a) -&amp;gt; a:(0, f) -&amp;gt; f:(5, b) -&amp;gt; b:(1, c) -&amp;gt; c:(2, e) -&amp;gt; e:(4, NULL)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Para melhor compreendermos os passos necessários para implementar essa inserção, vamos focar na parte de interesse da lista, comparando o antes e o depois.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a:(0, b) -&amp;gt; b:(1, c)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a:(0, f) -&amp;gt; f:(5, b) -&amp;gt; b:(1, c)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Talvez o fato mais evidente seja que nada foi alterado em &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;. De fato, para inserirmos um novo nó numa posição $i$ qualquer, basta que tenhamos a referência ao nó na posição $i-1$ (&lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;, neste caso). Vejamos como isso é feito em código:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Criação dos nós
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (0, NULL)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (1, NULL)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (2, NULL)
&lt;/span&gt;    
    &lt;span class=&quot;c1&quot;&gt;// Encadeamento
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (0, b)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (1, c), (2, NULL)
&lt;/span&gt;    
    &lt;span class=&quot;c1&quot;&gt;// Inserção no início
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Criação do nó c:(3, NULL)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (3, a)
&lt;/span&gt;    
    &lt;span class=&quot;c1&quot;&gt;// Inserção no final
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Criação do nó e:(4, NULL)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// Inserção no meio: entre a e b
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Criação do nó f:(5, NULL)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Aqui ambos apontam para b 
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// Aqui a aponta para f 
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;implementação-de-listas-de-encadeamento-simples&quot;&gt;Implementação de listas de encadeamento simples&lt;/h1&gt;

&lt;p&gt;Considerando a estrutura &lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt; definida a seguir, implemente todas as funcionalidades que foram implementadas para &lt;code class=&quot;highlighter-rouge&quot;&gt;vector&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// *** list.h *** 
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#define Type int
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_node&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;// Valor armazenado
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// Endereço do próximo nó
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Aloca memória inicial para o vetor
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Desaloca a memória de v-&amp;gt;data e do próprio v.
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;free_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Funções de remoção de elementos
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_pop_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_pop_front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_erase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Funções de inserção de elementos
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_push_front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;referências&quot;&gt;Referências&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Linked_list&quot;&gt;wikipedia/linked_list&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://pt.wikipedia.org/wiki/Lista_ligada&quot;&gt;wikipedia/lista_ligada&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.san.uri.br/~ober/arquivos/disciplinas/estruturaII_SI/(ebook)Estruturas%20de%20Dados%20Usando%20C%20(Tenenbaum).pdf&quot;&gt;book/Tenenbaum/cap.4.2&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 18 Sep 2017 13:50:00 -0300</pubDate>
        <link>http://localhost:4000/ae22cp-172/listas-encadeamento-simples.html</link>
        <guid isPermaLink="true">http://localhost:4000/ae22cp-172/listas-encadeamento-simples.html</guid>
        
        <category>listas</category>
        
        
        <category>AE22CP-172</category>
        
      </item>
    
      <item>
        <title>Lista V - Árvores de refutação</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#1-validade-de-argumentos&quot; id=&quot;markdown-toc-1-validade-de-argumentos&quot;&gt;1. Validade de argumentos&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2-satisfazibilidade-de-fórmulas&quot; id=&quot;markdown-toc-2-satisfazibilidade-de-fórmulas&quot;&gt;2. Satisfazibilidade de fórmulas&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#referências&quot; id=&quot;markdown-toc-referências&quot;&gt;Referências&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;1-validade-de-argumentos&quot;&gt;1. Validade de argumentos&lt;/h1&gt;

&lt;p&gt;Verifique se as formas de argumento a seguir são válidas ou inválidas utilizando árvores de refutação.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg p \vdash p \to \neg p&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \to \neg q \vdash \neg (p\land q)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p\lor q, \neg p, \neg q \vdash r&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg (p\lor q), r\leftrightarrow p \vdash \neg r&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p\leftrightarrow q, q \leftrightarrow r \vdash p \leftrightarrow r&lt;/script&gt;

&lt;h1 id=&quot;2-satisfazibilidade-de-fórmulas&quot;&gt;2. Satisfazibilidade de fórmulas&lt;/h1&gt;

&lt;p&gt;Verifique se as fórmulas a seguir são satifazíveis, caso afirmativo, verifique se são tautologias.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \to p&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg(p\to p)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\lor q)\to p&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \leftrightarrow \neg(p\lor q)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\land q) \land \neg(p\lor r)&lt;/script&gt;

&lt;h1 id=&quot;referências&quot;&gt;Referências&lt;/h1&gt;
&lt;p&gt;Capítulo 4: Pgs. 185 - 203, &lt;a href=&quot;https://racionalistasusp.files.wordpress.com/2010/01/nolt-john-rohatyn-dennis-lc3b3gica.pdf&quot;&gt;Logica - John Nolt (PDF).&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 13 Sep 2017 10:20:00 -0300</pubDate>
        <link>http://localhost:4000/lc21cp-172/lista5-arvores-de-refutacao.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/lista5-arvores-de-refutacao.html</guid>
        
        <category>semântica</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
      <item>
        <title>Semântica da lógica proposicional - Árvores de refutação</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#Árvores-de-refutação&quot; id=&quot;markdown-toc-Árvores-de-refutação&quot;&gt;Árvores de refutação&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#introdução&quot; id=&quot;markdown-toc-introdução&quot;&gt;Introdução&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-conjunção&quot; id=&quot;markdown-toc-exemplo-conjunção&quot;&gt;Exemplo: conjunção&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-disjunção&quot; id=&quot;markdown-toc-exemplo-disjunção&quot;&gt;Exemplo: disjunção&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-invalidade&quot; id=&quot;markdown-toc-exemplo-invalidade&quot;&gt;Exemplo: invalidade&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#regras-de-expansão&quot; id=&quot;markdown-toc-regras-de-expansão&quot;&gt;Regras de expansão&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#condicional-to&quot; id=&quot;markdown-toc-condicional-to&quot;&gt;Condicional $(\to)$&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#bicondicional-leftrightarrow&quot; id=&quot;markdown-toc-bicondicional-leftrightarrow&quot;&gt;Bicondicional $(\leftrightarrow)$&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#conjunção-negada-negland&quot; id=&quot;markdown-toc-conjunção-negada-negland&quot;&gt;Conjunção negada $(\neg\land)$&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#disjunção-negada-neglor&quot; id=&quot;markdown-toc-disjunção-negada-neglor&quot;&gt;Disjunção negada $(\neg\lor)$&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#condicional-negado-negto&quot; id=&quot;markdown-toc-condicional-negado-negto&quot;&gt;Condicional negado $(\neg\to)$&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#bicondicional-negado-negleftrightarrow&quot; id=&quot;markdown-toc-bicondicional-negado-negleftrightarrow&quot;&gt;Bicondicional negado $(\neg\leftrightarrow)$&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#satisfazibilidade&quot; id=&quot;markdown-toc-satisfazibilidade&quot;&gt;Satisfazibilidade&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#exercícios-em-aula&quot; id=&quot;markdown-toc-exercícios-em-aula&quot;&gt;Exercícios em aula&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#1-validade-de-argumentos&quot; id=&quot;markdown-toc-1-validade-de-argumentos&quot;&gt;1. Validade de argumentos&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#2-satisfazibilidade-de-fórmulas&quot; id=&quot;markdown-toc-2-satisfazibilidade-de-fórmulas&quot;&gt;2. Satisfazibilidade de fórmulas&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#referências&quot; id=&quot;markdown-toc-referências&quot;&gt;Referências&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;Árvores-de-refutação&quot;&gt;Árvores de refutação&lt;/h1&gt;

&lt;p&gt;As tabelas verdade fornecem um teste rigoroso e completo para a validade ou invalidade de formas de argumento. De fato, elas são algoritmos que podem ser implementados para verificar tais formas de argumento. Devido a existência desse algoritmo, diz-se que a lógica proposicional é &lt;em&gt;decidível&lt;/em&gt;, pois ele nos permite, em princípio, verificar a validade de qualquer forma de argumento. No entanto, as tabelas-verdade são ineficientes e de difícil utilização por seres humanos. As árvores de refutação são fornecem um algoritmo alternativo, mais eficaz, para o mesmo propósito.&lt;/p&gt;

&lt;h2 id=&quot;introdução&quot;&gt;Introdução&lt;/h2&gt;
&lt;p&gt;O primeiro passo de uma árvore de refutação é criar uma lista constituída das premissas e da negação da conclusão. A cada etapa, tentamos desmembrar as fórmulas em subfórmulas menores, até que restem apenas letras sentenciais, ou a negação das mesmas. Se encontrarmos uma atribuição de valores-verdade que valide todas as fórmulas da lista, então encontramos um caso em que as premissas são verdadeiras e a conclusão falsa: portanto a forma de argumento será inválida.&lt;/p&gt;

&lt;h3 id=&quot;exemplo-conjunção&quot;&gt;Exemplo: conjunção&lt;/h3&gt;
&lt;p&gt;Para exemplificar, considere a forma de argumento a seguir:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \land q \vdash \neg\neg p&lt;/script&gt;

&lt;p&gt;A lista de fórmulas consiste das premissas e da negação da conclusão:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p\land q\\
\neg \neg \neg p&lt;/script&gt;

&lt;p&gt;Como desmembrar qualquer uma dessas fórmulas? Utilizando a derivação de eliminação da conjunção, temos que $p\land q$ pode ser desmembrado em $p,q$.&lt;/p&gt;

&lt;p&gt;Indicamos isso inserindo essas duas subfórmulas abaixo da lista e marcando $p\land q$ como já desmembrada.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{lcc}
1&amp;    p\land q &amp;(\times)\\
2&amp;    \neg \neg \neg p &amp;\\
3&amp;    p &amp;\\
4&amp;    q &amp;
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;A próxima fórmula disponível é $\neg\neg\neg p$, a qual por eliminação da negação é equivalente a $\neg p$. Portanto essa segunda é inserida na lista, enquanto a primeira é marcada como já avaliada.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{lcc}
1&amp;    p\land q &amp;(\times)\\
2&amp;    \neg \neg \neg p &amp; (\times)\\
3&amp;    p &amp;\\
4&amp;    q &amp;\\
5&amp;    \neg p
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;Neste momento, já não há mais nada a ser desmembrado. Caso a lista inicial contenha apenas fórmulas verdadeiras, a lista restante deve conter apenas elementos verdadeiros. No entanto, chegamos a uma contradição $p \land \neg p$. Isso significa que a lista inicial não pode conter apenas fórmulas verdadeiras. Na prática isso significa que a tentativa de redução ao absurdo (inserindo a conclusão negada na lista inicial) nos levou a uma contradição, portanto a forma de argumento original precisa ser valida.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{lcc}
1&amp;    p\land q &amp;(\times)\\
2&amp;    \neg \neg \neg p &amp; (\times)\\
3&amp;    p &amp;\\
4&amp;    q &amp;\\
5&amp;    \neg p &amp;\\
6&amp;    \perp &amp; 3,5
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;A árvore de refutação tem esse nome porque por meio é possível descobrir uma refutação para a forma de argumento. No caso acima, existe apenas um ramo, no entanto, nos próximos exemplos veremos que diversos ramos podem ser expandidos, dependendo da forma de argumento inicial.&lt;/p&gt;

&lt;h3 id=&quot;exemplo-disjunção&quot;&gt;Exemplo: disjunção&lt;/h3&gt;

&lt;p&gt;Considere a forma de argumento:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p\lor q, \neg p \vdash q&lt;/script&gt;

&lt;p&gt;Novamente, a lista de fórmulas inicial consiste das premissas e a negação da conclusão.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{lcc}
1&amp;    p\lor q &amp;\\
2&amp;    \neg p &amp; \\
3&amp;    \neg q &amp;
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;A única fórmula que ainda pode ser desmembrada neste caso é a disjunção $p\lor q$. Esta fórmula tem a característica de ser verdadeira em ambos os casos $p$ ou $q$ separadamente. Para representar essa separação, criamos dois ramos, um para cada letra.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{lccc}
1&amp;    p\lor q &amp; &amp; (\times)\\
2&amp;    \neg p &amp; &amp;\\
3&amp;    \neg q &amp; &amp;\\
4&amp;    p &amp; q &amp; 
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;Observemos que nessa representação temos $p \land \neg p$ e temos $q \land \neg q$, uma contradição em cada um dos ramos. Como todos os ramos abertos levaram a uma contradição, a lista de fórmulas inicial não pode ser verdadeira, implicando que a forma de argumento original é válida. Ou seja, a refutação falhou em todos os ramos que foram abertos.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{lccc}
1&amp;    p\lor q &amp; &amp; (\times)\\
2&amp;    \neg p &amp; &amp;\\
3&amp;    \neg q &amp; &amp;\\
4&amp;    p &amp; q &amp; \\
5&amp;    \perp 2,4 &amp; \perp 3,4&amp;  
\end{array} %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;exemplo-invalidade&quot;&gt;Exemplo: invalidade&lt;/h3&gt;

&lt;p&gt;Consideremos agora a seguinte forma de argumento:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p\lor q, p\vdash \neg q&lt;/script&gt;

&lt;p&gt;Novamente, a lista de fórmulas inicial consiste das premissas e a negação da conclusão. Desta lista inicial, apenas a primeira e a terceira fórmula podem ser desmembradas.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{lcc}
1&amp;    p\lor q &amp;\\
2&amp;    p &amp; \\
3&amp;    \neg\neg q &amp;
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;Como a fórmula $p\lor$ é desmembrada em dois ramos, deixaremos ela pra depois, pois assim economizamos trabalho. Sendo assim, desmembraremos $\neg\neg q$ em sua equivalente $q$.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{lcc}
1&amp;    p\lor q &amp;\\
2&amp;    p &amp; \\
3&amp;    \neg\neg q &amp; (\times)\\
4&amp;    q &amp; 
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;Agora podemos desmembrar a disjunção em dois ramos, cada um contendo apenas um dos disnjuctos.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{lccc}
1&amp;    p\lor q &amp; &amp; (\times)\\
2&amp;    p &amp; &amp;\\
3&amp;    \neg\neg q &amp; &amp; (\times)\\
4&amp;    q &amp; &amp;\\
5&amp;    p &amp; q &amp; \\
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;Neste ponto, todos as fórmulas foram espandidas, no entanto, nenhuma contradição foi encontrada. Isso significa que a árvore de refutação encontrou um contra-exemplo para a forma de argumento original, o qual diz que quando $p$ e $q$ são verdadeiros, a conclusão será falsa. Portanto $p\lor q, p\vdash \neg q$ é uma forma de argumento inválida.&lt;/p&gt;

&lt;p&gt;Um ramo é dito &lt;em&gt;fechado&lt;/em&gt; se ele termina em contradição, e dito &lt;em&gt;aberto&lt;/em&gt; caso contrário.&lt;/p&gt;

&lt;h2 id=&quot;regras-de-expansão&quot;&gt;Regras de expansão&lt;/h2&gt;

&lt;p&gt;Fórmulas diferentes requerem diferentes regras para serem desmembradas (expandidas). No entanto, em geral, qualquer fórmula pode ser incluída em uma das seguintes categorias:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Negação&lt;/td&gt;
      &lt;td&gt;Negação negada&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Conjunção&lt;/td&gt;
      &lt;td&gt;Conjunção negada&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Disjunção&lt;/td&gt;
      &lt;td&gt;Disjunção negada&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Condicional&lt;/td&gt;
      &lt;td&gt;Condicional negado&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Bicondicional&lt;/td&gt;
      &lt;td&gt;Bicondicional negado&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;condicional-to&quot;&gt;Condicional $(\to)$&lt;/h3&gt;

&lt;p&gt;Se um ramo aberto contém uma fórmula da forma $\phi\to\psi$, bifurca-se em dois ramos contendo $\neg\phi$ e $\psi$. Isso se deve à equivalência $\phi\to\psi \dashv\vdash \neg\phi \lor \psi$.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p\to q, q\to r, p \vdash r&lt;/script&gt;

&lt;h3 id=&quot;bicondicional-leftrightarrow&quot;&gt;Bicondicional $(\leftrightarrow)$&lt;/h3&gt;

&lt;p&gt;Se um ramo aberto contém um bicondicional $\phi\leftrightarrow\psi$, bifurca-se em dois ramos contendo $\phi\land\psi$, $\neg\phi\land\neg\psi$. Isso se deve à equivalência $\phi\leftrightarrow\psi \dashv\vdash (\phi\land\psi) \lor (\neg\phi\land\neg\psi)$&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p\leftrightarrow q, \neg p \vdash \neg q&lt;/script&gt;

&lt;h3 id=&quot;conjunção-negada-negland&quot;&gt;Conjunção negada $(\neg\land)$&lt;/h3&gt;

&lt;p&gt;Se um ramo aberto contém a negação de uma conjunção $\neg(\phi\land\psi)$, bifurca-se em dois ramos contendo $\neg\phi$ e $\neg\psi$. Isso se deve à equivalência $\neg(\phi\land\psi) \dashv\vdash \neg\phi \lor \neg\psi$ (lei de De Morgan).&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg(p\land q) \vdash \neg p \land \neg q&lt;/script&gt;

&lt;h3 id=&quot;disjunção-negada-neglor&quot;&gt;Disjunção negada $(\neg\lor)$&lt;/h3&gt;

&lt;p&gt;Se um ramo aberto contém a negação de uma disjunção $\neg(\phi\lor\psi)$, adiciona-se $\neg\phi$ e $\neg\psi$ ao fim de cada ramo aberto, abaixo. Isso se deve à equivalência $\neg(\phi\lor\psi) \dashv\vdash \neg\phi \land \neg\psi$.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p\to q \vdash p \lor q&lt;/script&gt;

&lt;h3 id=&quot;condicional-negado-negto&quot;&gt;Condicional negado $(\neg\to)$&lt;/h3&gt;

&lt;p&gt;Se um ramo aberto contém a negação de um condicional $\neg(\phi\to\psi)$, adiciona-se $\phi$ e $\neg\psi$ ao fim de cada ramo aberto abaixo. Isso se deve à equivalência  $\neg(\phi\to\psi) \dashv\vdash \phi \land \neg \psi$.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg p \to \neg q \vdash p \to q&lt;/script&gt;

&lt;h3 id=&quot;bicondicional-negado-negleftrightarrow&quot;&gt;Bicondicional negado $(\neg\leftrightarrow)$&lt;/h3&gt;

&lt;p&gt;Se um ramo aberto contém a negação de um bicondicional $\neg(\phi\leftrightarrow\psi)$, bifurca-se cada ramo abaixo em $\phi\land\neg\psi$ e $\neg\phi\land\psi$. Cada uma dessas partes é por sua vez expandida em duas linhas: $\phi$ e $\neg\psi$, no primeiro ramo; e $\neg\phi$ e $\psi$, no segundo ramo. Isso se deve à equivalência $\neg(\phi\leftrightarrow\psi) \dashv\vdash (\phi\land\neg\psi) \lor (\neg\phi\land\psi)$&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p, p\to q \vdash p\leftrightarrow q&lt;/script&gt;

&lt;h2 id=&quot;satisfazibilidade&quot;&gt;Satisfazibilidade&lt;/h2&gt;

&lt;p&gt;Assim como as tabelas-verdade, as árvores de refutação também podem ser utilizadas para verificar as características de fórmulas: satizfazibilidade, insatisfatibilidade, tautologia.&lt;/p&gt;

&lt;p&gt;Em geral, uma árvore de refutação nos permite encontrar uma atribuição de valores verdade que satisfaça uma determinada fórmula. No caso de formas de argumento, como visto até então, inserimos a negação da conclusão dentre as premissas. Deste modo se uma atribuição for encontrada, teríamos como demostrar a invalidade da forma de argumento.&lt;/p&gt;

&lt;p&gt;Se ignorarmos a negação da conclusão (visto que uma fórmula não possui conclusão), esse tipo de árvore de expansão pode ser utilizada para encontrar uma atribuição de valores-verdade que satisfaça determinada fórmula. Sempre que uma atribuição for encontrada, podemos concluir que a fórmula é então &lt;em&gt;satisfazível&lt;/em&gt;, caso contrário ela é &lt;em&gt;insatisfatível&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Como exemplo, vamos procurar uma atribuição de valores-verdade para a fórmula:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\to q)\lor (p\land \neg q)&lt;/script&gt;

&lt;p&gt;Como não há conclusão a ser negada, inserimos apenas a fórmula inicial&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{lccc}
1&amp;    (p\to q) \lor (p\land \neg q) &amp; &amp; 
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;A única fórmula disponível pode então ser expandida em dois ramos pela regra de eliminação da disjunção.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{lccc}
1&amp;    (p\to q) \lor (p\land \neg q) &amp; &amp; (\times)\\
2&amp;    p\to q &amp; p\land\neg q&amp;
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;Aplicando agora a regra da eliminação da conjunção em $p\land\neg q$ e a eliminação do condicional em $p\to q$, chegaremos a tabela&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{lcccc}
1&amp;    &amp;(p\to q) \lor (p\land \neg q) &amp; &amp;(\times)\\
2&amp;    p\to q &amp; &amp; p\land\neg q&amp; (\times)\\
3&amp;    \neg p &amp; q &amp; p &amp; \\
4&amp;     &amp;  &amp; \neg q &amp;
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;As duas últimas expansões completam a árvore de refutação. Como nenhuma contradição foi encontrada, então encontramos exemplos de atribuição de valores-verdade a $p$ e $q$ tais que a fórmula $(p\to q) \lor (p\land \neg q)$ é verdadeira. Cada ramo ainda aberto representa uma dessas atribuições, ou seja:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$p: F$ e $q: V$ no ramo esquerdo, e&lt;/li&gt;
  &lt;li&gt;$p: V$ e $q: F$ no ramo da direita.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;O fato de existir uma atribuição que torne verdadeira a fórmula (ausência de contradição na árvore) implica que a fórmula é &lt;em&gt;satisfazível&lt;/em&gt;. O caso oposto, de todos os ramos gerarem uma contradição indicaria que a fórmula é &lt;em&gt;insatisfatível&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A negação de uma fórmula &lt;em&gt;insatisfatível&lt;/em&gt; é sempre uma tautologia. Portanto, para demonstrarmos se uma fórmula é uma &lt;em&gt;tautologia&lt;/em&gt; basta expandirmos a árvore de refutação para a sua negação. Se todos ramos abertos levarem a uma contradição (se fecharem), então a fórmula original é uma tautologia. Como exercício, demonstre que a fórmula a seguir é uma tautologia.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\to q) \lor (p\land \neg q)&lt;/script&gt;

&lt;h1 id=&quot;exercícios-em-aula&quot;&gt;Exercícios em aula&lt;/h1&gt;

&lt;h2 id=&quot;1-validade-de-argumentos&quot;&gt;1. Validade de argumentos&lt;/h2&gt;

&lt;p&gt;Verifique se as formas de argumento a seguir são válidas ou inválidas utilizando árvores de refutação.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \lor q \vdash p\land q&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \vdash (p\to (q\land p)) \to (p\land q)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(q\land r)\to p, \neg q, \neg r \vdash \neg p&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg(p\land q), r \leftrightarrow p \vdash \neg r&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p\to(r\lor s), (r\land s) \to q \vdash p\to q&lt;/script&gt;

&lt;h2 id=&quot;2-satisfazibilidade-de-fórmulas&quot;&gt;2. Satisfazibilidade de fórmulas&lt;/h2&gt;

&lt;p&gt;Verifique se as fórmulas a seguir são satifazíveis, caso afirmativo, verifique se são tautologias.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \to \neg p&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \to q&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\land q) \to p&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg((p\land q) \leftrightarrow(p\lor q))&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\to(q\land r)) \to (p\to r)&lt;/script&gt;

&lt;h1 id=&quot;referências&quot;&gt;Referências&lt;/h1&gt;

&lt;p&gt;Capítulo 4: Pgs. 185 - 203, &lt;a href=&quot;https://racionalistasusp.files.wordpress.com/2010/01/nolt-john-rohatyn-dennis-lc3b3gica.pdf&quot;&gt;Logica - John Nolt (PDF).&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 13 Sep 2017 10:20:00 -0300</pubDate>
        <link>http://localhost:4000/lc21cp-172/arvores-de-refutacao.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/arvores-de-refutacao.html</guid>
        
        <category>semântica</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
  </channel>
</rss>
