<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jean P. Martins</title>
    <description>Combinatorial optimization, evolutionary optimization, estimation of distribution algorithms, linkage learning, learning and optimization.
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 07 Nov 2017 13:20:59 -0200</pubDate>
    <lastBuildDate>Tue, 07 Nov 2017 13:20:59 -0200</lastBuildDate>
    <generator>Jekyll v3.4.3</generator>
    
      <item>
        <title>FAQ</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#segmentation-fault&quot; id=&quot;markdown-toc-segmentation-fault&quot;&gt;Segmentation Fault&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo-1&quot; id=&quot;markdown-toc-exemplo-1&quot;&gt;Exemplo 1&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo-2&quot; id=&quot;markdown-toc-exemplo-2&quot;&gt;Exemplo 2&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#programação-estruturada&quot; id=&quot;markdown-toc-programação-estruturada&quot;&gt;Programação estruturada&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#função-list_sizel&quot; id=&quot;markdown-toc-função-list_sizel&quot;&gt;Função &lt;code class=&quot;highlighter-rouge&quot;&gt;list_size(l)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;segmentation-fault&quot;&gt;Segmentation Fault&lt;/h1&gt;

&lt;p&gt;Se seu código está dando falha de segmentação, rode ele dentro do gdb, em muitos casos nem é preciso procurar o erro passo a passo, pois o gdb mostra informações de onde a falha de segmentação ocorreu.&lt;/p&gt;

&lt;h2 id=&quot;exemplo-1&quot;&gt;Exemplo 1&lt;/h2&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;@:~$ &lt;/span&gt;./list &amp;lt; input/input02.txt 
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1] 35 
Falha de segmentação &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;imagem &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;núcleo gravada&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Esta saída não nos dá informação suficiente para a correção do erro. Portanto, utilizarei o gdb. Primeiro passo, compilar com a flag &lt;code class=&quot;highlighter-rouge&quot;&gt;-g&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;@:~$ &lt;/span&gt;gcc main.c list.c -o list -g
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Após isso, inicializar o gdb passando o executável como parâmetro&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;@:~$ &lt;/span&gt;gdb ./list
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;A seguir, utilizar o comando &lt;code class=&quot;highlighter-rouge&quot;&gt;run&lt;/code&gt; do gdb para iniciar a execução do programa.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; run ./list &amp;lt; input/input02.txt &amp;gt; out
Starting program: ./list &amp;lt; input/input02.txt &amp;gt; out
 
Program received signal SIGSEGV, Segmentation fault.
0x00000000004009fb &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;list_erase &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0x7fffffffdfd0, &lt;span class=&quot;nv&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; at list.c:101
101        n-&amp;gt;next&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;j-&amp;gt;next;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Desta saída, podemos focar apenas em algumas partes.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Program received signal SIGSEGV, Segmentation fault.
&lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;list_erase &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;v, &lt;span class=&quot;nv&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; at list.c:101
101        n-&amp;gt;next&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;j-&amp;gt;next;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;SIGSEGV, é uma constante representando o tipo de erro, neste caso &lt;em&gt;segmentation fault&lt;/em&gt;, que se refere à tentativa de acesso de memória não permitido: além dos limites de um vetor, ou em posições de memória que não foram alocadas pelo programador.&lt;/p&gt;

&lt;p&gt;Note, que &lt;code class=&quot;highlighter-rouge&quot;&gt;list_erase (v, i=1)&lt;/code&gt;, nos diz que o erro aconteceu na função &lt;code class=&quot;highlighter-rouge&quot;&gt;list_erase&lt;/code&gt;, quando recebendo a posição &lt;code class=&quot;highlighter-rouge&quot;&gt;i=1&lt;/code&gt; e nos mostra também a linha exata onde a falha de segmentação aconteceu.&lt;/p&gt;

&lt;h2 id=&quot;exemplo-2&quot;&gt;Exemplo 2&lt;/h2&gt;

&lt;p&gt;Seguiremos o mesmo procedimento descrito anteriormente.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;@:~$ &lt;/span&gt;./list &amp;lt; input/input03.txt 
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1] 68
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;2] 68 98
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;3] 16 68 98
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;2] 68 98
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1] 98
Falha de segmentação &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;imagem &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;núcleo gravada&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;@:~$ &lt;/span&gt;gdb ./list
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; run ./list &amp;lt; input/input03.txt 
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1] 68
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;2] 68 98
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;3] 16 68 98
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;2] 68 98
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1] 98
 
Program received signal SIGSEGV, Segmentation fault.
0x0000000000400acb &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;list_pop_back &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0x604020&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; at list.c:183
183 &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;ptr-&amp;gt;next-&amp;gt;next !&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; NULL&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Neste exemplo, a falha de segmentação ocorreu na linha 183, na função &lt;code class=&quot;highlighter-rouge&quot;&gt;list_pop_back&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;in list_pop_back (l=0x604020) at list.c:183
183 while(ptr-&amp;gt;next-&amp;gt;next != NULL)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Como sabemos, &lt;em&gt;segmentation fault&lt;/em&gt; indica acesso indevido de memória. Portanto podemos imaginar que algo errado com a operação&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;183 while(ptr-&amp;gt;next-&amp;gt;next != NULL)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;O que aconteceria se &lt;code class=&quot;highlighter-rouge&quot;&gt;ptr-&amp;gt;next&lt;/code&gt; for &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt;? Bom, neste caso, ao tentar acessar o próximo &lt;code class=&quot;highlighter-rouge&quot;&gt;-&amp;gt;next&lt;/code&gt;, estariamos acessando o endereço indicado por &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt;, e lá procurando o campo &lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt;, algo como: &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL-&amp;gt;next&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Como &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt; é usualmente definido como o endereço &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; da memória, qualquer acesso a esse endereço levará à falha de segmentação. Portanto, sempre que houver falha de segmentação, a primeira suspeita deve ser:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Acesso fora dos limites de um vetor&lt;/li&gt;
  &lt;li&gt;Acesso (dereferenciamento) ao endereço &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;programação-estruturada&quot;&gt;Programação estruturada&lt;/h1&gt;

&lt;h2 id=&quot;função-list_sizel&quot;&gt;Função &lt;code class=&quot;highlighter-rouge&quot;&gt;list_size(l)&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;“Se a estrutura de dados &lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt; duplamente encadeada já possui um campo &lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;, qual a necessidade da função &lt;code class=&quot;highlighter-rouge&quot;&gt;list_size()&lt;/code&gt;.”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Em algumas situações certas funções parecem desnecessárias, é o caso do &lt;code class=&quot;highlighter-rouge&quot;&gt;list_size()&lt;/code&gt;. Para entender o porque de sua utilidade, é bom pensarmos em termos da lista como estrutura abstrata, a qual tem uma interface &lt;code class=&quot;highlighter-rouge&quot;&gt;list.h&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Nesse sentido, ambas implementações, “lista simples”, “listas duplas”, teriam uma implementação de &lt;code class=&quot;highlighter-rouge&quot;&gt;list_size()&lt;/code&gt;. Nas listas simples, preciso percorrer toda lista para saber o tamanho, nas duplas, basta acessar o size já existente. Algo desse tipo&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// forward_list.c
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;list_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// list.c
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;list_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Agora suponha que estejamos utilizando uma estrutura lista para resolver algum problema, soma/multiplicação de inteiros grandes, splice, por exemplo.&lt;/p&gt;

&lt;p&gt;Neste caso, se sempre que precisarmos saber o tamanho de uma lista, utilizarmos &lt;code class=&quot;highlighter-rouge&quot;&gt;list_size()&lt;/code&gt; (e as demais funções de acesso a lista), isso nos permitiria utilizar tanto a implementação da lista de encadeamento simples (&lt;code class=&quot;highlighter-rouge&quot;&gt;forward_list.c&lt;/code&gt;) quanto a de encadeamento duplo (&lt;code class=&quot;highlighter-rouge&quot;&gt;list.c&lt;/code&gt;). Bastando escolher durante a compilação.&lt;/p&gt;

&lt;p&gt;Se pelo contrário, eu utilizasse &lt;code class=&quot;highlighter-rouge&quot;&gt;l-&amp;gt;size&lt;/code&gt; diretamente, eu não conseguiria utilizar a implementação &lt;code class=&quot;highlighter-rouge&quot;&gt;forward_list.c&lt;/code&gt;, visto que nela, esse campo não existe.&lt;/p&gt;

&lt;p&gt;Portanto, a ideia de termos várias funções para acessar certas propriedades da estrutura, nos permite separar a implementação da definição da estrutura de dados. Isso é sugerido quando programamos pensando em reutilização, e programação de bibliotecas.&lt;/p&gt;

&lt;p&gt;Obviamente, podemos também querer implementar uma lista para algo bem específico, sem pensar que tal código será reutilizado para várias coisas diferentes, e então, não precisaríamos nos preocupar com isso.&lt;/p&gt;

&lt;p&gt;Em geral é essa a ideia, e se aplica ao uso das demais funções também.&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Dec 2017 13:50:00 -0200</pubDate>
        <link>http://localhost:4000/ae22cp-172/FAQ.html</link>
        <guid isPermaLink="true">http://localhost:4000/ae22cp-172/FAQ.html</guid>
        
        <category>faq</category>
        
        
        <category>AE22CP-172</category>
        
      </item>
    
      <item>
        <title>Tabelas hash</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#introdução&quot; id=&quot;markdown-toc-introdução&quot;&gt;Introdução&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#endereçamento-direto&quot; id=&quot;markdown-toc-endereçamento-direto&quot;&gt;Endereçamento direto&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tabelas-hash&quot; id=&quot;markdown-toc-tabelas-hash&quot;&gt;Tabelas Hash&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#resolução-de-colisões-por-encadeamento&quot; id=&quot;markdown-toc-resolução-de-colisões-por-encadeamento&quot;&gt;Resolução de colisões por encadeamento&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;introdução&quot;&gt;Introdução&lt;/h1&gt;

&lt;p&gt;Muitas aplicações precisam manipular informações sem necessariamente se preocupar na ordem em que essas informações estão armazenadas na memória. A maioria das estruturas de dados “lineares” estudadas até então, no entanto, impõe uma ordem específica aos elementos. Em uma lista, por exemplo, a inserção de um novo elemento requer que especifiquemos a posição de inserção desse elemento, o mesmo ocorre para vetores. O uso de fila de prioridades (implementadas sobre uma estrutura Heap) foi a primeira excessão a esta regra que investigamos, onde estavamos interessados sempre no mínimo elemento armazenado, mas sem nos importar necessariamente em que posição da estrutura esse elemento estava armazenado.&lt;/p&gt;

&lt;p&gt;Nesta seção uma nova estrutura de dados será introduzida, a qual nos permitirá efetuar operações como:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Inserção,&lt;/li&gt;
  &lt;li&gt;Remoção, e&lt;/li&gt;
  &lt;li&gt;Procura&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;de forma eficiente e sem nos preocuparmos com o posicionamento em memória dos elementos armazenados. Diferentemente das filas de prioridade, no entanto, tabelas hash permitem remoção de quaisquer elementos armazenados, não somento o mínimo/máximo. A única exigência sendo que cada um dos elementos armazenados tenha uma &lt;em&gt;chave&lt;/em&gt; única que o identifique.&lt;/p&gt;

&lt;p&gt;Exemplos:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Um aluno tem como chave única que o identifica, seu RA.&lt;/li&gt;
  &lt;li&gt;Uma pessoa tem como chave única que a identifica, seu CPF.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;endereçamento-direto&quot;&gt;Endereçamento direto&lt;/h1&gt;

&lt;p&gt;Tabelas hash são uma generalização de uma forma de armazenamento com mais limitações, chamada endereçamento aberto.&lt;/p&gt;

&lt;p&gt;Suponha que desejemos armazenar as informações sobre os funcionários de uma pequena empresa. Cada funcionário tem o seu identificador, um número que indica seu cadastro na empresa. Por se tratar de uma empresa pequena, o número de funcionários $n$ não é grande, $n\leq m$ por exemplo. É natural assumirmos que esses identificadores sejam atribuídos de forma crescente a cada novo funcionário contratado.&lt;/p&gt;

&lt;p&gt;Neste pequeno exemplo, assumimos que tais identificadores são as &lt;em&gt;chaves&lt;/em&gt; únicas de cada funcionário. Como o número $n$ de funcionários nunca ultrapassa $m$, um conjunto universo de chaves possíveis contendo números&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;U=\{0,1,\dots,m-1\}&lt;/script&gt;

&lt;p&gt;é suficiente para identificar todos eles. Ou seja, cada funcionário tem um número identificador $u\in U$. Como armazenar as informações sobre tais funcionários na memória de modo a ser possível inserir, remover, e procurar de forma eficiente?&lt;/p&gt;

&lt;p&gt;Sendo o número total de chaves $m$ de tamanho moderado, poderíamos simplesmente criar um vetor de $m$ posições.&lt;/p&gt;

&lt;p&gt;Dada uma chave, procurar pelo funcionário associado é então trivial. Tão triviais quanto serão as operações de inserção e removação de um funcionário.&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chave&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chave&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chave&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chave&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Info&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chave&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Neste contexto tão específico, em que sabemos que a maior chave possível $m$ é um número razoavelmente pequeno, esta é a implementação mais rápida possível. Porém, não é difícil percebermos suas limitações:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;E se as chaves $m$ forem números de 9 dígitos?
    &lt;ul&gt;
      &lt;li&gt;A tabela seria gigantesca, e se o número de itens armazenados for pequeno, um grande desperdício de memória ocorreria.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;E se as chaves não forem inteiros?
    &lt;ul&gt;
      &lt;li&gt;Não há como indexar a tabela com chaves não-inteiras.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;tabelas-hash&quot;&gt;Tabelas Hash&lt;/h1&gt;

&lt;p&gt;Nas situações em que endereçamento direto não se aplica, devido ao grande número de chaves possíveis, as Tabelas hash são opções interessantes.&lt;/p&gt;

&lt;p&gt;A ideia geral de uma tabela hash é diminuir o número de chaves que precisam ser tratadas, saindo de $|U|$ para um número $m \ll |U|$ (“muito menor que”). Para isso precisamos de função&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;h: U \to \{0,\dots,m-1\}&lt;/script&gt;

&lt;p&gt;que mapeie cada possível chave $k\in U$ para um número $h(k)$, onde $h$ é chamada &lt;strong&gt;função hash&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Neste contexto, se utilizarmos $h(k)$ como índice na tabela, precisaríamos de uma tabela de tamanho $m$ ao invés de $|U|$. Como, por definição $m\ll|U|$, uma grande economia de espaço é possível. O exemplo mais simples de função hash é o uso do operador de &lt;em&gt;resto&lt;/em&gt; (mod, &lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt;), o qual quando aplicado com o parâmetro $m$ produz um valor em ${0,\dots,m-1}$ (ver Figura).&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;h(k) = k \mod m.&lt;/script&gt;

&lt;p&gt;&lt;img src=&quot;/assets/AE22CP/hash.png&quot; alt=&quot;hash&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Mas antes de finalizarmos uma implementação de tabelas hash, precisamos lidar com um importante problema. A função hash mapeia cada valor em $U$ para um valor entre $0$ e $m$, porém, como $m\ll |U|$, é inevitável que para alguns valores $k_1,k_2 \in U$, $h(k_1) = h(k_2)$, o que chamamos de &lt;em&gt;colisão&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A existência de colisões nos impede uma implementação direta de tabela hash&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Info&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chave&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Pois esse tipo de implementação somente aceitaria um dos elementos que tenham o mesmo valor de hash. Por exemplo, se houvéssemos inserido $k_1$ e posteriormente tentado inserir $k_2$, o valor de que $k_1$ que estava armazenado em &lt;code class=&quot;highlighter-rouge&quot;&gt;t[h(k1)]&lt;/code&gt; seria sobrescrito, visto que $h(k_1)=h(k_2)$.&lt;/p&gt;

&lt;p&gt;A seguir, analisaremos formas de tratar colisões, de modo que a tabela hash permita o armazenamento simultâneo de diversos itens com mesmo valor de hash.&lt;/p&gt;

&lt;h2 id=&quot;resolução-de-colisões-por-encadeamento&quot;&gt;Resolução de colisões por encadeamento&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Referências&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;CORMEN, Thomas H. et al. Algoritmos: teoria e prática. Rio de Janeiro, RJ: Campus, 2002. xvii, 916 p. ISBN 8535209263. &lt;a href=&quot;http://www.inf.ufrgs.br/~tsrodrigues/utilidades/cormem.pdf&quot;&gt;(pdf: Algoritmos - cap. 11)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;iframe width=&quot;360&quot; height=&quot;205&quot; src=&quot;https://www.youtube.com/embed/0M_kIqhwbFo&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;
&lt;/iframe&gt;

&lt;iframe width=&quot;360&quot; height=&quot;205&quot; src=&quot;https://www.youtube.com/embed/BRO7mVIFt08&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;
&lt;/iframe&gt;

</description>
        <pubDate>Tue, 07 Nov 2017 13:50:00 -0200</pubDate>
        <link>http://localhost:4000/ae22cp-172/tabelas-hash.html</link>
        <guid isPermaLink="true">http://localhost:4000/ae22cp-172/tabelas-hash.html</guid>
        
        <category>tabelas-hash</category>
        
        
        <category>AE22CP-172</category>
        
      </item>
    
      <item>
        <title>Algoritmos ótimos para Ordenação por comparação</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#introdução&quot; id=&quot;markdown-toc-introdução&quot;&gt;Introdução&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ordenação-por-comparações&quot; id=&quot;markdown-toc-ordenação-por-comparações&quot;&gt;Ordenação por comparações&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#Árvore-de-decisão&quot; id=&quot;markdown-toc-Árvore-de-decisão&quot;&gt;Árvore de decisão&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#altura-da-árvore-de-decisão&quot; id=&quot;markdown-toc-altura-da-árvore-de-decisão&quot;&gt;Altura da árvore de decisão&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#limitante-inferior&quot; id=&quot;markdown-toc-limitante-inferior&quot;&gt;Limitante Inferior&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#qual-seria-o-limitante-inferior-para-a-busca-binária&quot; id=&quot;markdown-toc-qual-seria-o-limitante-inferior-para-a-busca-binária&quot;&gt;Qual seria o limitante inferior para a busca binária?&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;introdução&quot;&gt;Introdução&lt;/h1&gt;

&lt;p&gt;Até então discutimos vários algoritmo de ordenação como alternativas para solucionar o mesmo problema. Dada uma sequência numérica $x_1,\dots,x_n$, reordenar a sequência de modo a produzir uma nova que respeite uma relação de ordem:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x_i \leq x_{i+1}, \qquad i=1,\dots,n-1&lt;/script&gt;

&lt;p&gt;A comparação de eficiência entre os algoritmos discutidos tem sido feita considerando principalmente o pior caso de cada um, ou seja, sequências de entrada que levam esses algoritmos a terem seu pior desempenho, seja em tempo de execução ou número de comparações. Tal comparação teórica também pode ser feita em ao menos dois casos adicionais:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;melhor caso, e&lt;/li&gt;
  &lt;li&gt;caso médio.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;De forma genérica, o melhor caso de qualquer algoritmo representa tipos de entradas para as quais ele tem o seu melhor desempenho (menor número de comparações). Nos algoritmos de ordenação, isso geralmente ocorre quando a sequência já está ordenada da forma correta (ver tabela: buble sort e insertion sort).&lt;/p&gt;

&lt;p&gt;O caso médio, por outro lado, representa o comportamento médio do algoritmo em todas as entradas possíveis. O desempenho médio desses algoritmos pode ser avaliado de forma aproximada por meio de experimentos. A tabela abaixo nos indica a complexidade de cada um dos algoritmos vistos até então nesses três casos.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Algoritmo&lt;/th&gt;
      &lt;th&gt;Melhor caso&lt;/th&gt;
      &lt;th&gt;Caso médio&lt;/th&gt;
      &lt;th&gt;Pior caso&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Bubble sort&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
      &lt;td&gt;$O(n^2)$&lt;/td&gt;
      &lt;td&gt;$O(n^2)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Selection sort&lt;/td&gt;
      &lt;td&gt;$O(n^2)$&lt;/td&gt;
      &lt;td&gt;$O(n^2)$&lt;/td&gt;
      &lt;td&gt;$O(n^2)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Insertion sort&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
      &lt;td&gt;$O(n^2)$&lt;/td&gt;
      &lt;td&gt;$O(n^2)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Quicksort&lt;/td&gt;
      &lt;td&gt;$O(n \log n)$&lt;/td&gt;
      &lt;td&gt;$O(n \log n)$&lt;/td&gt;
      &lt;td&gt;$O(n^2)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Mergesort&lt;/td&gt;
      &lt;td&gt;$O(n \log n)$&lt;/td&gt;
      &lt;td&gt;$O(n \log n)$&lt;/td&gt;
      &lt;td&gt;$O(n \log n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Heapsort&lt;/td&gt;
      &lt;td&gt;$O(n \log n)$&lt;/td&gt;
      &lt;td&gt;$O(n \log n)$&lt;/td&gt;
      &lt;td&gt;$O(n \log n)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Tais resultados teóricos nos dão um bom indicativo da eficiência relativa de cada um desses algoritmos. No entanto, caso dois algoritmos tenham a mesma complexidade teórica (ex.: quicksort, mergesort e heapsort) eles não são suficientes para dizermos qual algoritmo será mais “rápido” do ponto de vista prático. Isso ocorre pois na prática existem outras características que influenciarão o desempenho do algoritmo, como exemplo, podemos citar: forma de acesso à memória, menor número de trocas, qualidade da implementação, etc.&lt;/p&gt;

&lt;p&gt;Algoritmos como o &lt;code class=&quot;highlighter-rouge&quot;&gt;quicksort&lt;/code&gt; são muito úteis na prática. Porém, como eficiência nunca é demais, podemos nos perguntar: – &lt;strong&gt;“Não existiria algoritmo mais rápido?”&lt;/strong&gt; –. O objetivo desta seção é oferecer uma resposta a essa pergunta.&lt;/p&gt;

&lt;h1 id=&quot;ordenação-por-comparações&quot;&gt;Ordenação por comparações&lt;/h1&gt;

&lt;h2 id=&quot;Árvore-de-decisão&quot;&gt;Árvore de decisão&lt;/h2&gt;
&lt;p&gt;Ao examinarmos a implementação dos algoritmos acima podemos notar algo em comum. Todos eles utilizam comparações entre pares de elementos $x_i, x_j$ para determinar a ordem relativa entre esses elementos. Obviamente, cada uma dessas comparações pode oferecer como resposta, apenas uma dentre duas possibilidades que existem como resposta:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$x_i \leq x_j$, ou&lt;/li&gt;
  &lt;li&gt;$x_j \leq x_i$.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A ordem que os elementos serão comparados, ou a quantidade de vezes que um mesmo par de elementos será comparado depende de um algoritmo específico e portanto deve ser ignorado nessa análise.&lt;/p&gt;

&lt;p&gt;O ponto mais importante seria notar que a cada comparação $x_i \leq x_j$, um determinado algoritmo ganha informação sobre a ordem relativa desses dois elementos. Se representarmos todas as possíveis sequências de comparações, temos uma estrutura chamada &lt;strong&gt;árvore binária de decisão&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/AE22CP/decision-tree.png&quot; alt=&quot;decision-tree&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Esse tipo de árvore representa as decisões tomadas por um algoritmo qualquer, em que cada nó inicia com a informação adicional obtida da comparação feita acima dele. Por exemplo, o nó &lt;code class=&quot;highlighter-rouge&quot;&gt;2:3&lt;/code&gt; (o qual representa a comparação entre $x_2$ e $x_3$) já assume que $x_1\leq x_2$.&lt;/p&gt;

&lt;h2 id=&quot;altura-da-árvore-de-decisão&quot;&gt;Altura da árvore de decisão&lt;/h2&gt;

&lt;p&gt;Os nós folhas da árvore indicam qual permutação da sequência original tornaria essa sequência ordenada de forma não decrescente. Por exemplo, &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;3,1,2&amp;gt;&lt;/code&gt;, no diz que a sequência ordenada é $x_3,x_1,x_2$.&lt;/p&gt;

&lt;p&gt;É de se esperar que um algoritmo correto permita uma resposta correta para toda possível entrada. Se os nós folhas da árvore nos dão a permutação da entrada que produz a resposta correta, então devem existir ao menos $n!$ permutações como nós folhas, uma para cada possível entrada. Sabendo disso,&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Qual seria o limitante inferior para a complexidade de qualquer algoritmo de ordenação por comparação?&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A ordenação de uma sequência é o procedimento descrito como um caminho que inicia na raíz da árvore de decisão e chega até uma de suas folhas, portanto o número total de comparações é equivalente a altura da árvore.&lt;/p&gt;

&lt;h2 id=&quot;limitante-inferior&quot;&gt;Limitante Inferior&lt;/h2&gt;

&lt;p&gt;Um limitante inferior (&lt;em&gt;lower-bound&lt;/em&gt;), como o próprio nome diz, limita por baixo a complexidade de algo. No nosso caso, esse algo é o &lt;em&gt;problema de ordenação de uma sequência&lt;/em&gt;. Como temos discutido complexidade da ordenação em termos do número de comparações, esse limitante inferior nos dará uma estimativa do menor número comparações possível, que um algoritmo teria que fazer para conseguir ordenar uma sequência qualquer. Este limitante inferior é equivalente a altura da árvore de decisão.&lt;/p&gt;

&lt;p&gt;Uma árvore binária qualquer tem, em seu $\ell$-ésimo nível, $2^\ell$ nós. Sabemos que o último nível dessa árvore deve ter no mínimo $n!$ nós, portanto, no último nível&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;n! \leq 2^\ell&lt;/script&gt;

&lt;p&gt;Aplicando o logaritmo em ambos os lados&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\log(n!) \leq \ell&lt;/script&gt;

&lt;p&gt;Não nos preocuparemos com os detalhes da demonstração, mas a partir dessa desigualdade é possível chegar ao resultado.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ell \geq n \log n&lt;/script&gt;

&lt;p&gt;O qual significa que qualquer algoritmo de ordenação baseado em comparações terá que fazer no mínimo $n \log n$ comparações.&lt;/p&gt;

&lt;h2 id=&quot;qual-seria-o-limitante-inferior-para-a-busca-binária&quot;&gt;Qual seria o limitante inferior para a busca binária?&lt;/h2&gt;

&lt;p&gt;Siga a mesma ideia descrita acima para obter um limitante inferior para busca binária.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Referências&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;CORMEN, Thomas H. Desmistificando algoritmos. 1. ed. Rio de Janeiro, RJ: Elsevier, c2014. xii, 188 p. ISBN 9788535271775.&lt;a href=&quot;https://book-store.github.io/cse/thirdyear/%5BThomas_H._Cormen%5D_Algorithms_unlocked(BookZZ.org).pdf&quot;&gt;(pdf:Algorithms Unlocked)&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CORMEN, Thomas H. et al. Algoritmos: teoria e prática. Rio de Janeiro, RJ: Campus, 2002. xvii, 916 p. ISBN 8535209263. &lt;a href=&quot;http://www.inf.ufrgs.br/~tsrodrigues/utilidades/cormem.pdf&quot;&gt;(pdf: Algoritmos)&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MIT - https://www.youtube.com/watch?v=Nz1KZXbghj8&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
&lt;iframe width=&quot;360&quot; height=&quot;205&quot; src=&quot;https://www.youtube.com/embed/Nz1KZXbghj8&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;
&lt;/iframe&gt;

&lt;iframe width=&quot;360&quot; height=&quot;205&quot; src=&quot;https://www.youtube.com/embed/tVjVaO3KD0w&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;
&lt;/iframe&gt;

</description>
        <pubDate>Mon, 06 Nov 2017 13:50:00 -0200</pubDate>
        <link>http://localhost:4000/ae22cp-172/limite-inferior-ordenacao.html</link>
        <guid isPermaLink="true">http://localhost:4000/ae22cp-172/limite-inferior-ordenacao.html</guid>
        
        <category>ordenação</category>
        
        
        <category>AE22CP-172</category>
        
      </item>
    
      <item>
        <title>Lógica de predicados - Árvores de refutação</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#introdução&quot; id=&quot;markdown-toc-introdução&quot;&gt;Introdução&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#Árvores-de-refutação&quot; id=&quot;markdown-toc-Árvores-de-refutação&quot;&gt;Árvores de refutação&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#generalização-das-Árvores-de-refutação&quot; id=&quot;markdown-toc-generalização-das-Árvores-de-refutação&quot;&gt;Generalização das Árvores de Refutação&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#quantificador-universal-forall&quot; id=&quot;markdown-toc-quantificador-universal-forall&quot;&gt;Quantificador universal ($\forall$)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#quantificador-existencial-negado-neg-exists&quot; id=&quot;markdown-toc-quantificador-existencial-negado-neg-exists&quot;&gt;Quantificador existencial negado ($\neg \exists$)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#quantificador-existencial-exists&quot; id=&quot;markdown-toc-quantificador-existencial-exists&quot;&gt;Quantificador existencial ($\exists$)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#quantificador-universal-negado-neg-forall&quot; id=&quot;markdown-toc-quantificador-universal-negado-neg-forall&quot;&gt;Quantificador universal negado ($\neg \forall$)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;introdução&quot;&gt;Introdução&lt;/h1&gt;

&lt;p&gt;Estudamos na lógica proposicional dois algoritmos principais para demonstrarmos a validade e invalidade de formas de argumentos: tabelas verdade, árvores de refutação. Deste modo, dada qualquer forma de argumento com premissas e uma conclusão&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\phi,\psi \vdash \chi&lt;/script&gt;

&lt;p&gt;é possível na lógica proposicional determinarmos se tal forma de argumento é válida ou não é valida.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Uma forma de argumento é válida&lt;/strong&gt;, se sempre que suas premissas forem verdadeiras ($\phi,\psi$) sua conclusão seja verdadeira ($\chi$)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Apesar de ineficientes em certas situações, tanto tabelas verdade quanto árvores de refutação podem, em princípio, ser utilizados para implementarmos um programa que verifique a validade de formas de argumento. Esse programa hipotético, pode tomar um tempo consideravelmente grande para chegar a uma decisão, mas ele eventualmente chegará a essa decisão, portanto diz-se que:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;A lógica proposicional é decidível&lt;/strong&gt;. Pois existem algoritmos que decidem se &lt;em&gt;qualquer&lt;/em&gt; forma de argumento é válida ou não.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Na lógica de predicados, a situação é diferente. Apesar de existirem procedimentos que nos permitem verificar a validade e invalidade de alguns tipos de formas de argumentos, não existe, e não pode existir, um procedimento que verifique &lt;em&gt;qualquer&lt;/em&gt; forma de argumento da lógica de predicados. Portanto, diz-se que:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;A lógica de predicados é indecidível&lt;/strong&gt;. Pois não existe algoritmo que decida a validade de &lt;em&gt;qualquer&lt;/em&gt; forma de argumento.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;Árvores-de-refutação&quot;&gt;Árvores de refutação&lt;/h1&gt;

&lt;p&gt;As árvores de refutação para a lógica de predicados são generalizadas pela introdução de seis novas regras, as quais tratarão fórmulas precedidas pelos quantificadores universal ou existencial. No entanto, existirão situações em que apenas as regras utilizadas na lógica proposicional serão úteis. Vejamos um exemplo:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x Fx \to \forall x Gx, \neg \forall x Gx \vdash \neg \forall x Fx&lt;/script&gt;

&lt;p&gt;Na primeira etapa da demonstração, apenas listamos as premissas e a negação da conclusão. Neste momento a árvore possui apenas um ramo contendo todas essas três fórmulas.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{lclr}
&amp; 1 &amp; \forall x Fx \to \forall x Gx &amp; \mbox{(premissa)} \\
&amp; 2&amp; \neg \forall x Gx &amp; \mbox{(premissa)} \\
&amp; 3&amp; \neg \neg \forall x Fx &amp; \mbox{(negação da conclusão)} \\
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;Como visto nas árvores de refutação da lógica proposicional, existem apenas duas regras para expansão da árvore: conjunção, disjunção. Qualquer outro operador lógico deve ser tratado por meio de fórmulas equivalentes que utilizem apenas conjunção e/ou disjunção.&lt;/p&gt;

&lt;p&gt;Neste exemplo, temos uma fórmula condicional do tipo $\phi\to\psi$, representada por $\forall x Fx \to \forall x Gx$, devemos então utilizar em seu lugar uma fórmula equivalente. Como $\phi\to\psi \dashv\vdash \neg\phi\lor\psi$, podemos utilizar a equivalência.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{lclr}
\checkmark&amp;  1&amp; \forall x Fx \to \forall x Gx &amp; \mbox{(premissa)} \\
&amp; 2&amp; \neg \forall x Gx &amp; \mbox{(premissa)} \\
&amp; 3&amp; \neg \neg \forall x Fx &amp; \mbox{(negação da conclusão)} \\
&amp; 4&amp; \neg \forall x Fx \lor \forall x Gx &amp; \mbox{(Equivalência de 1)}\\
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;Das três fórmulas restantes não marcadas, apenas aquela na linha 4 pode ser expandida, para tal aplicamos a regra da disjunção, a qual cria dois ramos, um para cada disjuncto.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{lclr}
\checkmark&amp; 1 &amp; \forall x Fx \to \forall x Gx &amp; \mbox{(premissa)} \\
&amp; 2&amp; \neg \forall x Gx &amp; \mbox{(premissa)} \\
&amp; 3&amp; \neg \neg \forall x Fx &amp; \mbox{(negação da conclusão)} \\
\checkmark&amp; 4&amp; \neg \forall x Fx \lor \forall x Gx &amp; \mbox{(Equivalência de 1)}\\
&amp; 5&amp; \neg \forall x Fx \qquad\qquad \forall x Gx&amp; \mbox{(Regra da disjunção)}\\
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;Neste momento, encontramos uma contradição em cada um dos ramos.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{lclr}
\checkmark&amp; 1 &amp; \forall x Fx \to \forall x Gx &amp; \mbox{(premissa)} \\
&amp; 2&amp; \neg \forall x Gx &amp; \mbox{(premissa)} \\
&amp; 3&amp; \neg \neg \forall x Fx &amp; \mbox{(negação da conclusão)} \\
\checkmark&amp;4&amp; \neg \forall x Fx \lor \forall x Gx &amp; \mbox{(Equivalência de 1)}\\
&amp; 5&amp; \neg \forall x Fx \qquad \forall x Gx&amp; \mbox{(Regra da disjunção)}\\
&amp; 6&amp; \perp (5,3) \qquad \perp(5,2) &amp; \\
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;As contradições fecharam todos os ramos, portanto essa é uma forma de argumento válida, significando que sempre que $\forall x Fx \to \forall x Gx$ e $\neg \forall x Gx$ forem verdadeiras, então $\neg \forall x Fx$ também será verdadeira. Esta fórmula é a versão em lógica de predicados da regra &lt;em&gt;Modus Tollens&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&quot;generalização-das-Árvores-de-refutação&quot;&gt;Generalização das Árvores de Refutação&lt;/h1&gt;

&lt;h2 id=&quot;quantificador-universal-forall&quot;&gt;Quantificador universal ($\forall$)&lt;/h2&gt;

&lt;p&gt;Se uma fórmla $\forall x Fx$ aparece num ramo aberto da árvore de refutação, e $a$ é uma letra nominal que aparece numa fórmula desse ramo, então podemos instanciar a fórmula, obtendo: $Fa$. Diferente do que ocorreria para as demais regras, a fórmula $\forall x Fx$ não é marcada com $\checkmark$ neste caso, pois ela pode ser instanciada novamente com outras letras nominais que também apareçam no mesmo ramo. Apenas nos casos em que não existam letras nominais no ramo é que uma letra pode ser introduzida.&lt;/p&gt;

&lt;p&gt;Demonstre a validade ou invalidade das seguintes forma de argumento.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x (Fx \to Gx), \forall x Fx \vdash Ga&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Fa\to Gb, \forall x \neg Fx \vdash \neg Gb&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x (Fx \to Gx), \forall x Gx \vdash Fa&lt;/script&gt;

&lt;h2 id=&quot;quantificador-existencial-negado-neg-exists&quot;&gt;Quantificador existencial negado ($\neg \exists$)&lt;/h2&gt;

&lt;p&gt;Se uma fórmula da forma $\neg \exists x Fx$ aparece num ramo aberto, ela deverá ser marcada e substituída por sua equivalente $\forall x\neg Fx$ no final de cada ramo aberto que a contém. $\neg \exists x Fx \dashv \vdash \forall x \neg Fx$&lt;/p&gt;

&lt;p&gt;Demonstre a validade ou invalidade das seguintes forma de argumento.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x (Fx \to Gx), \neg \exists x Gx \vdash \neg Fa&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x(Fx \land Gx) \vdash \neg Fa&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x Fx \to \forall x Gx, \neg \exists x Gx \vdash \exists x \neg Fx&lt;/script&gt;

&lt;h2 id=&quot;quantificador-existencial-exists&quot;&gt;Quantificador existencial ($\exists$)&lt;/h2&gt;

&lt;p&gt;Se uma fórmula da forma $\exists x Fx$ aparece num ramo aberto, ela deve ser marcada. Escolhemos então, uma letra nominal $a$ que ainda não apareceu no mesmo ramo e instanciamos a fórmula, como $Fa$, no final de todo ramo aberto que a contenha.&lt;/p&gt;

&lt;h2 id=&quot;quantificador-universal-negado-neg-forall&quot;&gt;Quantificador universal negado ($\neg \forall$)&lt;/h2&gt;

&lt;p&gt;Se uma fórmula da forma $\neg \forall x Fx$ aparece num ramo aberto, ela deve ser marcada e substituída por sua equivalente $\exists x \neg Fx$.&lt;/p&gt;

&lt;p&gt;Demonstre a validade ou invalidade das seguintes forma de argumento.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists x Fx \vdash \forall x Fx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists x (Fx \land Gx) \vdash \exists Fx \land \exists Gx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists x Fx, \exists x Gx \vdash \exists x(Fx \land Gx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \neg(\exists x Fx \land \forall x \neg Fx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \exists y Lxy \vdash Laa&lt;/script&gt;

</description>
        <pubDate>Wed, 01 Nov 2017 10:20:00 -0200</pubDate>
        <link>http://localhost:4000/lc21cp-172/logica-predicados-arvores-de-refutacao.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/logica-predicados-arvores-de-refutacao.html</guid>
        
        <category>predicados</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
      <item>
        <title>Filas de prioridades e Ordenação - Heapsort</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#introdução&quot; id=&quot;markdown-toc-introdução&quot;&gt;Introdução&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#filas-de-prioridades&quot; id=&quot;markdown-toc-filas-de-prioridades&quot;&gt;Filas de prioridades&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#heap&quot; id=&quot;markdown-toc-heap&quot;&gt;Heap&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;introdução&quot;&gt;Introdução&lt;/h1&gt;

&lt;p&gt;Para compreendermos o significado e a utilidade de &lt;em&gt;filas de prioridade&lt;/em&gt;, vamos utilizar como referência inicial o algoritmo de ordenação &lt;em&gt;selection sort&lt;/em&gt;. Esse algoritmo de ordenação funciona de forma bastante intuitiva&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;A cada passo, selecione o menor elemento e o insira na posição adequada.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Se assumirmos que o objetivo seja ordenar a sequência de forma crescente, o menor elemento deve ser inserido na parte inicial da sequência. Na primeira iteração, portanto, o menor elemento de toda a sequência será identificado e inserido na posição zero. Na segunda iteração, o próximo menor elemento será identificado e inserido na posição um, até que toda a sequência esteja ordenada.&lt;/p&gt;

&lt;p&gt;Podemos perceber que em todo o procedimento acima descrito, a etapa principal é a identificação do menor elemento da sequência. Uma forma simples de implementarmos essa ideia seria uma função &lt;code class=&quot;highlighter-rouge&quot;&gt;min&lt;/code&gt;, que retorna o índice do menor elemento num intervalo de $i$ a $f$.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;menor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;menor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;menor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;menor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Utilizando a função &lt;code class=&quot;highlighter-rouge&quot;&gt;min&lt;/code&gt;, o algoritmo de ordenação selection sort se torna bastante simples.&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;selectsort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Observemos que a repetição do laço &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; em &lt;code class=&quot;highlighter-rouge&quot;&gt;selectsort&lt;/code&gt; acontece $n$ vezes. Em cada uma dessas vezes, a função &lt;code class=&quot;highlighter-rouge&quot;&gt;min&lt;/code&gt; é chamada para identificar o menor elemento. Na primeira chamada, &lt;code class=&quot;highlighter-rouge&quot;&gt;min&lt;/code&gt; tem que percorrer toda a sequência para identificar o menor elemento, ou seja $n-1$ comparações. Na segunda chamada, &lt;code class=&quot;highlighter-rouge&quot;&gt;min&lt;/code&gt; terá que percorrer um elemento a menos, pois o primeiro já foi identificado, ou seja, $n-2$ comparações.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{lr}
[9 &amp; 8 &amp; 1 &amp; 2 &amp; 3 &amp; 7 &amp; 9 &amp; 0] &amp; i=0 &amp; O(n-1)\\
0 &amp; [8 &amp; 1 &amp; 2 &amp; 3 &amp; 7 &amp; 9 &amp; 9] &amp; i=1 &amp;  O(n-2)\\
0 &amp; 1 &amp; [8 &amp; 2 &amp; 3 &amp; 7 &amp; 9 &amp; 9] &amp; i=2 &amp;  O(n-3)\\
0 &amp; 1 &amp; 2 &amp; [8 &amp; 3 &amp; 7 &amp; 9 &amp; 9] &amp; i=3 &amp;  O(n-4)\\
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;Para contabilizarmos todas as etapas efetuadas por &lt;code class=&quot;highlighter-rouge&quot;&gt;min&lt;/code&gt;, basta somar o número de comparações feito em cada uma delas.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(n-1) + (n-2) + \dots + (1) = \sum_{i=1}^n (n-i)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\sum_{i=1}^n (n-i) = n(n+1)/2 = O(n^2)&lt;/script&gt;

&lt;h1 id=&quot;filas-de-prioridades&quot;&gt;Filas de prioridades&lt;/h1&gt;
&lt;p&gt;A análise simples do selection sort, nos indica claramente que o maior processamento feito por este algoritmo ocorre durante a identificação do menor elemento da sequência. Sendo o custo de &lt;code class=&quot;highlighter-rouge&quot;&gt;min&lt;/code&gt; determinante para o custo total do algoritmo. Em cada iteração, o único objetivo é identificar o elemento mínimo, o que nos leva a uma pergunta.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Não haveria uma estrutura de dados que nos permitisse sempre obter o menor elemento de forma mais rápida do que a feita por &lt;code class=&quot;highlighter-rouge&quot;&gt;min&lt;/code&gt;?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Uma das respostas para essa pergunta são as filas de prioridades. Tais estruturas tem como principal objetivo organizar os dados de modo que obter o mínimo/máximo elemento seja tão rápido quanto possível. Diferentemente das filas comuns, em que a ordem de inserção de um elemento determina sua ordem de remoção, nas filas de prioridade é a prioridade que determina a ordem de saída de um elemento. A prioridade, no caso mais simples é o próprio valor do elemento.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;selectsort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;heap&quot;&gt;Heap&lt;/h2&gt;

</description>
        <pubDate>Mon, 30 Oct 2017 13:50:00 -0200</pubDate>
        <link>http://localhost:4000/ae22cp-172/heapsort.html</link>
        <guid isPermaLink="true">http://localhost:4000/ae22cp-172/heapsort.html</guid>
        
        <category>ordenação</category>
        
        
        <category>AE22CP-172</category>
        
      </item>
    
      <item>
        <title>Lógica de predicados - Identidade</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#identidades&quot; id=&quot;markdown-toc-identidades&quot;&gt;Identidades&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplos&quot; id=&quot;markdown-toc-exemplos&quot;&gt;Exemplos&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#introdução-da-identidade&quot; id=&quot;markdown-toc-introdução-da-identidade&quot;&gt;Introdução da identidade&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplos-1&quot; id=&quot;markdown-toc-exemplos-1&quot;&gt;Exemplos&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#eliminação-da-identidade&quot; id=&quot;markdown-toc-eliminação-da-identidade&quot;&gt;Eliminação da identidade&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;identidades&quot;&gt;Identidades&lt;/h1&gt;

&lt;p&gt;Na lógica de predicados podemos definir um predicado $I(x,y)$ para denotar a igualdade entre $x$ e $y$.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$I(x,y)$: $x$ igual a $y$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;No entanto, por esse predicado ser de uso bastante comum, se torna às vezes conveniente representá-lo de forma mais compacta. O mesmo aconteceria se quiséssemos definir um predicado $M(x,y)$ para denotar $x$ é menor que $y$. Como tais predicados são comumente representado pelos símbolos $=$ e $&amp;lt;$ não há motivos para que não utilizemos os mesmos símbolos também na linguagem da lógica de predicados.&lt;/p&gt;

&lt;p&gt;Enquanto a letra ‘I’ pode ser utilizada para denotar o predicado de igualdade/identidade, ou seja $I(x,y)$ indicando a igualdade entre $x$ e $y$; ela também poderia ser utilizada em outras situações para denotar outro predicado qualquer, exemplo $I(x)$ indicando que $x$ é impar. Por outro lado, o símbolo ‘=’ também representa o predicado identidade, no entanto, ele nunca assumirá um significado diferente, ou seja, é um símbolo específico para representar o predicado de igualdade.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$x=y$: $x$ igual a $y$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Diferentemente dos demais predicados, $=$ é utilizado na forma infixa, ou seja, entre os operandos. Isso facilita pois mantém a forma de representação convencionalmente utilizada nas demais áreas da matemática.&lt;/p&gt;

&lt;h2 id=&quot;exemplos&quot;&gt;Exemplos&lt;/h2&gt;

&lt;p&gt;Formalize as seguintes sentenças utilizando o predicado identidade ‘$=$’&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$a$: Álvaro de Campos&lt;/li&gt;
  &lt;li&gt;$t$: Tabacaria&lt;/li&gt;
  &lt;li&gt;$f$: Fernando Pessoa&lt;/li&gt;
  &lt;li&gt;$A(x)$: $x$ é um autor português&lt;/li&gt;
  &lt;li&gt;$M(x,y)$: $x$ é melhor autor que $y$&lt;/li&gt;
  &lt;li&gt;$E(x,y)$: $x$ escreveu $y$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;a. Fernando Pessoa não é Álvaro de Campos&lt;/p&gt;

&lt;p&gt;b. Existe Fernando Pessoa&lt;/p&gt;

&lt;p&gt;c. Se Fernando Pessoa é Álvaro de Campos, então Álvaro de Campos escreveu Tabacaria&lt;/p&gt;

&lt;p&gt;d. Somente Fernando Pessoa escreveu Tabacaria&lt;/p&gt;

&lt;p&gt;e. Fernando Pessoa é o melhor autor português&lt;/p&gt;

&lt;p&gt;f. Existem ao menos duas coisas diferentes.&lt;/p&gt;

&lt;p&gt;g. Existe somente uma coisa.&lt;/p&gt;

&lt;p&gt;h. Existem exatamente duas coisas.&lt;/p&gt;

&lt;h2 id=&quot;introdução-da-identidade&quot;&gt;Introdução da identidade&lt;/h2&gt;

&lt;p&gt;Para qualquer letra nominal $\alpha$, podemos sempre introduzir a identidade $\alpha = \alpha$. Esse tipo de regra é útil para produzir exemplos para outras regras de derivação. Considere, por exemplo, a introdução dos quantificadores universal e existencial, a introdução de ambos depende da existência de um exemplo.&lt;/p&gt;

&lt;p&gt;Para o quantificador universal, esse exemplo deve utilizar uma letra nominal genérica, de modo que seja possível generalizar a afirmação. Nesse caso, uma instância/exemplo $Fa\land Ga$ pode ser generalizada à $\forall x (Fx \land Gx)$, desde que não haja restrições quanto à letra $a$.&lt;/p&gt;

&lt;p&gt;Para o quantificador existencial, por outro lado, o funcionamento é mais simples. Se tivermos um exemplo, então podemos generalizá-lo. Deste modo, a partir de $(Fa\land Ga)$ podemos imediatamente concluir $\exists x(Fx \land Gx)$.&lt;/p&gt;

&lt;h3 id=&quot;exemplos-1&quot;&gt;Exemplos&lt;/h3&gt;

&lt;p&gt;Dada a interpretação acima, como demonstraríamos os seguintes argumentos?&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall x (x=x)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \exists x (a=x)&lt;/script&gt;

&lt;h2 id=&quot;eliminação-da-identidade&quot;&gt;Eliminação da identidade&lt;/h2&gt;

&lt;p&gt;A regra de eliminação da identidade é apenas uma formalização da nossa intuição. Se duas coisas são iguais, posso utilizar tanto uma quanto a outra em qualquer situação.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Fa, a=b \vdash Fb&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Fa, \neg Fb \vdash \neg (a = b)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall x \forall y (x=y)\to(y=x)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall x \forall y \forall z (x=y\land y=z)\to (x=z))&lt;/script&gt;
</description>
        <pubDate>Thu, 26 Oct 2017 10:20:00 -0200</pubDate>
        <link>http://localhost:4000/lc21cp-172/lp-identidade.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/lp-identidade.html</guid>
        
        <category>predicados</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
      <item>
        <title>PROVA 2 - sub</title>
        <description>&lt;p&gt;&lt;strong&gt;NOME:&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;equivalências&quot;&gt;Equivalências&lt;/h1&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;eq.1&lt;/td&gt;
      &lt;td&gt;$\phi\to\psi$&lt;/td&gt;
      &lt;td&gt;$\neg\phi\lor\psi$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;eq.2&lt;/td&gt;
      &lt;td&gt;$\phi\leftrightarrow\psi$&lt;/td&gt;
      &lt;td&gt;$(\phi\land\psi)\lor(\neg\phi\land\neg\psi)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;eq.3&lt;/td&gt;
      &lt;td&gt;$\neg(\phi\land\psi)$&lt;/td&gt;
      &lt;td&gt;$\neg\phi \lor \neg \psi$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;eq.4&lt;/td&gt;
      &lt;td&gt;$\neg(\phi\lor\psi)$&lt;/td&gt;
      &lt;td&gt;$\neg\phi\land\neg\psi$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;eq.5&lt;/td&gt;
      &lt;td&gt;$\neg(\phi\to\psi)$&lt;/td&gt;
      &lt;td&gt;$\phi\land \neg \psi$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;eq.6&lt;/td&gt;
      &lt;td&gt;$\neg(\phi\leftrightarrow\psi)$&lt;/td&gt;
      &lt;td&gt;$(\phi\land \neg\psi)\lor (\neg\phi\land\psi)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;(2,0pts)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; Verifique se as formas de argumento a seguir são válidas ou inválidas utilizando árvores de refutação.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \to \neg q \vdash \neg (p\land q)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p\lor q, \neg p, \neg q \vdash r&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash (p\to q) \leftrightarrow \neg (p \land \neg q)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg (p\lor q), r\leftrightarrow p \vdash  r&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p\leftrightarrow q, \neg(q \leftrightarrow r) \vdash p \leftrightarrow r&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;(2,0pts)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; Utilize árvores de refutação para determinar quais das fórmulas a seguir são satifazíveis ou insatisfatíveis.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg((p\land q) \leftrightarrow(p\lor q))&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \leftrightarrow \neg(p\lor q)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\land q) \land \neg(p\lor r)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg ((p\to(q\land r)) \to (p\to r))&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;(2,0pt)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; Reescreva as sentenças a seguir como fórmulas da lógica de predicados. Utilize os predicados:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$G(x,y)$ : $x$ ganha de $y$&lt;/li&gt;
  &lt;li&gt;$F(x)$ : $x$ é um time de futebol&lt;/li&gt;
  &lt;li&gt;$Z(x,y)$: $x$ é zagueiro de $y$&lt;/li&gt;
  &lt;li&gt;$P(x,y)$: $x$ perde para $y$&lt;/li&gt;
  &lt;li&gt;“c”: Coritiba&lt;/li&gt;
  &lt;li&gt;“j”: Joinville&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;a. Todo time de futebol tem um zagueiro&lt;/p&gt;

&lt;p&gt;b. Se o Joinville ganha do Coritiba, então o Joinville não perde para todos os times de futebol&lt;/p&gt;

&lt;p&gt;c. O Coritiba ganha de algum time de futebol.&lt;/p&gt;

&lt;p&gt;d. O Joinville ganhha de algum time que ganha do Coritiba&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(1,0pts)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; a) Descreva em linguagem natural cada uma das fórmulas. b) Reescreva as fórmulas utilizando outro quantificador.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \forall x \neg Fx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists x \neg Fx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \neg Fx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x \neg Fx&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;(3,0pts)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt; Demonstre 5 das seguintes formas de argumento da lógica de predicados.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists x Fx \vdash \exists x \exists y(Fx \land Fy)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(Fx \leftrightarrow r), r \vdash Fa&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \forall x(Fx \land Gx) \vdash \exists x(\neg Fx \lor \neg Gx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x \exists y Lxy \vdash \forall x \neg Lxx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(Fx \to Gx) \vdash \exists x Fx \to \exists x Gx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \forall y(Fxy \to \neg Fyx) \vdash \forall x \neg Fxx&lt;/script&gt;

</description>
        <pubDate>Wed, 25 Oct 2017 10:20:00 -0200</pubDate>
        <link>http://localhost:4000/lc21cp-172/PROVA2-sub.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/PROVA2-sub.html</guid>
        
        <category>predicados</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
      <item>
        <title>PROVA 2</title>
        <description>&lt;p&gt;&lt;strong&gt;NOME:&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;equivalências&quot;&gt;Equivalências&lt;/h1&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;$\phi\to\psi$&lt;/td&gt;
      &lt;td&gt;$\neg\phi\lor\psi$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;$\phi\leftrightarrow\psi$&lt;/td&gt;
      &lt;td&gt;$(\phi\land\psi)\lor(\neg\phi\land\neg\psi)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;$\neg(\phi\land\psi)$&lt;/td&gt;
      &lt;td&gt;$\neg\phi \lor \neg \psi$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;$\neg(\phi\lor\psi)$&lt;/td&gt;
      &lt;td&gt;$\neg\phi\land\neg\psi$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;$\neg(\phi\to\psi)$&lt;/td&gt;
      &lt;td&gt;$\phi\land \neg \psi$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;$\neg(\phi\leftrightarrow\psi)$&lt;/td&gt;
      &lt;td&gt;$(\phi\land \neg\psi)\lor (\neg\phi\land\psi)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;(2,0pts)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; Verifique se as formas de argumento a seguir são válidas ou inválidas utilizando árvores de refutação.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \vdash (p\to (q\land p)) \to (p\land q)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(q\land r)\to p, \neg q, \neg r \vdash \neg p&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg(p\land q), r \leftrightarrow p \vdash \neg r&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p\leftrightarrow q, q \leftrightarrow r \vdash p \leftrightarrow r&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;(2,0pts)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; Verifique se as fórmulas a seguir são tautologias utilizando árvores de refutação.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p \leftrightarrow \neg(p\lor q)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\land q) \land \neg(p\lor r)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\land q) \to p&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg((p\land q) \leftrightarrow(p\lor q))&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(p\to(q\land r)) \to (p\to r)&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;(1,0pt)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; Reescreva as sentenças a seguir como fórmulas da lógica de predicados. Utilize os predicados:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$A(x,y)$ : $x$ ama $y$&lt;/li&gt;
  &lt;li&gt;$L(x,y)$ : $x$ é mais alto que $y$&lt;/li&gt;
  &lt;li&gt;“Benedito”: $b$&lt;/li&gt;
  &lt;li&gt;“Cassandra”: $c$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;a. Para quaisquer três objetos, se o primeiro é mais alto que o segundo e o segundo mais alto que o terceiro, então o primeiro é mais alto que o terceiro.&lt;/p&gt;

&lt;p&gt;b. Todo mundo é amado por alguém&lt;/p&gt;

&lt;p&gt;c. Benedito e Cassandra amam todo mundo.&lt;/p&gt;

&lt;p&gt;d. Se alguém ama o Benedito então Cassandra ama esse alguém.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(4,0pts)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; Demonstre 5 das seguintes formas de argumento da lógica de predicados.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x (Fx \land Gx) \vdash \forall x (Fx \to \neg Gx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(\neg Fx \lor \neg Gx) \vdash \neg(Fa \land Ga)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(Fx \to Gx) \vdash \forall x(\neg Gx \to \neg Fx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \forall y(Fxy \to \neg Fyx) \vdash \forall x \neg Fxx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x (Fx \land Gx) \vdash \forall x (\neg Fx \lor \neg Gx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \forall x(Fx \land Gx) \vdash \exists x(\neg Fx \lor \neg Gx)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x \exists y Lxy \vdash \forall x \neg Lxx&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;(1,0pts)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt; Descreva em linguagem natural cada uma das fórmulas e as reescreva utilizando outro quantificador&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \forall x \neg Fx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists x \neg Fx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \neg Fx&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \exists x \neg Fx&lt;/script&gt;

</description>
        <pubDate>Wed, 25 Oct 2017 10:20:00 -0200</pubDate>
        <link>http://localhost:4000/lc21cp-172/PROVA2.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/PROVA2.html</guid>
        
        <category>predicados</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
      <item>
        <title>APS3 - Algoritmos de ordenação</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#objetivos&quot; id=&quot;markdown-toc-objetivos&quot;&gt;Objetivos&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#motivação&quot; id=&quot;markdown-toc-motivação&quot;&gt;Motivação&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#experimentos&quot; id=&quot;markdown-toc-experimentos&quot;&gt;Experimentos&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#cenários-de-experimentação&quot; id=&quot;markdown-toc-cenários-de-experimentação&quot;&gt;Cenários de experimentação&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#experimentos-1&quot; id=&quot;markdown-toc-experimentos-1&quot;&gt;Experimentos&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#análise-dos-resultados&quot; id=&quot;markdown-toc-análise-dos-resultados&quot;&gt;Análise dos resultados&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#nomenclatura-de-arquivos&quot; id=&quot;markdown-toc-nomenclatura-de-arquivos&quot;&gt;Nomenclatura de arquivos&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;objetivos&quot;&gt;Objetivos&lt;/h1&gt;

&lt;p&gt;Comparar experimentalmente os algoritmos de ordenação em diferentes cenários. Identificar a relação entre os tipos de entradas e a eficiência desses algoritmos.&lt;/p&gt;

&lt;h1 id=&quot;motivação&quot;&gt;Motivação&lt;/h1&gt;

&lt;p&gt;Aprender a identificar qual algoritmo utilizar para ordenação de dados em um determinado contexto.&lt;/p&gt;

&lt;h1 id=&quot;experimentos&quot;&gt;Experimentos&lt;/h1&gt;

&lt;p&gt;Todos algoritmos deverão ser executados para os mesmos casos de teste e depois comparados quanto ao&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;tempo médio&lt;/strong&gt;,&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;número de comparações&lt;/strong&gt;,&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;número de trocas&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Deste modo, a primeira etapa do trabalho consiste em adaptar seus códigos para que a cada execução esses três dados sejam coletados/contabilizados.&lt;/p&gt;

&lt;h1 id=&quot;cenários-de-experimentação&quot;&gt;Cenários de experimentação&lt;/h1&gt;

&lt;p&gt;Os algoritmos serão avaliados em quatro cenários. Cada cenário representará um tipo de sequência de entrada.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Sequências aleatórias,&lt;/li&gt;
  &lt;li&gt;Sequências ordenadas de forma crescente&lt;/li&gt;
  &lt;li&gt;Sequências ordenadas de forma decrescente&lt;/li&gt;
  &lt;li&gt;Sequências quase ordenadas&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Consideraremos que uma sequência quase ordenada é gerada por dois passos principais.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Gerar uma sequência ordenada,&lt;/li&gt;
  &lt;li&gt;Efetuar um certo número de trocas aleatórias
    - O número de trocas deve equivaler a 15% do tamanho da sequência.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;experimentos-1&quot;&gt;Experimentos&lt;/h1&gt;

&lt;p&gt;Cada um dos cenários acima serão avaliados seguindo o mesmo planejamento de experimentos. Como exemplo, podemos considerar o caso de sequências &lt;em&gt;aleatórias&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Queremos avaliar o desempenho dos algoritmos para sequências de tamanhos diferentes, então neste contexto a primeira etapa seria definirmos quais tamanhos de sequências farão parte dos experimentos. É importante que possamos avaliar os algoritos em sequências pequenas e grandes, portanto os tamanhos utilizados devem atender essa demanda.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sugestão de tamanhos $n(x) = 10 \times 2^x$.&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$x$&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$n$&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;40&lt;/td&gt;
      &lt;td&gt;80&lt;/td&gt;
      &lt;td&gt;160&lt;/td&gt;
      &lt;td&gt;320&lt;/td&gt;
      &lt;td&gt;640&lt;/td&gt;
      &lt;td&gt;1280&lt;/td&gt;
      &lt;td&gt;2560&lt;/td&gt;
      &lt;td&gt;5120&lt;/td&gt;
      &lt;td&gt;10240&lt;/td&gt;
      &lt;td&gt;20480&lt;/td&gt;
      &lt;td&gt;40960&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Os experimentos terão que ser repetidos para cada $n$.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Vamos assumir, como exemplo, o caso de $n=20$. Cada algoritmo deverá ser executado em sequências de tamanho $n$, porém, como estamos estamos interessados no comportamento médio do algoritmo, não podemos executá-lo apenas uma vez. Deste modo, cada algoritmo deverá ser executado um determinado número $N$ de vezes com sequências diferentes de tamanho $n$, $N$ é chamado &lt;em&gt;número de experimentos&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sugestão para o número de experimentos $N$: $30 \leq N \leq 100$.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Cada execução de um algoritmo &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; com as sequências aleatórias (&lt;code class=&quot;highlighter-rouge&quot;&gt;rand&lt;/code&gt;) de um determinado tamanho $n$ (&lt;code class=&quot;highlighter-rouge&quot;&gt;20&lt;/code&gt;), produzirá três dados:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;num. comparações&lt;/em&gt;,&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;num. trocas&lt;/em&gt;,&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;tempo&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;17823812 123213 0.2345
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;O conjunto de $N$ execuções produzirá então, um arquivo de saída &lt;code class=&quot;highlighter-rouge&quot;&gt;rand_20_A.out&lt;/code&gt;, com $N$ linhas, cada uma delas representando um experimento.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;17823812 123213 0.2345
17823812 123213 0.2345
...
17823812 123213 0.2345
17823812 123213 0.2345
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Suponha que estejamos comparando quatro algoritmos: &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;D&lt;/code&gt;. Ao repetirmos o procedimento acima para cada um deles, teremos produzido quatro arquivos:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rand_20_A.out&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rand_20_B.out&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rand_20_C.out&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rand_20_D.out&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tais nomes foram escolhidos pois são informativos sobre o experimento que eles representam. O prefixo &lt;code class=&quot;highlighter-rouge&quot;&gt;rand&lt;/code&gt; indica que a sequência foi gerada aleatoriamente, o infixo &lt;code class=&quot;highlighter-rouge&quot;&gt;20&lt;/code&gt; indica o tamanho dessas sequências, e o sufixo &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, indica o algoritmo.&lt;/p&gt;

&lt;h1 id=&quot;análise-dos-resultados&quot;&gt;Análise dos resultados&lt;/h1&gt;

&lt;p&gt;Esses arquivos contém os dados brutos dos experimentos. Podemos a partir deles iniciar a análise dos resultados. Primeiro passo é calcular a média de cada coluna. No exemplo, acima, a média de cada coluna em cada um dos arquivos produzirá três valores.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rand_20_A.out&lt;/code&gt;, média das colunas:
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;17823812 123213 0.2345
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rand_20_B.out&lt;/code&gt;, média das colunas:
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;89898923 1342213 2.2345
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rand_20_C.out&lt;/code&gt;, média das colunas:
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;123812 123213 9.2345
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rand_20_D.out&lt;/code&gt;, média das colunas:
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;948812 99213 11.2345
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Com esses novos valores (médias), podemos inciar a popular nossos gráficos, um para cada dado sendo avaliado. Nos gráficos abaixo inserimos os pontos referentes aos valores médios de &lt;em&gt;comparações&lt;/em&gt;, &lt;em&gt;trocas&lt;/em&gt; e &lt;em&gt;tempo&lt;/em&gt; obtidos para sequências crescentes de tamanho $20$. Portanto, todos os pontos ficam na mesma coluna ($n=20$).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/AE22CP/rand_20.png&quot; alt=&quot;rand_20&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ao efetuarmos esses mesmos experimentos mas agora com os demais tamanhos de sequência, teremos vários outros pontos para popular o gráfico, indicando o comportamento dos algoritmos com os diferentes tamanhos de sequência. As linhas pontilhadas são as referências teóricas de complexidade $O(n), O(n \log n)$ e $O(n^2)$ (da menos inclinada à mais inclinada).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/AE22CP/rand_20_todos.png&quot; alt=&quot;rand_20&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;nomenclatura-de-arquivos&quot;&gt;Nomenclatura de arquivos&lt;/h1&gt;

&lt;p&gt;Minha sugestão para que tenhamos um padrão de nomenclatura e organização dos arquivos da APS3 é a seguinte:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Crie um diretório (pasta) de nome igual ao seu RA: “227728/”&lt;/li&gt;
  &lt;li&gt;Dentro desse diretório insira seus códigos fonte, que deverão ter como prefixo seu “RA_”:&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Caso tenha implementados todos em um mesmo arquivo, nomeie este arquivo como “RA_sort.c”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Os arquivos produzidos para os experimentos ficarão em um subdiretório chamado “output”, exemplo:
    &lt;ul&gt;
      &lt;li&gt;“227728/output/”&lt;/li&gt;
      &lt;li&gt;Para os arquivos dos experimentos, sugiro o padrão de nomenclatura: “cenario_tamanho_algoritmo.out”&lt;/li&gt;
      &lt;li&gt;Para “cenário”, temos quatro tipos possíveis:
        &lt;ul&gt;
          &lt;li&gt;“rand”: sequências aleatórias&lt;/li&gt;
          &lt;li&gt;“cres”: sequências aleatórias crescentes&lt;/li&gt;
          &lt;li&gt;“decr”: sequências aleatórias decrescentes&lt;/li&gt;
          &lt;li&gt;“semi”: sequências aleatórias semi-ordenadas&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Para “tamanho”, temos os valores indicados na tabela no início deste documento&lt;/li&gt;
      &lt;li&gt;Para “algoritmo”, temos várias possibilidades, como as descritas a seguir.
        &lt;ul&gt;
          &lt;li&gt;Mergesort:        “merge”&lt;/li&gt;
          &lt;li&gt;Quicksort:        “quick”&lt;/li&gt;
          &lt;li&gt;Selectionsort:    “selct”&lt;/li&gt;
          &lt;li&gt;Insertionsort:    “insrt”&lt;/li&gt;
          &lt;li&gt;Bubblesort:       “bubbl”&lt;/li&gt;
          &lt;li&gt;Heapsort:         “heaps”&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Esses padrões de nomenclatura nos dão uma melhor organização, e me permite automatizar a verificação de suas submissões, o que se torna inviável caso contrário&lt;/strong&gt;.&lt;/p&gt;
</description>
        <pubDate>Fri, 20 Oct 2017 13:50:00 -0200</pubDate>
        <link>http://localhost:4000/ae22cp-172/APS3-ordenacao.html</link>
        <guid isPermaLink="true">http://localhost:4000/ae22cp-172/APS3-ordenacao.html</guid>
        
        <category>ordenação</category>
        
        
        <category>AE22CP-172</category>
        
      </item>
    
      <item>
        <title>Lógica de predicados - Teoremas e regras de equivalência</title>
        <description>&lt;p&gt;&lt;strong&gt;Conteúdo&lt;/strong&gt;&lt;/p&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#teoremas&quot; id=&quot;markdown-toc-teoremas&quot;&gt;Teoremas&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo-1&quot; id=&quot;markdown-toc-exemplo-1&quot;&gt;Exemplo 1&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo-2&quot; id=&quot;markdown-toc-exemplo-2&quot;&gt;Exemplo 2&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo-3&quot; id=&quot;markdown-toc-exemplo-3&quot;&gt;Exemplo 3&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#equivalências&quot; id=&quot;markdown-toc-equivalências&quot;&gt;Equivalências&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo-1-1&quot; id=&quot;markdown-toc-exemplo-1-1&quot;&gt;Exemplo 1&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo-2-1&quot; id=&quot;markdown-toc-exemplo-2-1&quot;&gt;Exemplo 2&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo-3-1&quot; id=&quot;markdown-toc-exemplo-3-1&quot;&gt;Exemplo 3&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#intercâmbio-de-quantificadores&quot; id=&quot;markdown-toc-intercâmbio-de-quantificadores&quot;&gt;Intercâmbio de quantificadores&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#variáveis-abertas-e-fechadas&quot; id=&quot;markdown-toc-variáveis-abertas-e-fechadas&quot;&gt;Variáveis abertas e fechadas&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#exemplo&quot; id=&quot;markdown-toc-exemplo&quot;&gt;Exemplo&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#qual-a-utilidade&quot; id=&quot;markdown-toc-qual-a-utilidade&quot;&gt;Qual a utilidade?&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#exemplo-1&quot; id=&quot;markdown-toc-exemplo-1&quot;&gt;Exemplo&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;teoremas&quot;&gt;Teoremas&lt;/h1&gt;

&lt;p&gt;Assim como na lógica proposicional, existem fórmulas na lógica de predicados que podem ser demonstradas sem a necessidade de premissas. Tais fórmulas, chamadas &lt;em&gt;teoremas&lt;/em&gt;, são verdades lógicas, ou seja sua verdade é necessária de acordo com as regras da lógica de predicados. Todos os teoremas da lógica proposicional são, também, teoremas na lógica de predicados.&lt;/p&gt;

&lt;h2 id=&quot;exemplo-1&quot;&gt;Exemplo 1&lt;/h2&gt;

&lt;p&gt;O condicional quando aplicado a antecedente e consequente iguais é um teorema na lógica proposicional, $p \to p$, sendo portanto representado em forma de argumento sem premissas&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash p \to p \alpha 3&lt;/script&gt;

&lt;p&gt;Na lógica de predicados temos a versão generalizada deste teorema, a qual é produzida pela introdução do quantificador universal.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall x (Fx\to Fx)&lt;/script&gt;

&lt;p&gt;A demonstração deste teorema segue a estratégia utilizada para demonstrarmos qualquer condicional. Assumimos como hipótese o antecedente e derivamos o consequente.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; Fa                   &amp;   \mbox{Hipótese para prova do condicional}\\
2 &amp; Fa\to Fa     &amp;  \mbox{Introdução do condicional 1}\\
3 &amp; \forall x (Fx\to Fx)             &amp;   \mbox{Introdução do universal em 2}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h2 id=&quot;exemplo-2&quot;&gt;Exemplo 2&lt;/h2&gt;

&lt;p&gt;Provemos o seguinte teorema:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall x Fx \to Fa&lt;/script&gt;

&lt;p&gt;A estratégia de demonstração é a mesma, basta observarmos que $Fa$ é uma instância da fórmula generalizada $\forall x Fx$. Portanto&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall x Fx                   &amp;   \mbox{Hipótese para prova do condicional}\\
2 &amp; \qquad Fa     &amp;  \mbox{Eliminação do universal em 1}\\
3 &amp; \forall x Fx\to Fa             &amp;   \mbox{Prova do condicional 1-2}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h2 id=&quot;exemplo-3&quot;&gt;Exemplo 3&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \neg(\forall x Fx \land \exists x \neg Fx)&lt;/script&gt;

&lt;p&gt;Neste exemplo, não é evidente qual regra de derivação utilizar. Seguindo a estratégia já mencionada anteriormente, tentaremos a demonstração por redução ao absurdo. Assumindo a negação da conclusão como hipótese&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{llr}
1 &amp; \forall x Fx \land \exists x \neg Fx    &amp;   \mbox{Hipótese para redução ao absurdo}\\
2 &amp; \qquad \forall x Fx     &amp;  \mbox{Eliminação do condicional em 1}\\
3 &amp; \qquad \exists x \neg Fx     &amp;  \mbox{Eliminação do condicional em 1}\\
4 &amp; \qquad\quad \neg Fa          &amp;   \mbox{Hipótese para eliminação do existencial}\\
5 &amp; \qquad\quad Fa              &amp;    \mbox{Eliminação do universal em 2}\\
6 &amp; \qquad\quad p \land \neg p    &amp;  \mbox{Pela contradição de } Fa\\
7 &amp; \qquad p \land \neg p &amp; \mbox{Eliminação do existencial 4-6}\\
8 &amp; \neg(\forall x Fx \land \exists x \neg Fx) &amp; \mbox{Redução a absurdo 1-7}
\end{array} %]]&gt;&lt;/script&gt;

&lt;h1 id=&quot;equivalências&quot;&gt;Equivalências&lt;/h1&gt;

&lt;p&gt;Assim como vimos para as árvores de refutação da lógica proposicional, nem sempre uma fórmula é facilmente demonstrável ou derivavel. Em alguns desses casos, no entanto, a utilização de uma fórmula equivalente facilita consideravelmente o trabalho.&lt;/p&gt;

&lt;p&gt;Para ilustrar essa ideia, como demonstraríamos o teorema a seguir?&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall x Fx \lor \exists x \neg Fx&lt;/script&gt;

&lt;p&gt;Não é evidente quais regras aplicar, visto que não temos premissas, a regra de eliminação ou introdução da disjunção não são aplicáveis. Podemos então tentar substituir essa fórmula por uma equivalente, mas qual utilizar? Na lógica proposicional demonstramos a equivalência $p \to q \dashv\vdash \neg p \lor q$, seria essa quivalência válida na lógica de predicados.&lt;/p&gt;

&lt;h2 id=&quot;exemplo-1-1&quot;&gt;Exemplo 1&lt;/h2&gt;

&lt;p&gt;Demonstre a equivalência&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x Fx \lor \exists x \neg Fx \dashv\vdash \neg\forall x Fx \to \exists x \neg Fx&lt;/script&gt;

&lt;p&gt;Dada a equivalência acima, demonstrar o teorema $\vdash \forall x Fx \lor \exists x \neg Fx$ é equivalente a demonstrar sua equivalência&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \neg\forall x Fx \to \exists x \neg Fx&lt;/script&gt;

&lt;h2 id=&quot;exemplo-2-1&quot;&gt;Exemplo 2&lt;/h2&gt;

&lt;p&gt;Demonstre a equivalência&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x(Fx \to \neg Gx) \dashv\vdash \neg \exists x(Fx \land Gx)&lt;/script&gt;

&lt;h2 id=&quot;exemplo-3-1&quot;&gt;Exemplo 3&lt;/h2&gt;

&lt;p&gt;Demonstre as equivalências&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \forall x \neg Fx \dashv \vdash \exists x Fx \label{eq:1}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \forall x Fx \dashv \vdash \exists x \neg Fx \label{eq:2}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \neg Fx \dashv\vdash \neg \exists x Fx \label{eq:3}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x Fx \dashv\vdash \neg \exists x \neg Fx \label{eq:4}&lt;/script&gt;

&lt;h1 id=&quot;intercâmbio-de-quantificadores&quot;&gt;Intercâmbio de quantificadores&lt;/h1&gt;

&lt;p&gt;As últimas equivalências, descritas no Exemplo 3, são mais genéricas do que parecem à primeira vista. De fato, elas são válidas para quaiquer subfórmulas, desde que sejam subfórmulas dependentes da mesma variável. No entanto, para formalizarmos essa ideia, precisamos definir antes alguns conceitos.&lt;/p&gt;

&lt;h2 id=&quot;variáveis-abertas-e-fechadas&quot;&gt;Variáveis abertas e fechadas&lt;/h2&gt;

&lt;p&gt;Consideremos como exemplo simples a fórmula $\forall x Fx$. Pela definição das regras de formação da linguagem da lógica de predicados, sabemos que $Fx$ só faz sentido, se houver antes um quantificador discriminando $x$.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Uma fórmula é dita fechada em relação a uma variável $x$ qualquer, se existe um quantificador associado a tal variável. Exemplo: $\forall x (Fx \land Gx)$&lt;/li&gt;
  &lt;li&gt;Uma fórmula é dita aberta em relação a uma variável $x$ qualquer, se não existe quantificador que discrimine tal variável. Exemplo: $Fx \land Gx$, $\forall y Fxy$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Essa terminologia permite nos referirmos mais facilmente a fórmulas e subfórmulas com a mesma característica em termos de variáveis. Para melhor exemplificar, consideremos a equivalência $\eqref{eq:4}$ descrita anteriormente.&lt;/p&gt;

&lt;p&gt;Nela, podemos nos referir $Fx$ como uma fórmula &lt;strong&gt;aberta em $x$&lt;/strong&gt; enquanto $\forall x Fx$ é uma fórmula &lt;strong&gt;fechada em $x$&lt;/strong&gt;. Obviamente, existem diversas outras fórmulas abertas em $x$. Por exemplo $Fx\land Gx$ e $Fx\to Gx$ são ambas fórmulas abertas em $x$. Ou seja, todas elas compartilham essa mesma característica com $Fx$. Podemos então, expressar ideias como&lt;/p&gt;

&lt;p&gt;“Seja qualquer fórmula $\phi$ que seja aberta em $\beta$”.&lt;/p&gt;

&lt;p&gt;Em que $\beta$ represente qualquer variável, e.g. $x, y, z,\dots$. Isso nos permite generalizar as equivalências $\eqref{eq:1}-\eqref{eq:4}$ para além de $Fx$, da seguinte forma:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \forall \beta \neg \phi \dashv \vdash \exists \beta \phi \label{eq:5}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg \forall \beta \phi \dashv \vdash \exists \beta \neg \phi&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall \beta \neg \phi \dashv\vdash \neg \exists \beta \phi&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall \beta \phi \dashv\vdash \neg \exists \beta \neg \phi \label{eq:8}&lt;/script&gt;

&lt;h2 id=&quot;exemplo&quot;&gt;Exemplo&lt;/h2&gt;

&lt;p&gt;Vejamos um exemplo da aplicação dessa generalização. Considere a forma de argumento a seguir:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x (Fx \to \neg Gx) \vdash \neg \exists x (Fx \land Gx)&lt;/script&gt;

&lt;p&gt;Neste exemplo, $(Fx\to\neg Gx)$ e $(Fx \land Gx)$ são fórmulas abertas em $x$. Se dermos um nome mais simples para cada uma delas, por exemplo, $\phi$ e $\psi$, respectivamente. Então a forma de argumento acima é instância de algo mais genérico&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \phi \vdash \exists x \psi&lt;/script&gt;

&lt;h2 id=&quot;qual-a-utilidade&quot;&gt;Qual a utilidade?&lt;/h2&gt;

&lt;p&gt;A principal utilidade desse tipo de generalização é nos permitir utilizar as equivalências em um contexto amplo, sem necessariamente ter que provar cada uma delas, mostrando que todas são instâncias dos mesmos teoremas. Em outras palavras, se:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall x \neg Fx  \leftrightarrow \neg \exists Fx&lt;/script&gt;

&lt;p&gt;Então o teorema a seguir também é verdadeiro&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall x \neg (Fx \land Gx)  \leftrightarrow \neg \exists (Fx \land Gx)&lt;/script&gt;

&lt;p&gt;pois ambos são instâncias do mesmo teorema genérico.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall \beta \neg \phi \leftrightarrow \neg \exists\beta \phi&lt;/script&gt;

&lt;p&gt;Este tipo de intercâmbio entre equivalências em muitos casos torna as demonstrações muito mais simples.&lt;/p&gt;

&lt;h3 id=&quot;exemplo-1&quot;&gt;Exemplo&lt;/h3&gt;

&lt;p&gt;Demonstre o seguinte teoremas&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \forall x  Fx \lor \exists x \neg Fx&lt;/script&gt;

&lt;p&gt;Iniciaremos com a tautologia&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x Fx \lor \neg \forall x Fx&lt;/script&gt;

&lt;p&gt;A subfórmula $\neg \forall x Fx$ pode ser interpretada como&lt;/p&gt;

&lt;p&gt;“Nem todo x satisfaz o predicado F”&lt;/p&gt;

&lt;p&gt;Que por sua vez é equivalente a dizermos que&lt;/p&gt;

&lt;p&gt;“Existe x que não satisfaz F”&lt;/p&gt;

&lt;p&gt;A segunda versão pode ser escrita simbolicamente como $\exists x \neg Fx$. Esta equivalência está representada em $\eqref{eq:2}$. Substituindo essa equivalência na tautologia acima, produzimos&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x Fx \lor \exists x \neg Fx&lt;/script&gt;

&lt;p&gt;O qual finaliza a demonstração do teorema.&lt;/p&gt;
</description>
        <pubDate>Wed, 18 Oct 2017 10:20:00 -0200</pubDate>
        <link>http://localhost:4000/lc21cp-172/lp-teoremas-equivalencias.html</link>
        <guid isPermaLink="true">http://localhost:4000/lc21cp-172/lp-teoremas-equivalencias.html</guid>
        
        <category>predicados</category>
        
        
        <category>LC21CP-172</category>
        
      </item>
    
  </channel>
</rss>
